<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# iotmakerdockerbuilder

```go
import "github.com/helmutkemper/iotmaker.docker.builder"
```

### Package iotmakerdockerbuilder

English:

### Golang and Docker in a simple way

Documentation in progress

This package facilitates the use of docker containers by golang code\, enabling the creation of unit tests involving containers in linear and chaos scenarios\, enabling the development of microservices and failure simulation\.

Português: Golang e Docker de forma simples\.

Este pacote facilita o uso de containers docker por código golang\, possibilitando a criação de testes unitários envolvendo containers em cenários linear e de caos possibilitando o desenvolvimento de microsserviços e simulação de falha\.

### Transforme teste unitário em cenário de caos

A criação de microsserviços requerem uma nova abordagem de testes\, onde nem sempre\, os testes unitários são fáceis de fazer\.

Imagine um microsserviço simples\, uma simples comunicação gRPC entre duas instâncias do mesmo serviço\.

Como fazer um simples teste para saber se eles se conectam?

Este módulo tem a finalidade de resolver este problema\, adicionando ao código golang de teste a capacidade de criar vários elementos docker de forma muito rápida no meio dos testes unitários\.

Imagine poder criar uma rede docker\, apontar para uma pasta contendo o projeto e subir quantos containers quiser\, com a capacidade de gerar relatórios e simular falhas de comunicação aleatórias com algumas poucas linhas de código\.

### Criando uma rede docker

A rede é opcional e permite controlar melhor o endereço IP de cada instância do serviço em teste\, além de permitir isolar a comunicação entre eles\.

### Exemplo de código para criação de rede

```
package code
import (
	dockerBuilder "github.com/helmutkemper/iotmaker.docker.builder"
	dockerNetwork "github.com/helmutkemper/iotmaker.docker.builder.network"
	"log"
	"testing"
)

func TestCode(t *testing.T) {
	var err error
	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}

	// create a network named cache_delete_after_test, subnet 10.0.0.0/16 e gatway 10.0.0.1
	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
}
```

Uma vez criada a rede\, cada instância do serviço adicionada ao docker ganhará um endereço IP seguindo a ordem de criação da instância\.

Por exemplo\, a primeira instância criada irá para o endereço \`10\.0\.0\.2\` e a seguinte irá para o endereço \`10\.0\.0\.3\`\, e assim por diante\.

Uma vez criada a rede\, basta usar o comando \`container\.SetNetworkDocker\(&netDocker\)\` e a mesma será ligada a nova rede de forma transperente\.

Caso queira trocar o IP de uma instância\, para simular uma troca de IP aleatória\, basta rodar o comando \`container\.NetworkChangeIp\(\)\` e a instância terá o seu IP trocado para o próximo IP da lista\.

### Subindo um container baseado em uma imagem pública

Imagine que o seu projeto necessita de um container \`nats:latest\` para rodar\, logo temos o código golang:

```
package code
import (
	dockerBuilder "github.com/helmutkemper/iotmaker.docker.builder"
	dockerNetwork "github.com/helmutkemper/iotmaker.docker.builder.network"
	"log"
	"testing"
)

func TestCode(t *testing.T) {
	var err error
	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}

	// Create a network named cache_delete_after_test, subnet 10.0.0.0/16 e gatway 10.0.0.1
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}

	// Create a container
	var container = dockerBuilder.ContainerBuilder{}
	// Set image name for docker pull
	container.SetImageName("nats:latest")
	// Expose nats port [optional]
	container.AddPortToExpose("4222")
	// Link container and network [optional] (next ip address is 10.0.0.2)
	container.SetNetworkDocker(&netDocker)
	// Set a container name.
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	container.SetContainerName("container_delete_nats_after_test")
	// Set a waits for the text to appear in the standard container output to proceed [optional]
	container.SetWaitStringWithTimeout("Listening for route connections on 0.0.0.0:6222", 10*time.Second)
	// Inialize the container object
	err = container.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Image nats:latest pull command
	err = container.ImagePull()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Container build and start from image nats:latest
	// Waits for the text "Listening for route connections on 0.0.0.0:6222" to appear  in the standard container
	// output to proceed
	err = container.ContainerBuildFromImage()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
}
```

Como padrão\, todos os parâmetros são adicionados primeiro e em seguida o objeto é inicializado\, com o comando \`container\.Init\(\)\`\.

Como este exemplo usa uma imagem pública\, o primeiro comando é o comando \`container\.ImagePull\(\)\`\, para que a imagem definida em \`container\.SetImageName\("nats:latest"\)\` seja baixada\.

Logo em seguida\, o comando \`container\.ContainerBuildFromImage\(\)\` gera um container de nome \`container\.SetContainerName\("container\_delete\_nats\_after\_test"\)\` e deixa o código parado até a saída padrão do container exibir o texto \[opcional\] \`container\.SetWaitStringWithTimeout\("Listening for route connections on 0\.0\.0\.0:6222"\, 10\*time\.Second\)\`\.

### Subindo um container baseado em uma pasta local com acesso a repositório privado

Esta configuração permite transformar uma pasta local em uma imagem\, de forma simples\, mesmo se o projeto necessitar acessar um repositório git privado\, protegido com chave \`ssh\`

```
package code

import (
	dockerBuilder "github.com/helmutkemper/iotmaker.docker.builder"
	dockerNetwork "github.com/helmutkemper/iotmaker.docker.builder.network"
	"log"
	"testing"
)

func TestCode(t *testing.T) {
	var err error
	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}

	// Create a network named cache_delete_after_test, subnet 10.0.0.0/16 e gatway 10.0.0.1
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}

	// Create a container
	container = dockerBuilder.ContainerBuilder{}
	// Adds an expiration date, in order to prevent the creation of the same image multiple times in a row during the
	// same test [optional]
	container.SetImageExpirationTime(5 * time.Minute)
	// Link container and network [optional] (next ip address is 10.0.0.2)
	container.SetNetworkDocker(netDocker)
	// Print the container's standard output to golang's standard output
	container.SetPrintBuildOnStrOut()
	// Enables the use of the "cache:latest" image [optional].
	// To prevent an image from downloading the same dependency multiple times for each test, you can create an image
	// named "cache:latest" and use this image as the basis for the test images.
	container.SetCacheEnable(true)
	// Determines the name of the image to be created during the test.
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	container.SetImageName("data_rand_pod_image:latest")
	// Determina o nome do container. Lembre-se que ele deve ser único.
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	container.SetContainerName("delete_data_rand_pod_container")
	// Determines the path of the folder where your project is located.
	container.SetBuildFolderPath("./project_folder")
	// Enables the creation of the "Dockerfile-oitmaker" file automatically, as long as the "main.go" and "go.mod" files
	// are in the project root.
	container.MakeDefaultDockerfileForMe()
	// Defines a list of private repositories used in the project. Separate values by a comma.
	container.SetGitPathPrivateRepository("github.com/helmutkemper")
	// Copy the "~/.ssh/id_rsa.pub" and "~/.ssh/known_hosts" credentials into the container.
	// The automatic creation of the container is done in two steps and the credentials are erased when the first image
	// is erased.
	err = container.SetPrivateRepositoryAutoConfig()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Set a waits for the text to appear in the standard container output to proceed [optional]
	container.SetWaitStringWithTimeout("data rand container started", 10*time.Second)
	// It links a folder/file contained on the computer where the test runs and a folder/file contained in the container
	// [optional]
	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./memory/container", "/containerMemory")
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// It links a folder/file contained on the computer where the test runs and a folder/file contained in the container
	// [optional]
	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./memory/config", "/config")
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Inialize the container object
	err = container.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Generates an image from a project folder
	_, err = container.ImageBuildFromFolder()
	if err != nil {
			log.Printf("error: %v", err)
			t.Fail()
	}
	// Container build and start from image nats:latest
	// Waits for the text "data rand container started" to appear  in the standard container
	// output to proceed
	err = container.ContainerBuildFromImage()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
}
```

Os comandos básicos para a criação de imagem são \`container\.SetBuildFolderPath\("\./project\_folder"\)\`\, para definir a pasta local\, onde o projeto se encontra\, e \`container\.ImageBuildFromFolder\(\)\`\, encarregado de transformar o conteúdo da pasta em imagem\.

Caso haja a necessidade de compartilhar conteúdo local com o container\, o comando \`container\.AddFileOrFolderToLinkBetweenConputerHostAndContainer\("\./memory/config"\, "/config"\)\` fará a ligação entre pastas e arquivos no computador local com o container\.

### Criando uma imagem de cache

Em muitos casos de teste\, criar uma imagem de cache ajuda a baixar menos dependência na hora de criar as imagens e deixa o teste mais rápido\.

A forma de fazer isto é bem simples\, basta criar uma imagem de nome \`cache:latest\`\.

```
package code

import (
	dockerBuilder "github.com/helmutkemper/iotmaker.docker.builder"
	"log"
	"testing"
)

func TestCache(t *testing.T) {
	var err error

	// Create a container
	container = dockerBuilder.ContainerBuilder{}
	// Adds an expiration date, in order to prevent the creation of the same image multiple times in a row during the
	// same test [optional]
	container.SetImageExpirationTime(365 * 24 * time.Hour)
	// Print the container's standard output to golang's standard output
	container.SetPrintBuildOnStrOut()
	// Determines the name of the image to be created during the test.
	// Use the term "delete" to enable the function "dockerBuilder.SaGarbageCollector()", which will search for and remove
	// all docker elements with the term "delete" contained in the name. For example, network, image, container and
	// volumes.
	container.SetImageName("cache:latest")
	// Determines the path of the folder where your project is located.
	container.SetBuildFolderPath("./cache_folder")
	// Inialize the container object
	err = container.Init()
	if err != nil {
		log.Printf("error: %v", err)
		t.Fail()
	}
	// Generates an image from a project folder
	_, err = container.ImageBuildFromFolder()
	if err != nil {
			log.Printf("error: %v", err)
			t.Fail()
	}
}
```

A criação da cache é usada em paralelo com os comandos \`container\.SetCacheEnable\(true\)\` e \`container\.MakeDefaultDockerfileForMe\(\)\`\, onde eles vão usar como base a imagem \`cache:latest\` e a imagem de cache será criada em cima da imagem \`golang:1\.17\-alpine\`\.

Caso você não tenha prática em criar imagens\, use o exemplo abaixo\, onde \`RUN go get \.\.\.\` são as dependências usadas por você\.

```
FROM golang:1.17-alpine as builder
RUN mkdir -p /root/.ssh/ && \
		apk update && \
		apk add openssh && \
		apk add --no-cache build-base && \
		apk add --no-cache alpine-sdk && \
		rm -rf /var/cache/apk/*
ARG CGO_ENABLED=0

RUN go get ...
RUN go get ...
RUN go get ...
RUN go get ...
RUN go get ...
```

### Usando repositórios privados

Caso seus projetos necessitem usar repositórios privados\, o comando \`container\.MakeDefaultDockerfileForMe\(\)\` sempre faz a criação da imagem em duas etapas e as credencias de segurança ficam na primeira etapa\, descartada ao final do processo\, evitando uma cópia das suas credencias de segurança em uma imagem pública\.

O comando \`container\.SetPrivateRepositoryAutoConfig\(\)\` copia as suas credenciais de segurança padrão \`\~/\.ssh/id\_rsa\.pub\`\, \`\~/\.ssh/known\_hosts\` e \`\~/\.gitconfig\`

Em seguida\, devemos informar os repositórios privados com o comando \`container\.SetGitPathPrivateRepository\("github\.com/user1\,github\.com/user2"\)\`\.

Caso você tenha problema em baixar repositórios privados\, adicione o cógido abaixo ao arquivo \`\~/\.gitconfig\`

```
[core]
				autocrlf = input
[url "ssh://git@github.com/"]
				insteadOf = https://github.com/
[url "git://"]
				insteadOf = https://
```

Para quem não tem prática em processo de build em duas etapas\, na primeira etapa é criada uma imagem grande com todas as depend6encias e programas necessários para o processode construção do código\. Porém\, ao final do processo\, apenas o binário gerado na primeira etapa é copiado para uma imagem nova\, o que deixa a imagem final pequena\.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func ConfigChaosScene(sceneName string, maxStopedContainers, maxPausedContainers, maxTotalPausedAndStoppedContainers int)](<#func-configchaosscene>)
- [func SaGarbageCollector(names ...string)](<#func-sagarbagecollector>)
- [func SaImageMakeCache(projectPath, cacheName string, expirationDate time.Duration) (err error)](<#func-saimagemakecache>)
- [func SaImageMakeCacheWithDefaultName(projectPath string, expirationDate time.Duration) (err error)](<#func-saimagemakecachewithdefaultname>)
- [func init()](<#func-init>)
- [type BlkioStatEntry](<#type-blkiostatentry>)
- [type BlkioStats](<#type-blkiostats>)
- [type CPUStats](<#type-cpustats>)
- [type CPUUsage](<#type-cpuusage>)
- [type ContainerBuilder](<#type-containerbuilder>)
  - [func (e *ContainerBuilder) AddFailMatchFlag(value string)](<#func-containerbuilder-addfailmatchflag>)
  - [func (e *ContainerBuilder) AddFailMatchFlagToFileLog(value, logDirectoryPath string) (err error)](<#func-containerbuilder-addfailmatchflagtofilelog>)
  - [func (e *ContainerBuilder) AddFileOrFolderToLinkBetweenConputerHostAndContainer(computerHostPath, insideContainerPath string) (err error)](<#func-containerbuilder-addfileorfoldertolinkbetweenconputerhostandcontainer>)
  - [func (e *ContainerBuilder) AddFilterToCvsLog(label, match, filter string)](<#func-containerbuilder-addfiltertocvslog>)
  - [func (e *ContainerBuilder) AddFilterToCvsLogWithReplace(label, match, filter, search, replace string)](<#func-containerbuilder-addfiltertocvslogwithreplace>)
  - [func (e *ContainerBuilder) AddFilterToFail(match, filter, search, replace string)](<#func-containerbuilder-addfiltertofail>)
  - [func (e *ContainerBuilder) AddFilterToRestartContainer(match, filter, search, replace string)](<#func-containerbuilder-addfiltertorestartcontainer>)
  - [func (e *ContainerBuilder) AddFilterToStartChaos(match, filter, search, replace string)](<#func-containerbuilder-addfiltertostartchaos>)
  - [func (e *ContainerBuilder) AddFilterToSuccess(match, filter, search, replace string)](<#func-containerbuilder-addfiltertosuccess>)
  - [func (e *ContainerBuilder) AddImageBuildOptionsBuildArgs(key string, value *string)](<#func-containerbuilder-addimagebuildoptionsbuildargs>)
  - [func (e *ContainerBuilder) AddPortToChange(imagePort string, newPort string)](<#func-containerbuilder-addporttochange>)
  - [func (e *ContainerBuilder) AddPortToDockerfileExpose(value string)](<#func-containerbuilder-addporttodockerfileexpose>)
  - [func (e *ContainerBuilder) AddPortToExpose(value string)](<#func-containerbuilder-addporttoexpose>)
  - [func (e *ContainerBuilder) AddRestartMatchFlag(value string)](<#func-containerbuilder-addrestartmatchflag>)
  - [func (e *ContainerBuilder) AddRestartMatchFlagToFileLog(value, logDirectoryPath string) (err error)](<#func-containerbuilder-addrestartmatchflagtofilelog>)
  - [func (e *ContainerBuilder) AddStartChaosMatchFlag(value string)](<#func-containerbuilder-addstartchaosmatchflag>)
  - [func (e *ContainerBuilder) AddStartChaosMatchFlagToFileLog(value, logDirectoryPath string) (err error)](<#func-containerbuilder-addstartchaosmatchflagtofilelog>)
  - [func (e *ContainerBuilder) AddSuccessMatchFlag(value string)](<#func-containerbuilder-addsuccessmatchflag>)
  - [func (e *ContainerBuilder) ContainerBuildAndStartFromImage() (err error)](<#func-containerbuilder-containerbuildandstartfromimage>)
  - [func (e *ContainerBuilder) ContainerBuildWithoutStartingItFromImage() (err error)](<#func-containerbuilder-containerbuildwithoutstartingitfromimage>)
  - [func (e *ContainerBuilder) ContainerCopyFrom(containerPathList []string, hostPathList []string) (statsList []types.ContainerPathStat, err error)](<#func-containerbuilder-containercopyfrom>)
  - [func (e *ContainerBuilder) ContainerCopyTo(hostPathList []string, containerPathList []string) (err error)](<#func-containerbuilder-containercopyto>)
  - [func (e *ContainerBuilder) ContainerExecCommand(commands []string) (exitCode int, runing bool, stdOutput []byte, stdError []byte, err error)](<#func-containerbuilder-containerexeccommand>)
  - [func (e *ContainerBuilder) ContainerFindIdByName(name string) (id string, err error)](<#func-containerbuilder-containerfindidbyname>)
  - [func (e *ContainerBuilder) ContainerFindIdByNameContains(containsName string) (list []NameAndId, err error)](<#func-containerbuilder-containerfindidbynamecontains>)
  - [func (e *ContainerBuilder) ContainerInspect() (inspect ContainerInspect, err error)](<#func-containerbuilder-containerinspect>)
  - [func (e *ContainerBuilder) ContainerPause() (err error)](<#func-containerbuilder-containerpause>)
  - [func (e *ContainerBuilder) ContainerRemove(removeVolumes bool) (err error)](<#func-containerbuilder-containerremove>)
  - [func (e *ContainerBuilder) ContainerRestart() (err error)](<#func-containerbuilder-containerrestart>)
  - [func (e *ContainerBuilder) ContainerRestartWithTimeout(timeout time.Duration) (err error)](<#func-containerbuilder-containerrestartwithtimeout>)
  - [func (e *ContainerBuilder) ContainerSetDisabePauseOnChaosScene(value bool)](<#func-containerbuilder-containersetdisabepauseonchaosscene>)
  - [func (e *ContainerBuilder) ContainerSetDisabeStopOnChaosScene(value bool)](<#func-containerbuilder-containersetdisabestoponchaosscene>)
  - [func (e *ContainerBuilder) ContainerStart() (err error)](<#func-containerbuilder-containerstart>)
  - [func (e *ContainerBuilder) ContainerStartAfterBuild() (err error)](<#func-containerbuilder-containerstartafterbuild>)
  - [func (e *ContainerBuilder) ContainerStatisticsOneShot() (stats types.Stats, err error)](<#func-containerbuilder-containerstatisticsoneshot>)
  - [func (e *ContainerBuilder) ContainerStop() (err error)](<#func-containerbuilder-containerstop>)
  - [func (e *ContainerBuilder) ContainerUnpause() (err error)](<#func-containerbuilder-containerunpause>)
  - [func (e *ContainerBuilder) EnableChaosScene(enable bool)](<#func-containerbuilder-enablechaosscene>)
  - [func (e *ContainerBuilder) FindCurrentIPV4Address() (IP string, err error)](<#func-containerbuilder-findcurrentipv4address>)
  - [func (e *ContainerBuilder) FindTextInsideContainerLog(value string) (contains bool, err error)](<#func-containerbuilder-findtextinsidecontainerlog>)
  - [func (e *ContainerBuilder) GetBuildFolderPath() (buildPath string)](<#func-containerbuilder-getbuildfolderpath>)
  - [func (e *ContainerBuilder) GetChannelEvent() (channel *chan ContainerPullStatusSendToChannel)](<#func-containerbuilder-getchannelevent>)
  - [func (e *ContainerBuilder) GetChannelOnContainerInspect() (channel *chan bool)](<#func-containerbuilder-getchanneloncontainerinspect>)
  - [func (e *ContainerBuilder) GetChannelOnContainerReady() (channel *chan bool)](<#func-containerbuilder-getchanneloncontainerready>)
  - [func (e *ContainerBuilder) GetChaosEvent() (eventChannel chan Event)](<#func-containerbuilder-getchaosevent>)
  - [func (e *ContainerBuilder) GetContainerID() (ID string)](<#func-containerbuilder-getcontainerid>)
  - [func (e *ContainerBuilder) GetContainerInfo() (info types.Info, err error)](<#func-containerbuilder-getcontainerinfo>)
  - [func (e ContainerBuilder) GetContainerIsStarted() (started bool)](<#func-containerbuilder-getcontainerisstarted>)
  - [func (e *ContainerBuilder) GetContainerLog() (log []byte, err error)](<#func-containerbuilder-getcontainerlog>)
  - [func (e *ContainerBuilder) GetContainerName() (containerName string)](<#func-containerbuilder-getcontainername>)
  - [func (e *ContainerBuilder) GetFailFlag() (fail bool)](<#func-containerbuilder-getfailflag>)
  - [func (e *ContainerBuilder) GetGitCloneToBuild() (url string)](<#func-containerbuilder-getgitclonetobuild>)
  - [func (e *ContainerBuilder) GetIPV4Address() (IP string)](<#func-containerbuilder-getipv4address>)
  - [func (e *ContainerBuilder) GetImageArchitecture() (architecture string)](<#func-containerbuilder-getimagearchitecture>)
  - [func (e *ContainerBuilder) GetImageAuthor() (author string)](<#func-containerbuilder-getimageauthor>)
  - [func (e *ContainerBuilder) GetImageCacheName() (name string)](<#func-containerbuilder-getimagecachename>)
  - [func (e *ContainerBuilder) GetImageComment() (comment string)](<#func-containerbuilder-getimagecomment>)
  - [func (e *ContainerBuilder) GetImageContainer() (imageName string)](<#func-containerbuilder-getimagecontainer>)
  - [func (e *ContainerBuilder) GetImageCreatedTime() (created time.Time)](<#func-containerbuilder-getimagecreatedtime>)
  - [func (e *ContainerBuilder) GetImageExpirationTime() (expiration time.Duration)](<#func-containerbuilder-getimageexpirationtime>)
  - [func (e *ContainerBuilder) GetImageID() (ID string)](<#func-containerbuilder-getimageid>)
  - [func (e *ContainerBuilder) GetImageName() (name string)](<#func-containerbuilder-getimagename>)
  - [func (e *ContainerBuilder) GetImageOs() (os string)](<#func-containerbuilder-getimageos>)
  - [func (e *ContainerBuilder) GetImageOsVersion() (osVersion string)](<#func-containerbuilder-getimageosversion>)
  - [func (e *ContainerBuilder) GetImageParent() (parent string)](<#func-containerbuilder-getimageparent>)
  - [func (e *ContainerBuilder) GetImageRepoDigests() (repoDigests []string)](<#func-containerbuilder-getimagerepodigests>)
  - [func (e *ContainerBuilder) GetImageRepoTags() (repoTags []string)](<#func-containerbuilder-getimagerepotags>)
  - [func (e *ContainerBuilder) GetImageSize() (size int64)](<#func-containerbuilder-getimagesize>)
  - [func (e *ContainerBuilder) GetImageVariant() (variant string)](<#func-containerbuilder-getimagevariant>)
  - [func (e *ContainerBuilder) GetImageVirtualSize() (virtualSize int64)](<#func-containerbuilder-getimagevirtualsize>)
  - [func (e *ContainerBuilder) GetInitialized() (initialized bool)](<#func-containerbuilder-getinitialized>)
  - [func (e *ContainerBuilder) GetLastInspect() (inspect ContainerInspect)](<#func-containerbuilder-getlastinspect>)
  - [func (e *ContainerBuilder) GetLastLineOfOccurrenceBySearchTextInsideContainerLog(value string) (text string, contains bool, err error)](<#func-containerbuilder-getlastlineofoccurrencebysearchtextinsidecontainerlog>)
  - [func (e *ContainerBuilder) GetLastLogs() (logs string)](<#func-containerbuilder-getlastlogs>)
  - [func (e *ContainerBuilder) GetMetadata() (metadata map[string]interface{})](<#func-containerbuilder-getmetadata>)
  - [func (e *ContainerBuilder) GetNetworkGatewayIPV4() (IPV4 string)](<#func-containerbuilder-getnetworkgatewayipv4>)
  - [func (e *ContainerBuilder) GetNetworkGatewayIPV4ByNetworkName(networkName string) (IPV4 string, err error)](<#func-containerbuilder-getnetworkgatewayipv4bynetworkname>)
  - [func (e *ContainerBuilder) GetNetworkIPV4() (IPV4 string)](<#func-containerbuilder-getnetworkipv4>)
  - [func (e *ContainerBuilder) GetNetworkIPV4ByNetworkName(networkName string) (IPV4 string, err error)](<#func-containerbuilder-getnetworkipv4bynetworkname>)
  - [func (e *ContainerBuilder) GetNetworkInterface() (network isolatedNetwork.ContainerBuilderNetworkInterface)](<#func-containerbuilder-getnetworkinterface>)
  - [func (e *ContainerBuilder) GetProblem() (problem string)](<#func-containerbuilder-getproblem>)
  - [func (e *ContainerBuilder) GetSuccessFlag() (success bool)](<#func-containerbuilder-getsuccessflag>)
  - [func (e *ContainerBuilder) ImageBuildFromFolder() (inspect types.ImageInspect, err error)](<#func-containerbuilder-imagebuildfromfolder>)
  - [func (e *ContainerBuilder) ImageBuildFromServer() (inspect types.ImageInspect, err error)](<#func-containerbuilder-imagebuildfromserver>)
  - [func (e *ContainerBuilder) ImageFindIdByName(name string) (id string, err error)](<#func-containerbuilder-imagefindidbyname>)
  - [func (e *ContainerBuilder) ImageFindIdByNameContains(containsName string) (list []NameAndId, err error)](<#func-containerbuilder-imagefindidbynamecontains>)
  - [func (e *ContainerBuilder) ImageInspect() (inspect types.ImageInspect, err error)](<#func-containerbuilder-imageinspect>)
  - [func (e *ContainerBuilder) ImageListExposedPorts() (portList []nat.Port, err error)](<#func-containerbuilder-imagelistexposedports>)
  - [func (e *ContainerBuilder) ImageListExposedVolumes() (list []string, err error)](<#func-containerbuilder-imagelistexposedvolumes>)
  - [func (e *ContainerBuilder) ImagePull() (err error)](<#func-containerbuilder-imagepull>)
  - [func (e *ContainerBuilder) ImageRemove() (err error)](<#func-containerbuilder-imageremove>)
  - [func (e *ContainerBuilder) ImageRemoveByName(name string) (err error)](<#func-containerbuilder-imageremovebyname>)
  - [func (e *ContainerBuilder) Init() (err error)](<#func-containerbuilder-init>)
  - [func (e *ContainerBuilder) MakeDefaultDockerfileForMe()](<#func-containerbuilder-makedefaultdockerfileforme>)
  - [func (e *ContainerBuilder) MakeDefaultDockerfileForMeWithInstallExtras()](<#func-containerbuilder-makedefaultdockerfileformewithinstallextras>)
  - [func (e *ContainerBuilder) NetworkChangeIp() (err error)](<#func-containerbuilder-networkchangeip>)
  - [func (e *ContainerBuilder) RemoveAllByNameContains(value string) (err error)](<#func-containerbuilder-removeallbynamecontains>)
  - [func (e *ContainerBuilder) SetBuildFolderPath(value string)](<#func-containerbuilder-setbuildfolderpath>)
  - [func (e *ContainerBuilder) SetCacheEnable(value bool)](<#func-containerbuilder-setcacheenable>)
  - [func (e *ContainerBuilder) SetContainerAttachStandardStreamsToTty(value bool)](<#func-containerbuilder-setcontainerattachstandardstreamstotty>)
  - [func (e *ContainerBuilder) SetContainerCommandToRunWhenStartingTheContainer(values []string)](<#func-containerbuilder-setcontainercommandtorunwhenstartingthecontainer>)
  - [func (e *ContainerBuilder) SetContainerEntrypointToRunWhenStartingTheContainer(values []string)](<#func-containerbuilder-setcontainerentrypointtorunwhenstartingthecontainer>)
  - [func (e *ContainerBuilder) SetContainerHealthcheck(value *HealthConfig)](<#func-containerbuilder-setcontainerhealthcheck>)
  - [func (e *ContainerBuilder) SetContainerName(value string)](<#func-containerbuilder-setcontainername>)
  - [func (e *ContainerBuilder) SetContainerRestartPolicyAlways()](<#func-containerbuilder-setcontainerrestartpolicyalways>)
  - [func (e *ContainerBuilder) SetContainerRestartPolicyNo()](<#func-containerbuilder-setcontainerrestartpolicyno>)
  - [func (e *ContainerBuilder) SetContainerRestartPolicyOnFailure()](<#func-containerbuilder-setcontainerrestartpolicyonfailure>)
  - [func (e *ContainerBuilder) SetContainerRestartPolicyUnlessStopped()](<#func-containerbuilder-setcontainerrestartpolicyunlessstopped>)
  - [func (e *ContainerBuilder) SetContainerShellForShellFormOfRunCmdEntrypoint(values []string)](<#func-containerbuilder-setcontainershellforshellformofruncmdentrypoint>)
  - [func (e *ContainerBuilder) SetCsvFileReader(value bool)](<#func-containerbuilder-setcsvfilereader>)
  - [func (e *ContainerBuilder) SetCsvFileRowSeparator(value string)](<#func-containerbuilder-setcsvfilerowseparator>)
  - [func (e *ContainerBuilder) SetCsvFileRowsToPrint(value int64)](<#func-containerbuilder-setcsvfilerowstoprint>)
  - [func (e *ContainerBuilder) SetCsvFileValueSeparator(value string)](<#func-containerbuilder-setcsvfilevalueseparator>)
  - [func (e *ContainerBuilder) SetCsvLogPath(path string, removeOldFile bool)](<#func-containerbuilder-setcsvlogpath>)
  - [func (e *ContainerBuilder) SetDockerfileBuilder(value DockerfileAuto)](<#func-containerbuilder-setdockerfilebuilder>)
  - [func (e *ContainerBuilder) SetEnvironmentVar(value []string)](<#func-containerbuilder-setenvironmentvar>)
  - [func (e *ContainerBuilder) SetGitCloneToBuild(url string)](<#func-containerbuilder-setgitclonetobuild>)
  - [func (e *ContainerBuilder) SetGitCloneToBuildWithPrivateSSHKey(url, privateSSHKeyPath, password string)](<#func-containerbuilder-setgitclonetobuildwithprivatesshkey>)
  - [func (e *ContainerBuilder) SetGitCloneToBuildWithPrivateToken(url, privateToken string)](<#func-containerbuilder-setgitclonetobuildwithprivatetoken>)
  - [func (e *ContainerBuilder) SetGitCloneToBuildWithUserPassworh(url, user, password string)](<#func-containerbuilder-setgitclonetobuildwithuserpassworh>)
  - [func (e *ContainerBuilder) SetGitConfigFile(value string)](<#func-containerbuilder-setgitconfigfile>)
  - [func (e *ContainerBuilder) SetGitPathPrivateRepository(value string)](<#func-containerbuilder-setgitpathprivaterepository>)
  - [func (e *ContainerBuilder) SetGitSshPassword(password string)](<#func-containerbuilder-setgitsshpassword>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCPUPeriod(value int64)](<#func-containerbuilder-setimagebuildoptionscpuperiod>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCPUQuota(value int64)](<#func-containerbuilder-setimagebuildoptionscpuquota>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCPUSetCPUs(value string)](<#func-containerbuilder-setimagebuildoptionscpusetcpus>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCPUSetMems(value string)](<#func-containerbuilder-setimagebuildoptionscpusetmems>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCPUShares(value int64)](<#func-containerbuilder-setimagebuildoptionscpushares>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsCacheFrom(values []string)](<#func-containerbuilder-setimagebuildoptionscachefrom>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsExtraHosts(values []string)](<#func-containerbuilder-setimagebuildoptionsextrahosts>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsIsolationDefault()](<#func-containerbuilder-setimagebuildoptionsisolationdefault>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsIsolationHyperV()](<#func-containerbuilder-setimagebuildoptionsisolationhyperv>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsIsolationProcess()](<#func-containerbuilder-setimagebuildoptionsisolationprocess>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsMemory(value int64)](<#func-containerbuilder-setimagebuildoptionsmemory>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsMemorySwap(value int64)](<#func-containerbuilder-setimagebuildoptionsmemoryswap>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsNoCache()](<#func-containerbuilder-setimagebuildoptionsnocache>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsPlatform(value string)](<#func-containerbuilder-setimagebuildoptionsplatform>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsSecurityOpt(value []string)](<#func-containerbuilder-setimagebuildoptionssecurityopt>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsSquash(value bool)](<#func-containerbuilder-setimagebuildoptionssquash>)
  - [func (e *ContainerBuilder) SetImageBuildOptionsTarget(value string)](<#func-containerbuilder-setimagebuildoptionstarget>)
  - [func (e *ContainerBuilder) SetImageCacheName(name string)](<#func-containerbuilder-setimagecachename>)
  - [func (e *ContainerBuilder) SetImageExpirationTime(expiration time.Duration)](<#func-containerbuilder-setimageexpirationtime>)
  - [func (e *ContainerBuilder) SetImageName(value string)](<#func-containerbuilder-setimagename>)
  - [func (e *ContainerBuilder) SetInspectInterval(value time.Duration)](<#func-containerbuilder-setinspectinterval>)
  - [func (e *ContainerBuilder) SetMetadata(metadata map[string]interface{})](<#func-containerbuilder-setmetadata>)
  - [func (e *ContainerBuilder) SetNetworkDocker(network isolatedNetwork.ContainerBuilderNetworkInterface)](<#func-containerbuilder-setnetworkdocker>)
  - [func (e *ContainerBuilder) SetOnBuild(onBuild []string)](<#func-containerbuilder-setonbuild>)
  - [func (e *ContainerBuilder) SetOpenAllContainersPorts()](<#func-containerbuilder-setopenallcontainersports>)
  - [func (e *ContainerBuilder) SetPrintBuildOnStrOut()](<#func-containerbuilder-setprintbuildonstrout>)
  - [func (e *ContainerBuilder) SetPrivateRepositoryAutoConfig() (err error)](<#func-containerbuilder-setprivaterepositoryautoconfig>)
  - [func (e *ContainerBuilder) SetRestartProbability(restartProbability, restartChangeIpProbability float64, limit int)](<#func-containerbuilder-setrestartprobability>)
  - [func (e *ContainerBuilder) SetSceneNameOnChaosScene(name string)](<#func-containerbuilder-setscenenameonchaosscene>)
  - [func (e *ContainerBuilder) SetSshIdRsaFile(value string)](<#func-containerbuilder-setsshidrsafile>)
  - [func (e *ContainerBuilder) SetSshKnownHostsFile(value string)](<#func-containerbuilder-setsshknownhostsfile>)
  - [func (e *ContainerBuilder) SetTimeBeforeStartChaosInThisContainerOnChaosScene(min, max time.Duration)](<#func-containerbuilder-settimebeforestartchaosinthiscontaineronchaosscene>)
  - [func (e *ContainerBuilder) SetTimeOnContainerPausedStateOnChaosScene(min, max time.Duration)](<#func-containerbuilder-settimeoncontainerpausedstateonchaosscene>)
  - [func (e *ContainerBuilder) SetTimeOnContainerUnpausedStateOnChaosScene(min, max time.Duration)](<#func-containerbuilder-settimeoncontainerunpausedstateonchaosscene>)
  - [func (e *ContainerBuilder) SetTimeToRestartThisContainerAfterStopEventOnChaosScene(min, max time.Duration)](<#func-containerbuilder-settimetorestartthiscontainerafterstopeventonchaosscene>)
  - [func (e *ContainerBuilder) SetTimeToStartChaosOnChaosScene(min, max time.Duration)](<#func-containerbuilder-settimetostartchaosonchaosscene>)
  - [func (e *ContainerBuilder) SetWaitString(value string)](<#func-containerbuilder-setwaitstring>)
  - [func (e *ContainerBuilder) SetWaitStringWithTimeout(value string, timeout time.Duration)](<#func-containerbuilder-setwaitstringwithtimeout>)
  - [func (e *ContainerBuilder) SizeToString(value int64) (size string)](<#func-containerbuilder-sizetostring>)
  - [func (e *ContainerBuilder) StartMonitor()](<#func-containerbuilder-startmonitor>)
  - [func (e *ContainerBuilder) StopMonitor() (err error)](<#func-containerbuilder-stopmonitor>)
  - [func (e ContainerBuilder) TestDockerInstall() (err error)](<#func-containerbuilder-testdockerinstall>)
  - [func (e *ContainerBuilder) WaitForTextInContainerLog(value string) (dockerLogs string, err error)](<#func-containerbuilder-waitfortextincontainerlog>)
  - [func (e *ContainerBuilder) WaitForTextInContainerLogWithTimeout(value string, timeout time.Duration) (dockerLogs string, err error)](<#func-containerbuilder-waitfortextincontainerlogwithtimeout>)
  - [func (e *ContainerBuilder) addImageBuildOptionsGitCredentials() (buildOptions types.ImageBuildOptions)](<#func-containerbuilder-addimagebuildoptionsgitcredentials>)
  - [func (e *ContainerBuilder) addProblem(problem string)](<#func-containerbuilder-addproblem>)
  - [func (e *ContainerBuilder) findCurrentIPV4AddressSupport(networkID string) (IP string, err error)](<#func-containerbuilder-findcurrentipv4addresssupport>)
  - [func (e *ContainerBuilder) getIdByContainerName() (err error)](<#func-containerbuilder-getidbycontainername>)
  - [func (e *ContainerBuilder) getProbalityNumber() (probality float64)](<#func-containerbuilder-getprobalitynumber>)
  - [func (e *ContainerBuilder) getRandSeed() (seed *rand.Rand)](<#func-containerbuilder-getrandseed>)
  - [func (e *ContainerBuilder) gitMakePublicSshKey() (publicKeys *ssh.PublicKeys, err error)](<#func-containerbuilder-gitmakepublicsshkey>)
  - [func (e *ContainerBuilder) imageExpirationTimeIsValid() (valid bool)](<#func-containerbuilder-imageexpirationtimeisvalid>)
  - [func (e *ContainerBuilder) incIpV4Address(ip string, inc int64) (next string, err error)](<#func-containerbuilder-incipv4address>)
  - [func (e *ContainerBuilder) logsCleaner(logs []byte) (logsLine [][]byte)](<#func-containerbuilder-logscleaner>)
  - [func (e *ContainerBuilder) logsSearchAndReplaceIntoText(logs *[]byte, lineList [][]byte, configuration []LogFilter) (line []byte, found bool)](<#func-containerbuilder-logssearchandreplaceintotext>)
  - [func (e *ContainerBuilder) managerChaos()](<#func-containerbuilder-managerchaos>)
  - [func (e *ContainerBuilder) selectBetweenMaxAndMin(max, min time.Duration) (selected time.Duration)](<#func-containerbuilder-selectbetweenmaxandmin>)
  - [func (e *ContainerBuilder) stopMonitorAfterStopped() (err error)](<#func-containerbuilder-stopmonitorafterstopped>)
  - [func (e ContainerBuilder) traceCodeLine() (file string, line int)](<#func-containerbuilder-tracecodeline>)
  - [func (e *ContainerBuilder) verifyImageName() (err error)](<#func-containerbuilder-verifyimagename>)
  - [func (e *ContainerBuilder) verifyStatusError(inspect ContainerInspect) (hasError bool)](<#func-containerbuilder-verifystatuserror>)
  - [func (e *ContainerBuilder) writeAggregatePreCPUTimeTheContainerWasThrottled(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeaggregateprecputimethecontainerwasthrottled>)
  - [func (e *ContainerBuilder) writeAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeaggregatetimethecontainerwasthrottledforinnanoseconds>)
  - [func (e *ContainerBuilder) writeBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioiomergedrecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioioqueuedrecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioioservicebytesrecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioioservicetimerecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioioservicedrecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioiotimerecursive>)
  - [func (e *ContainerBuilder) writeBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkioiowaittimerecursive>)
  - [func (e *ContainerBuilder) writeBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeblkiosectorsrecursive>)
  - [func (e *ContainerBuilder) writeCommittedBytes(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writecommittedbytes>)
  - [func (e *ContainerBuilder) writeConstAggregatePreCPUTimeTheContainerWasThrottled(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstaggregateprecputimethecontainerwasthrottled>)
  - [func (e *ContainerBuilder) writeConstAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstaggregatetimethecontainerwasthrottledforinnanoseconds>)
  - [func (e *ContainerBuilder) writeConstBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioiomergedrecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioioqueuedrecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioioservicebytesrecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioioservicetimerecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioioservicedrecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioiotimerecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkioiowaittimerecursive>)
  - [func (e *ContainerBuilder) writeConstBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeconstblkiosectorsrecursive>)
  - [func (e *ContainerBuilder) writeConstCommittedBytes(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstcommittedbytes>)
  - [func (e *ContainerBuilder) writeConstCurrentNumberOfOidsInTheCGroup(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstcurrentnumberofoidsinthecgroup>)
  - [func (e *ContainerBuilder) writeConstCurrentResCounterUsageForMemory(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstcurrentrescounterusageformemory>)
  - [func (e *ContainerBuilder) writeConstFilterIntoLog(file *os.File, filter []LogFilter) (tab bool, err error)](<#func-containerbuilder-writeconstfilterintolog>)
  - [func (e *ContainerBuilder) writeConstLimitOnTheNumberOfPidsInTheCGroup(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstlimitonthenumberofpidsinthecgroup>)
  - [func (e *ContainerBuilder) writeConstMaximumUsageEverRecorded(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstmaximumusageeverrecorded>)
  - [func (e *ContainerBuilder) writeConstMemoryLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstmemorylimit>)
  - [func (e *ContainerBuilder) writeConstNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstnumberofperiodswhenthecontainerhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeConstNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstnumberofperiodswhenthecontainerprecpuhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeConstNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstnumberofperiodswithprecputhrottlingactive>)
  - [func (e *ContainerBuilder) writeConstNumberOfPeriodsWithThrottlingActive(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstnumberofperiodswiththrottlingactive>)
  - [func (e *ContainerBuilder) writeConstNumberOfTimesMemoryUsageHitsLimits(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstnumberoftimesmemoryusagehitslimits>)
  - [func (e *ContainerBuilder) writeConstOnlineCPUs(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstonlinecpus>)
  - [func (e *ContainerBuilder) writeConstOnlinePreCPUs(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstonlineprecpus>)
  - [func (e *ContainerBuilder) writeConstPeakCommittedBytes(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstpeakcommittedbytes>)
  - [func (e *ContainerBuilder) writeConstPreCPUSystemUsage(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstprecpusystemusage>)
  - [func (e *ContainerBuilder) writeConstPrivateWorkingSet(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstprivateworkingset>)
  - [func (e *ContainerBuilder) writeConstReadingTime(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstreadingtime>)
  - [func (e *ContainerBuilder) writeConstSystemUsage(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconstsystemusage>)
  - [func (e *ContainerBuilder) writeConstTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttimespentbyprecputasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeConstTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttimespentbyprecputasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeConstTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttimespentbytasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeConstTimeSpentByTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttimespentbytasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeConstTotalCPUTimeConsumed(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttotalcputimeconsumed>)
  - [func (e *ContainerBuilder) writeConstTotalCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttotalcputimeconsumedpercore>)
  - [func (e *ContainerBuilder) writeConstTotalPreCPUTimeConsumed(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttotalprecputimeconsumed>)
  - [func (e *ContainerBuilder) writeConstTotalPreCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)](<#func-containerbuilder-writeconsttotalprecputimeconsumedpercore>)
  - [func (e *ContainerBuilder) writeContainerConstToFile(file *os.File, stats *types.Stats) (err error)](<#func-containerbuilder-writecontainerconsttofile>)
  - [func (e *ContainerBuilder) writeContainerLabelToFile(file *os.File, stats *types.Stats) (err error)](<#func-containerbuilder-writecontainerlabeltofile>)
  - [func (e *ContainerBuilder) writeContainerLogToFile(path string, lineList [][]byte) (err error)](<#func-containerbuilder-writecontainerlogtofile>)
  - [func (e *ContainerBuilder) writeContainerStatsToFile(file *os.File, stats *types.Stats, lineList *[][]byte) (err error)](<#func-containerbuilder-writecontainerstatstofile>)
  - [func (e *ContainerBuilder) writeCurrentNumberOfOidsInTheCGroup(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writecurrentnumberofoidsinthecgroup>)
  - [func (e *ContainerBuilder) writeCurrentResCounterUsageForMemory(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writecurrentrescounterusageformemory>)
  - [func (e *ContainerBuilder) writeFilterIntoLog(file *os.File, filter []LogFilter, lineList *[][]byte) (tab bool, err error)](<#func-containerbuilder-writefilterintolog>)
  - [func (e *ContainerBuilder) writeLabelAggregatePreCPUTimeTheContainerWasThrottled(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelaggregateprecputimethecontainerwasthrottled>)
  - [func (e *ContainerBuilder) writeLabelAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelaggregatetimethecontainerwasthrottledforinnanoseconds>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioiomergedrecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioioqueuedrecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioioservicebytesrecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioioservicetimerecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioioservicedrecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioiotimerecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkioiowaittimerecursive>)
  - [func (e *ContainerBuilder) writeLabelBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelabelblkiosectorsrecursive>)
  - [func (e *ContainerBuilder) writeLabelCommittedBytes(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelcommittedbytes>)
  - [func (e *ContainerBuilder) writeLabelCurrentNumberOfOidsInTheCGroup(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelcurrentnumberofoidsinthecgroup>)
  - [func (e *ContainerBuilder) writeLabelCurrentResCounterUsageForMemory(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelcurrentrescounterusageformemory>)
  - [func (e *ContainerBuilder) writeLabelFilterIntoLog(file *os.File, filter []LogFilter) (tab bool, err error)](<#func-containerbuilder-writelabelfilterintolog>)
  - [func (e *ContainerBuilder) writeLabelLimitOnTheNumberOfPidsInTheCGroup(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabellimitonthenumberofpidsinthecgroup>)
  - [func (e *ContainerBuilder) writeLabelMaximumUsageEverRecorded(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelmaximumusageeverrecorded>)
  - [func (e *ContainerBuilder) writeLabelMemoryLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelmemorylimit>)
  - [func (e *ContainerBuilder) writeLabelNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelnumberofperiodswhenthecontainerhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeLabelNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelnumberofperiodswhenthecontainerprecpuhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeLabelNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelnumberofperiodswithprecputhrottlingactive>)
  - [func (e *ContainerBuilder) writeLabelNumberOfPeriodsWithThrottlingActive(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelnumberofperiodswiththrottlingactive>)
  - [func (e *ContainerBuilder) writeLabelNumberOfTimesMemoryUsageHitsLimits(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelnumberoftimesmemoryusagehitslimits>)
  - [func (e *ContainerBuilder) writeLabelOnlineCPUs(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelonlinecpus>)
  - [func (e *ContainerBuilder) writeLabelOnlinePreCPUs(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelonlineprecpus>)
  - [func (e *ContainerBuilder) writeLabelPeakCommittedBytes(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelpeakcommittedbytes>)
  - [func (e *ContainerBuilder) writeLabelPreCPUSystemUsage(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelprecpusystemusage>)
  - [func (e *ContainerBuilder) writeLabelPrivateWorkingSet(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelprivateworkingset>)
  - [func (e *ContainerBuilder) writeLabelReadingTime(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelreadingtime>)
  - [func (e *ContainerBuilder) writeLabelSystemUsage(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabelsystemusage>)
  - [func (e *ContainerBuilder) writeLabelTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltimespentbyprecputasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeLabelTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltimespentbyprecputasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeLabelTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltimespentbytasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeLabelTimeSpentByTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltimespentbytasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeLabelTotalCPUTimeConsumed(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltotalcputimeconsumed>)
  - [func (e *ContainerBuilder) writeLabelTotalCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltotalcputimeconsumedpercore>)
  - [func (e *ContainerBuilder) writeLabelTotalPreCPUTimeConsumed(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltotalprecputimeconsumed>)
  - [func (e *ContainerBuilder) writeLabelTotalPreCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)](<#func-containerbuilder-writelabeltotalprecputimeconsumedpercore>)
  - [func (e *ContainerBuilder) writeLimitOnTheNumberOfPidsInTheCGroup(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writelimitonthenumberofpidsinthecgroup>)
  - [func (e *ContainerBuilder) writeMaximumUsageEverRecorded(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writemaximumusageeverrecorded>)
  - [func (e *ContainerBuilder) writeMemoryLimit(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writememorylimit>)
  - [func (e *ContainerBuilder) writeNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writenumberofperiodswhenthecontainerhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writenumberofperiodswhenthecontainerprecpuhitsitsthrottlinglimit>)
  - [func (e *ContainerBuilder) writeNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writenumberofperiodswithprecputhrottlingactive>)
  - [func (e *ContainerBuilder) writeNumberOfPeriodsWithThrottlingActive(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writenumberofperiodswiththrottlingactive>)
  - [func (e *ContainerBuilder) writeNumberOfTimesMemoryUsageHitsLimits(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writenumberoftimesmemoryusagehitslimits>)
  - [func (e *ContainerBuilder) writeOnlineCPUs(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeonlinecpus>)
  - [func (e *ContainerBuilder) writeOnlinePreCPUs(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeonlineprecpus>)
  - [func (e *ContainerBuilder) writePeakCommittedBytes(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writepeakcommittedbytes>)
  - [func (e *ContainerBuilder) writePreCPUSystemUsage(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeprecpusystemusage>)
  - [func (e *ContainerBuilder) writePrivateWorkingSet(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writeprivateworkingset>)
  - [func (e *ContainerBuilder) writeReadingTime(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writereadingtime>)
  - [func (e *ContainerBuilder) writeSystemUsage(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writesystemusage>)
  - [func (e *ContainerBuilder) writeTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetimespentbyprecputasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetimespentbyprecputasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetimespentbytasksofthecgroupinkernelmode>)
  - [func (e *ContainerBuilder) writeTimeSpentByTasksOfTheCGroupInUserMode(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetimespentbytasksofthecgroupinusermode>)
  - [func (e *ContainerBuilder) writeTotalCPUTimeConsumed(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetotalcputimeconsumed>)
  - [func (e *ContainerBuilder) writeTotalCPUTimeConsumedPerCore(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetotalcputimeconsumedpercore>)
  - [func (e *ContainerBuilder) writeTotalPreCPUTimeConsumed(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetotalprecputimeconsumed>)
  - [func (e *ContainerBuilder) writeTotalPreCPUTimeConsumedPerCore(file *os.File, stats *types.Stats) (tab bool, err error)](<#func-containerbuilder-writetotalprecputimeconsumedpercore>)
- [type DockerfileAuto](<#type-dockerfileauto>)
- [type Event](<#type-event>)
  - [func (e *Event) clear()](<#func-event-clear>)
- [type HealthConfig](<#type-healthconfig>)
- [type LogFilter](<#type-logfilter>)
- [type MemoryStats](<#type-memorystats>)
- [type NameAndId](<#type-nameandid>)
- [type NetworkChaos](<#type-networkchaos>)
  - [func (e *NetworkChaos) Init() (err error)](<#func-networkchaos-init>)
  - [func (e *NetworkChaos) SetContainerName(value string)](<#func-networkchaos-setcontainername>)
  - [func (e *NetworkChaos) SetFatherContainer(fatherContainer *ContainerBuilder)](<#func-networkchaos-setfathercontainer>)
  - [func (e *NetworkChaos) SetNetworkDocker(network isolatedNetwork.ContainerBuilderNetworkInterface)](<#func-networkchaos-setnetworkdocker>)
  - [func (e *NetworkChaos) SetPorts(listenPort, outputPort int, invert bool)](<#func-networkchaos-setports>)
  - [func (e *NetworkChaos) imageExists() (exists bool)](<#func-networkchaos-imageexists>)
- [type PidsStats](<#type-pidsstats>)
- [type Restart](<#type-restart>)
- [type Stats](<#type-stats>)
- [type StorageStats](<#type-storagestats>)
- [type TestContainerLog](<#type-testcontainerlog>)
  - [func (e *TestContainerLog) fileToDataFormat(path string, t *testing.T) (problem pb.Problem)](<#func-testcontainerlog-filetodataformat>)
  - [func (e TestContainerLog) findKeyIndex(key string, t *testing.T) (index int, problem pb.Problem)](<#func-testcontainerlog-findkeyindex>)
  - [func (e *TestContainerLog) makeTest(path string, listUnderTest *[]parserLog, t *testing.T) (problem pb.Problem)](<#func-testcontainerlog-maketest>)
  - [func (e TestContainerLog) proccessKeyList(listUnderTest *[]parserLog, t *testing.T) (problem pb.Problem)](<#func-testcontainerlog-proccesskeylist>)
- [type Theater](<#type-theater>)
  - [func (e *Theater) ConfigScene(sceneName string, maxStopedContainers, maxPausedContainers, maxTotalPausedAndStoppedContainers int)](<#func-theater-configscene>)
  - [func (e *Theater) Init()](<#func-theater-init>)
  - [func (e *Theater) SetContainerPaused(sceneName string) (doNotPauseContainer bool)](<#func-theater-setcontainerpaused>)
  - [func (e *Theater) SetContainerStopped(sceneName string) (IsOnTheEdge bool)](<#func-theater-setcontainerstopped>)
  - [func (e *Theater) SetContainerUnPaused(sceneName string)](<#func-theater-setcontainerunpaused>)
  - [func (e *Theater) SetContainerUnStopped(sceneName string)](<#func-theater-setcontainerunstopped>)
- [type ThrottlingData](<#type-throttlingdata>)
- [type Timers](<#type-timers>)
- [type chaos](<#type-chaos>)
- [type gitData](<#type-gitdata>)
- [type parserLog](<#type-parserlog>)
- [type scene](<#type-scene>)


## Constants

```go
const (
    // KKiloByte
    //
    // English: 1024 Bytes multiplier
    //
    // Example:
    //   5 * KKiloByte = 5 KBytes
    //
    // Português: multiplicador de 1024 Bytes
    //
    // Exemplo:
    //   5 * KKiloByte = 5 KBytes
    KKiloByte = 1024

    // KMegaByte
    //
    // English: 1024 KBytes multiplier
    //
    // Example:
    //   5 * KMegaByte = 5 MBytes
    //
    // Português: multiplicador de 1024 KBytes
    //
    // Exemplo:
    //   5 * KMegaByte = 5 MBytes
    KMegaByte = 1024 * 1024

    // KGigaByte
    //
    // English: 1024 MBytes multiplier
    //
    // Example:
    //   5 * KGigaByte = 5 GBytes
    //
    // Português: multiplicador de 1024 MBytes
    //
    // Exemplo:
    //   5 * KGigaByte = 5 GBytes
    KGigaByte = 1024 * 1024 * 1024

    // KTeraByte (
    //
    // English: 1024 GBytes multiplier
    //
    // Example:
    //   5 * KTeraByte = 5 TBytes
    //
    // Português: multiplicador de 1024 GBytes
    //
    // Exemplo:
    //   5 * KTeraByte = 5 TBytes
    KTeraByte = 1024 * 1024 * 1024 * 1024

    // KLogColumnAll
    //
    // English: Enable all values to log
    KLogColumnAll = 0x7FFFFFFFFFFFFFF

    // KLogColumnReadingTime
    //
    // English: Reading time
    KLogColumnReadingTime = 0b0000000000000000000000000000000000000000000000000000000000000001
    KReadingTimeComa      = 0b0111111111111111111111111111111111111111111111111111111111111110

    KFilterLog              = 0b0000000000000000000000000000000000000000000000000000000000000010
    KLogColumnFilterLogComa = 0b0111111111111111111111111111111111111111111111111111111111111100

    // KLogColumnCurrentNumberOfOidsInTheCGroup
    //
    // English: Linux specific stats, not populated on Windows. Current is the number of pids in the cgroup
    KLogColumnCurrentNumberOfOidsInTheCGroup = 0b0000000000000000000000000000000000000000000000000000000000000100
    KCurrentNumberOfOidsInTheCGroupComa      = 0b0111111111111111111111111111111111111111111111111111111111111000

    // KLogColumnLimitOnTheNumberOfPidsInTheCGroup
    //
    // English: Linux specific stats, not populated on Windows. Limit is the hard limit on the number of pids in the cgroup. A "Limit" of 0 means that there is no limit.
    KLogColumnLimitOnTheNumberOfPidsInTheCGroup = 0b0000000000000000000000000000000000000000000000000000000000001000
    KLimitOnTheNumberOfPidsInTheCGroupComa      = 0b0111111111111111111111111111111111111111111111111111111111110000

    // KLogColumnTotalCPUTimeConsumed
    //
    // English: Total CPU time consumed. (Units: nanoseconds on Linux, Units: 100's of nanoseconds on Windows)
    KLogColumnTotalCPUTimeConsumed = 0b0000000000000000000000000000000000000000000000000000000000010000
    KTotalCPUTimeConsumedComa      = 0b0111111111111111111111111111111111111111111111111111111111100000

    // KLogColumnTotalCPUTimeConsumedPerCore
    //
    // English: Total CPU time consumed. (Units: nanoseconds on Linux, Units: 100's of nanoseconds on Windows)
    KLogColumnTotalCPUTimeConsumedPerCore = 0b0000000000000000000000000000000000000000000000000000000000100000
    KTotalCPUTimeConsumedPerCoreComa      = 0b0111111111111111111111111111111111111111111111111111111111000000

    // KLogColumnTimeSpentByTasksOfTheCGroupInKernelMode
    //
    // English: Time spent by tasks of the cgroup in kernel mode (Units: nanoseconds on Linux). Time spent by all container processes in kernel mode (Units: 100's of nanoseconds on Windows.Not populated for Hyper-V Containers.)
    KLogColumnTimeSpentByTasksOfTheCGroupInKernelMode = 0b0000000000000000000000000000000000000000000000000000000001000000
    KTimeSpentByTasksOfTheCGroupInKernelModeComa      = 0b0111111111111111111111111111111111111111111111111111111110000000

    // KLogColumnTimeSpentByTasksOfTheCGroupInUserMode
    //
    // English: Time spent by tasks of the cgroup in user mode (Units: nanoseconds on Linux). Time spent by all container processes in user mode (Units: 100's of nanoseconds on Windows. Not populated for Hyper-V Containers)
    KLogColumnTimeSpentByTasksOfTheCGroupInUserMode = 0b0000000000000000000000000000000000000000000000000000000010000000
    KTimeSpentByTasksOfTheCGroupInUserModeComa      = 0b0111111111111111111111111111111111111111111111111111111100000000

    // KLogColumnSystemUsage
    //
    // English: System Usage. Linux only.
    KLogColumnSystemUsage = 0b0000000000000000000000000000000000000000000000000000000100000000
    KSystemUsageComa      = 0b0111111111111111111111111111111111111111111111111111111000000000

    // KOnlineCPUs
    //
    // English: Online CPUs. Linux only.
    KLogColumnOnlineCPUs = 0b0000000000000000000000000000000000000000000000000000001000000000
    KOnlineCPUsComa      = 0b0111111111111111111111111111111111111111111111111111110000000000

    // KLogColumnNumberOfPeriodsWithThrottlingActive
    //
    // English: Throttling Data. Linux only. Number of periods with throttling active.
    KLogColumnNumberOfPeriodsWithThrottlingActive = 0b0000000000000000000000000000000000000000000000000000010000000000
    KNumberOfPeriodsWithThrottlingActiveComa      = 0b0111111111111111111111111111111111111111111111111111100000000000

    // KNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit
    //
    // English: Throttling Data. Linux only. Number of periods when the container hits its throttling limit.
    KLogColumnNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit = 0b0000000000000000000000000000000000000000000000000000100000000000
    KNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimitComa      = 0b0111111111111111111111111111111111111111111111111111000000000000

    // KAggregateTimeTheContainerWasThrottledForInNanoseconds
    //
    // English: Throttling Data. Linux only. Aggregate time the container was throttled for in nanoseconds.
    KLogColumnAggregateTimeTheContainerWasThrottledForInNanoseconds = 0b0000000000000000000000000000000000000000000000000001000000000000
    KAggregateTimeTheContainerWasThrottledForInNanosecondsComa      = 0b0111111111111111111111111111111111111111111111111110000000000000

    // KLogColumnTotalPreCPUTimeConsumed
    //
    // English: Total CPU time consumed per core (Units: nanoseconds on Linux). Not used on Windows.
    KLogColumnTotalPreCPUTimeConsumed = 0b0000000000000000000000000000000000000000000000000010000000000000
    KTotalPreCPUTimeConsumedComa      = 0b0111111111111111111111111111111111111111111111111100000000000000

    // KLogColumnTotalPreCPUTimeConsumedPerCore
    //
    // English: Total CPU time consumed per core (Units: nanoseconds on Linux). Not used on Windows.
    KLogColumnTotalPreCPUTimeConsumedPerCore = 0b0000000000000000000000000000000000000000000000000100000000000000
    KTotalPreCPUTimeConsumedPerCoreComa      = 0b0111111111111111111111111111111111111111111111111000000000000000

    // KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInKernelMode
    //
    // English: Time spent by tasks of the cgroup in kernel mode (Units: nanoseconds on Linux) - Time spent by all container processes in kernel mode (Units: 100's of nanoseconds on Windows - Not populated for Hyper-V Containers.)
    KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInKernelMode = 0b0000000000000000000000000000000000000000000000001000000000000000
    KTimeSpentByPreCPUTasksOfTheCGroupInKernelModeComa      = 0b0111111111111111111111111111111111111111111111110000000000000000

    // KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInUserMode
    //
    // English: Time spent by tasks of the cgroup in user mode (Units: nanoseconds on Linux) - Time spent by all container processes in user mode (Units: 100's of nanoseconds on Windows. Not populated for Hyper-V Containers)
    KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInUserMode = 0b0000000000000000000000000000000000000000000000010000000000000000
    KTimeSpentByPreCPUTasksOfTheCGroupInUserModeComa      = 0b0111111111111111111111111111111111111111111111100000000000000000

    // KLogColumnPreCPUSystemUsage
    //
    // English: System Usage. (Linux only)
    KLogColumnPreCPUSystemUsage = 0b0000000000000000000000000000000000000000000000100000000000000000
    KPreCPUSystemUsageComa      = 0b0111111111111111111111111111111111111111111111000000000000000000

    // KLogColumnOnlinePreCPUs
    //
    // English: Online CPUs. (Linux only)
    KLogColumnOnlinePreCPUs = 0b0000000000000000000000000000000000000000000001000000000000000000
    KOnlinePreCPUsComa      = 0b0111111111111111111111111111111111111111111110000000000000000000

    // KLogColumnAggregatePreCPUTimeTheContainerWasThrottled
    //
    // English: Throttling Data. (Linux only) - Aggregate time the container was throttled for in nanoseconds
    KLogColumnAggregatePreCPUTimeTheContainerWasThrottled = 0b0000000000000000000000000000000000000000000010000000000000000000
    KAggregatePreCPUTimeTheContainerWasThrottledComa      = 0b0111111111111111111111111111111111111111111100000000000000000000

    // KLogColumnNumberOfPeriodsWithPreCPUThrottlingActive
    //
    // English: Throttling Data. (Linux only) - Number of periods with throttling active
    KLogColumnNumberOfPeriodsWithPreCPUThrottlingActive = 0b0000000000000000000000000000000000000000000100000000000000000000
    KNumberOfPeriodsWithPreCPUThrottlingActiveComa      = 0b0111111111111111111111111111111111111111111000000000000000000000

    // KLogColumnNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit
    //
    // English: Throttling Data. (Linux only) - Number of periods when the container hits its throttling limit.
    KLogColumnNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit = 0b0000000000000000000000000000000000000000001000000000000000000000
    KNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimitComa      = 0b0111111111111111111111111111111111111111110000000000000000000000

    // KLogColumnCurrentResCounterUsageForMemory
    //
    // English: Current res_counter usage for memory
    KLogColumnCurrentResCounterUsageForMemory = 0b0000000000000000000000000000000000000000010000000000000000000000
    KCurrentResCounterUsageForMemoryComa      = 0b0111111111111111111111111111111111111111100000000000000000000000

    // KLogColumnMaximumUsageEverRecorded
    //
    // English: Maximum usage ever recorded
    KLogColumnMaximumUsageEverRecorded = 0b0000000000000000000000000000000000000000100000000000000000000000
    KMaximumUsageEverRecordedComa      = 0b0111111111111111111111111111111111111111000000000000000000000000

    // KLogColumnNumberOfTimesMemoryUsageHitsLimits
    //
    // English: Number of times memory usage hits limits
    KLogColumnNumberOfTimesMemoryUsageHitsLimits = 0b0000000000000000000000000000000000000001000000000000000000000000
    KNumberOfTimesMemoryUsageHitsLimitsComa      = 0b0111111111111111111111111111111111111110000000000000000000000000

    // KLogColumnMemoryLimit
    //
    // English: Memory limit
    KLogColumnMemoryLimit = 0b0000000000000000000000000000000000000010000000000000000000000000
    KMemoryLimitComa      = 0b0111111111111111111111111111111111111100000000000000000000000000

    // KLogColumnCommittedBytes
    //
    // English: Committed bytes
    KLogColumnCommittedBytes = 0b0000000000000000000000000000000000000100000000000000000000000000
    KCommittedBytesComa      = 0b0111111111111111111111111111111111111000000000000000000000000000

    // KLogColumnPeakCommittedBytes
    //
    // English: Peak committed bytes
    KLogColumnPeakCommittedBytes = 0b0000000000000000000000000000000000001000000000000000000000000000
    KPeakCommittedBytesComa      = 0b0111111111111111111111111111111111110000000000000000000000000000

    // KLogColumnPrivateWorkingSet
    //
    // English: Private working set
    KLogColumnPrivateWorkingSet = 0b0000000000000000000000000000000000010000000000000000000000000000
    KPrivateWorkingSetComa      = 0b0111111111111111111111111111111111100000000000000000000000000000

    KLogColumnBlkioIoServiceBytesRecursive = 0b0000000000000000000000000000000000100000000000000000000000000000
    KBlkioIoServiceBytesRecursiveComa      = 0b0111111111111111111111111111111111000000000000000000000000000000

    KLogColumnBlkioIoServicedRecursive = 0b0000000000000000000000000000000001000000000000000000000000000000
    KBlkioIoServicedRecursiveComa      = 0b0111111111111111111111111111111110000000000000000000000000000000

    KLogColumnBlkioIoQueuedRecursive = 0b0000000000000000000000000000000010000000000000000000000000000000
    KBlkioIoQueuedRecursiveComa      = 0b0111111111111111111111111111111100000000000000000000000000000000

    KLogColumnBlkioIoServiceTimeRecursive = 0b0000000000000000000000000000000100000000000000000000000000000000
    KBlkioIoServiceTimeRecursiveComa      = 0b0111111111111111111111111111111000000000000000000000000000000000

    KLogColumnBlkioIoWaitTimeRecursive = 0b0000000000000000000000000000001000000000000000000000000000000000
    KBlkioIoWaitTimeRecursiveComa      = 0b0111111111111111111111111111110000000000000000000000000000000000

    KLogColumnBlkioIoMergedRecursive = 0b0000000000000000000000000000010000000000000000000000000000000000
    KBlkioIoMergedRecursiveComa      = 0b0111111111111111111111111111100000000000000000000000000000000000

    KLogColumnBlkioIoTimeRecursive = 0b0000000000000000000000000000100000000000000000000000000000000000
    KBlkioIoTimeRecursiveComa      = 0b0111111111111111111111111111000000000000000000000000000000000000

    KLogColumnBlkioSectorsRecursive = 0b0000000000000000000000000001000000000000000000000000000000000000
    KBlkioSectorsRecursiveComa      = 0b0111111111111111111111111110000000000000000000000000000000000000

    // KLogColumnMacOsLogWithAllCores
    //
    // English: Mac OS Log
    KLogColumnMacOsLogWithAllCores = KLogColumnReadingTime |
        KLogColumnCurrentNumberOfOidsInTheCGroup |
        KLogColumnTotalCPUTimeConsumed |
        KLogColumnTotalCPUTimeConsumedPerCore |
        KLogColumnTimeSpentByTasksOfTheCGroupInKernelMode |
        KLogColumnSystemUsage |
        KLogColumnOnlineCPUs |
        KLogColumnTotalPreCPUTimeConsumed |
        KLogColumnTotalPreCPUTimeConsumedPerCore |
        KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInKernelMode |
        KLogColumnPreCPUSystemUsage |
        KLogColumnOnlinePreCPUs |
        KLogColumnCurrentResCounterUsageForMemory |
        KLogColumnMaximumUsageEverRecorded |
        KLogColumnMemoryLimit |
        KLogColumnBlkioIoServiceBytesRecursive |
        KLogColumnBlkioIoServicedRecursive |
        KLogColumnBlkioIoQueuedRecursive |
        KLogColumnBlkioIoServiceTimeRecursive |
        KLogColumnBlkioIoWaitTimeRecursive |
        KLogColumnBlkioIoMergedRecursive |
        KLogColumnBlkioIoTimeRecursive |
        KLogColumnBlkioSectorsRecursive // não aparece no mac

    // KLogColumnMacOs
    //
    // English: Mac OS Log
    KLogColumnMacOs = KLogColumnReadingTime |
        KLogColumnCurrentNumberOfOidsInTheCGroup |
        KLogColumnTotalCPUTimeConsumed |
        KLogColumnTimeSpentByTasksOfTheCGroupInKernelMode |
        KLogColumnSystemUsage |
        KLogColumnOnlineCPUs |
        KLogColumnTotalPreCPUTimeConsumed |
        KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInKernelMode |
        KLogColumnPreCPUSystemUsage |
        KLogColumnOnlinePreCPUs |
        KLogColumnCurrentResCounterUsageForMemory |
        KLogColumnMaximumUsageEverRecorded |
        KLogColumnMemoryLimit |
        KLogColumnBlkioIoServiceBytesRecursive |
        KLogColumnBlkioIoServicedRecursive |
        KLogColumnBlkioIoQueuedRecursive |
        KLogColumnBlkioIoServiceTimeRecursive |
        KLogColumnBlkioIoWaitTimeRecursive |
        KLogColumnBlkioIoMergedRecursive |
        KLogColumnBlkioIoTimeRecursive |
        KLogColumnBlkioSectorsRecursive // não aparece no mac

    KLogColumnWindows = KLogColumnReadingTime |
        KLogColumnCurrentNumberOfOidsInTheCGroup |
        KLogColumnTotalCPUTimeConsumed |
        KLogColumnTotalCPUTimeConsumedPerCore |
        KLogColumnTimeSpentByTasksOfTheCGroupInKernelMode |
        KLogColumnTimeSpentByTasksOfTheCGroupInUserMode |
        KLogColumnSystemUsage |
        KLogColumnOnlineCPUs |
        KLogColumnTotalPreCPUTimeConsumed |
        KLogColumnTotalPreCPUTimeConsumedPerCore |
        KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInKernelMode |
        KLogColumnTimeSpentByPreCPUTasksOfTheCGroupInUserMode |
        KLogColumnPreCPUSystemUsage |
        KLogColumnOnlinePreCPUs |
        KLogColumnCurrentResCounterUsageForMemory |
        KLogColumnMaximumUsageEverRecorded |
        KLogColumnMemoryLimit
)
```

```go
const (
    KLogReadingTimeLabel  = "Reading time"
    KLogReadingTimeValue  = "KReadingTime"
    KLogReadingTimeRegexp = "\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}.\\d{4,}(\\s\\+\\d{4})?\\sUTC"

    KLogCurrentNumberOfOidsInTheCGroupLabel  = "Linux specific stats - not populated on Windows. Current is the number of pids in the cgroup"
    KLogCurrentNumberOfOidsInTheCGroupValue  = "KCurrentNumberOfOidsInTheCGroup"
    KLogCurrentNumberOfOidsInTheCGroupRegexp = "\\d+"

    KLogLimitOnTheNumberOfPidsInTheCGroupLabel  = "Linux specific stats. Not populated on Windows. Limit is the hard limit on the number of pids in the cgroup. A \"Limit\" of 0 means that there is no limit."
    KLogLimitOnTheNumberOfPidsInTheCGroupValue  = "KLimitOnTheNumberOfPidsInTheCGroup"
    KLogLimitOnTheNumberOfPidsInTheCGroupRegexp = "\\d+"

    KLogTotalCPUTimeConsumedLabel  = "Total CPU time consumed. (Units: nanoseconds on Linux - Units: 100's of nanoseconds on Windows)"
    KLogTotalCPUTimeConsumedValue  = "KTotalCPUTimeConsumed"
    KLogTotalCPUTimeConsumedRegexp = "\\d+"

    KLogTotalCPUTimeConsumedPerCoreLabel  = "Total CPU time consumed per core (Units: nanoseconds on Linux). Not used on Windows."
    KLogTotalCPUTimeConsumedPerCoreValue  = "KTotalCPUTimeConsumedPerCore"
    KLogTotalCPUTimeConsumedPerCoreRegexp = "\\d+"

    KLogTimeSpentByTasksOfTheCGroupInKernelModeLabel  = "Time spent by tasks of the cgroup in kernel mode (Units: nanoseconds on Linux). Time spent by all container processes in kernel mode (Units: 100's of nanoseconds on Windows.Not populated for Hyper-V Containers.)."
    KLogTimeSpentByTasksOfTheCGroupInKernelModeValue  = "KTimeSpentByTasksOfTheCGroupInKernelMode"
    KLogTimeSpentByTasksOfTheCGroupInKernelModeRegexp = "\\d+"

    KLogTimeSpentByTasksOfTheCGroupInUserModeLabel  = "Time spent by tasks of the cgroup in user mode (Units: nanoseconds on Linux). Time spent by all container processes in user mode (Units: 100's of nanoseconds on Windows. Not populated for Hyper-V Containers)."
    KLogTimeSpentByTasksOfTheCGroupInUserModeValue  = "KTimeSpentByTasksOfTheCGroupInUserMode"
    KLogTimeSpentByTasksOfTheCGroupInUserModeRegexp = "\\d+"

    KLogSystemUsageLabel  = "System Usage. Linux only."
    KLogSystemUsageValue  = "KSystemUsage"
    KLogSystemUsageRegexp = "\\d+"

    KLogOnlineCPUsLabel  = "Online CPUs. Linux only."
    KLogOnlineCPUsValue  = "KOnlineCPUs"
    KLogOnlineCPUsRegexp = "\\d+"

    KLogNumberOfPeriodsWithThrottlingActiveLabel  = "Throttling Data. Linux only. Number of periods with throttling active."
    KLogNumberOfPeriodsWithThrottlingActiveValue  = "KNumberOfPeriodsWithThrottlingActive"
    KLogNumberOfPeriodsWithThrottlingActiveRegexp = "\\d+"

    KLogNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimitLabel  = "Throttling Data. Linux only. Number of periods when the container hits its throttling limit."
    KLogNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimitValue  = "KNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit"
    KLogNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimitRegexp = "\\d+"

    KLogAggregateTimeTheContainerWasThrottledForInNanosecondsLabel  = "Throttling Data. Linux only. Aggregate time the container was throttled for in nanoseconds."
    KLogAggregateTimeTheContainerWasThrottledForInNanosecondsValue  = "KAggregateTimeTheContainerWasThrottledForInNanoseconds"
    KLogAggregateTimeTheContainerWasThrottledForInNanosecondsRegexp = "\\d+"

    KLogTotalPreCPUTimeConsumedLabel  = "Total CPU time consumed. (Units: nanoseconds on Linux. Units: 100's of nanoseconds on Windows)"
    KLogTotalPreCPUTimeConsumedValue  = "KTotalPreCPUTimeConsumed"
    KLogTotalPreCPUTimeConsumedRegexp = "\\d+"

    KLogTotalPreCPUTimeConsumedPerCoreLabel  = "Total CPU time consumed per core (Units: nanoseconds on Linux). Not used on Windows."
    KLogTotalPreCPUTimeConsumedPerCoreValue  = "KTotalPreCPUTimeConsumedPerCore"
    KLogTotalPreCPUTimeConsumedPerCoreRegexp = "\\d+"

    KLogTimeSpentByPreCPUTasksOfTheCGroupInKernelModeLabel  = "Time spent by tasks of the cgroup in kernel mode (Units: nanoseconds on Linux) - Time spent by all container processes in kernel mode (Units: 100's of nanoseconds on Windows - Not populated for Hyper-V Containers.)"
    KLogTimeSpentByPreCPUTasksOfTheCGroupInKernelModeValue  = "KTimeSpentByPreCPUTasksOfTheCGroupInKernelMode"
    KLogTimeSpentByPreCPUTasksOfTheCGroupInKernelModeRegexp = "\\d+"

    KLogTimeSpentByPreCPUTasksOfTheCGroupInUserModeLabel  = "Time spent by tasks of the cgroup in user mode (Units: nanoseconds on Linux) - Time spent by all container processes in user mode (Units: 100's of nanoseconds on Windows. Not populated for Hyper-V Containers)"
    KLogTimeSpentByPreCPUTasksOfTheCGroupInUserModeValue  = "KTimeSpentByPreCPUTasksOfTheCGroupInUserMode"
    KLogTimeSpentByPreCPUTasksOfTheCGroupInUserModeRegexp = "\\d+"

    KLogPreCPUSystemUsageLabel  = "System Usage. (Linux only)"
    KLogPreCPUSystemUsageValue  = "KPreCPUSystemUsage"
    KLogPreCPUSystemUsageRegexp = "\\d+"

    KLogOnlinePreCPUsLabel  = "Online CPUs. (Linux only)"
    KLogOnlinePreCPUsValue  = "KOnlinePreCPUs"
    KLogOnlinePreCPUsRegexp = "\\d+"

    KLogAggregatePreCPUTimeTheContainerWasThrottledLabel  = "Throttling Data. (Linux only) - Aggregate time the container was throttled for in nanoseconds."
    KLogAggregatePreCPUTimeTheContainerWasThrottledValue  = "KAggregatePreCPUTimeTheContainerWasThrottled"
    KLogAggregatePreCPUTimeTheContainerWasThrottledRegexp = "\\d+"

    KLogNumberOfPeriodsWithPreCPUThrottlingActiveLabel  = "Throttling Data. (Linux only) - Number of periods with throttling active."
    KLogNumberOfPeriodsWithPreCPUThrottlingActiveValue  = "KNumberOfPeriodsWithPreCPUThrottlingActive"
    KLogNumberOfPeriodsWithPreCPUThrottlingActiveRegexp = "\\d+"

    KLogNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimitLabel  = "Throttling Data. (Linux only) - Number of periods when the container hits its throttling limit."
    KLogNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimitValue  = "KNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit"
    KLogNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimitRegexp = "\\d+"

    KLogCurrentResCounterUsageForMemoryLabel  = "Current res_counter usage for memory"
    KLogCurrentResCounterUsageForMemoryValue  = "KCurrentResCounterUsageForMemory"
    KLogCurrentResCounterUsageForMemoryRegexp = "\\d+"

    KLogMaximumUsageEverRecordedLabel  = "Maximum usage ever recorded."
    KLogMaximumUsageEverRecordedValue  = "KMaximumUsageEverRecorded"
    KLogMaximumUsageEverRecordedRegexp = "\\d+"

    KLogNumberOfTimesMemoryUsageHitsLimitsLabel  = "Number of times memory usage hits limits."
    KLogNumberOfTimesMemoryUsageHitsLimitsValue  = "KNumberOfTimesMemoryUsageHitsLimits"
    KLogNumberOfTimesMemoryUsageHitsLimitsRegexp = "\\d+"

    KLogMemoryLimitLabel  = "Memory limit"
    KLogMemoryLimitValue  = "KMemoryLimit"
    KLogMemoryLimitRegexp = "\\d+"

    KLogCommittedBytesLabel  = "Committed bytes"
    KLogCommittedBytesValue  = "KCommittedBytes"
    KLogCommittedBytesRegexp = "\\d+"

    KLogPeakCommittedBytesLabel  = "Peak committed bytes"
    KLogPeakCommittedBytesValue  = "KPeakCommittedBytes"
    KLogPeakCommittedBytesRegexp = "\\d+"

    KLogPrivateWorkingSetLabel  = "Private working set"
    KLogPrivateWorkingSetValue  = "KPrivateWorkingSet"
    KLogPrivateWorkingSetRegexp = "\\d+"

    kLogHeaderLine = 0
    kLogLabelLine  = 1
)
```

## Variables

```go
var theater = Theater{}
```

## func [ConfigChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcConfigChaosScene.go#L59-L64>)

```go
func ConfigChaosScene(sceneName string, maxStopedContainers, maxPausedContainers, maxTotalPausedAndStoppedContainers int)
```

### ConfigChaosScene

English:

Add and configure a test scene prevents all containers in the scene from stopping at the same time

```
Input:
  sceneName: unique name for the scene
  maxStopedContainers: Maximum number of stopped containers
  maxPausedContainers: Maximum number of paused containers
  maxTotalPausedAndStoppedContainers: Maximum number of containers stopped and paused at the same
    time
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Adiciona e configura uma cena de teste impedindo que todos os container da cena parem ao mesmo tempo

```
Entrada:
  sceneName: Nome único para a cena
  maxStopedContainers: Quantidade máxima de containers parados
  maxPausedContainers: Quantidade máxima de containers pausados
  maxTotalPausedAndStoppedContainers: Quantidade máxima de containers parados e pausados ao mesmo
    tempo
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"errors"
	"fmt"
	dockerNetwork "github.com/helmutkemper/iotmaker.docker.builder.network"
	"github.com/helmutkemper/util"
	"strconv"
	"time"
)

func main() {
	var err error

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	SaGarbageCollector()

	// English: Create a chaos scene named nats_chaos and control the number of containers stopped at the same time
	//
	// Português: Cria uma cena de caos de nome nats_chaos e controla a quantidade de containers parados ao mesmo tempo
	ConfigChaosScene("nats_chaos", 2, 2, 2)

	// English: Create a docker network controler
	//
	// Português: Cria um controlador de rede do docker
	var netDocker = &dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		util.TraceToLog()
		fmt.Printf("Error: %s\n", err.Error())
		return
	}

	// English: Create a network named nats_network_delete_after_test, subnet 10.0.0.0/16 and gatway 10.0.0.1
	//
	// Português: Cria uma rede de nome nats_network_delete_after_test, subrede 10.0.0.0/16 e gatway 10.0.0.1
	err = netDocker.NetworkCreate("nats_network_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		util.TraceToLog()
		fmt.Printf("Error: %s\n", err.Error())
		return
	}

	// English: Create a docker container named container_delete_nats_after_test_ + i
	//
	// Português: Cria um container do docker de nome container_delete_nats_after_test_ + i
	for i := 0; i != 3; i += 1 {
		go func(i int, err error) {
			err = mountNatsContainer(i, netDocker)
			if err != nil {
				util.TraceToLog()
				fmt.Printf("Error: %s\n", err.Error())
				return
			}
		}(i, err)
	}

	// English: Let the test run for two minutes before closing it
	//
	// Português: Deixa o teste rodar por dois minutos antes de o encerrar
	time.Sleep(2 * 60 * time.Second)

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	SaGarbageCollector()

}

func mountNatsContainer(loop int, network *dockerNetwork.ContainerBuilderNetwork) (err error) {
	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	//
	// [optional/opcional]
	container.SetPrintBuildOnStrOut()

	// English: Sets a validity time for the image, preventing the same image from being remade for a period of time.
	// In some tests, the same image is created inside a loop, and adding an expiration date causes the same image to be used without having to redo the same image at each loop iteration.
	//
	// Português: Define uma tempo de validade para a imagem, evitando que a mesma imagem seja refeita durante um período de tempo.
	// Em alguns testes, a mesma imagem é criada dentro de um laço, e adicionar uma data de validade faz a mesma imagem ser usada sem a necessidade de refazer a mesma imagem a cada interação do loop
	//
	// [optional/opcional]
	container.SetImageExpirationTime(5 * time.Minute)

	// English: Link this container to a chaos scene for greater control
	//
	// Português: Vincula este container a uma cena de caos para maior controle
	container.SetSceneNameOnChaosScene("nats_chaos")

	// English: Set image name for docker pull
	//
	// Português: Define o nome da imagem para o docker pull
	container.SetImageName("nats:latest")

	// English: set a container name
	//
	// Português: Define o nome do container
	container.SetContainerName("container_delete_nats_after_test_" + strconv.Itoa(loop))

	// English: Links the container to the previously created network
	//
	// Português: Vincula o container a rede criada previamente
	container.SetNetworkDocker(network)

	// English: Defines a wait for text, where the text must appear in the container's standard output to proceed [optional]
	//
	// Português: Define uma espera por texto, onde o texto deve aparecer na saída padrão do container para prosseguir [opcional]
	container.SetWaitStringWithTimeout("Listening for route connections on 0.0.0.0:6222", 10*time.Second)

	// English: Defines the probability of the container restarting and changing the IP address in the process.
	//
	// Português: Define a probalidade do container reiniciar e mudar o endereço IP no processo.
	container.SetRestartProbability(0.9, 1.0, 5)

	// English: Defines a time window used to start chaos testing after container initialized
	//
	// Português: Define uma janela de tempo usada para começar o teste de caos depois do container inicializado
	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	// English: Sets a time window used to release container restart after the container has been initialized
	//
	// Português: Define uma janela de tempo usada para liberar o reinício do container depois do container ter sido inicializado
	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	// English: Defines a time window used to pause the container
	//
	// Português: Define uma janela de tempo usada para pausar o container
	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	// English: Defines a time window used to unpause the container
	//
	// Português: Define uma janela de tempo usada para remover a pausa do container
	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	// English: Sets a time window used to restart the container after stopping
	//
	// Português: Define uma janela de tempo usada para reiniciar o container depois de parado
	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	// English: Enable chaos test
	//
	// Português: Habilita o teste de caos
	container.EnableChaosScene(true)

	// English: Initialize the container's control object
	//
	// Português: Inicializa o objeto de controle do container
	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	// image nats:latest pull command [optional]
	//err = container.ImagePull()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	// container build and start from image nats:latest
	// waits for the text "Listening for route connections on 0.0.0.0:6222" to appear  in the standard container output
	// to proceed
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var IP string
	IP, err = container.FindCurrentIPV4Address()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	if IP != container.GetIPV4Address() {
		err = errors.New("all ip address must be a samer IP")
		util.TraceToLog()
		panic(err)
	}

	// container "container_delete_nats_after_test" running and ready for use on this code point on var IP
	// all nats ports are open
	// you can use AddPortToExpose("4222"), to open only ports defineds inside code;
	// you can use AddPortToChange("4222", "1111") to open only ports defineds inside code and change port 4222 to port
	// 1111;
	// you can use SetDoNotOpenContainersPorts() to not open containers ports

	// English: Starts container monitoring at two second intervals. This functionality monitors the container's standard output and generates the log defined by the SetCsvLogPath() function.
	//
	// Português: Inicializa o monitoramento do container com intervalos de dois segundos. Esta funcionalidade monitora a saída padrão do container e gera o log definido pela função SetCsvLogPath().
	// StartMonitor() é usado durante o teste de caos e na geração do log de desempenho do container.
	// [optional/opcional]
	container.StartMonitor()

	return
}
```

#### Output

```

```

</p>
</details>

## func [SaGarbageCollector](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGarbageCollector.go#L32>)

```go
func SaGarbageCollector(names ...string)
```

### SaGarbageCollector

English:

Removes docker elements created during unit tests\, such as networks\, containers\, images and volumes with the term delete in the name\.

Eg: network\_to\_delete\_after\_test

```
Input:
  names: Terms contained in the name of docker elements indicated for removal.
    Eg: nats, removes network, container image, and volume elements that contain the term "nats"
    in the name. [optional]
```

Português:

Remove elementos docker criados dutente os testtes unitários\, como por exemplo\, redes\, contêineres\, imagens e volumes com o termo delete no nome\.

ex\.: network\_to\_delete\_after\_test

```
Entrada:
  names: Termos contidos no nome dos elementos docker indicados para remoção.
    Ex.: nats, remove os elementos de rede, imagem container e volumes que contenham o termo
    "nats" no nome. [opcional]
```

## func [SaImageMakeCache](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageMakeCache.go#L70>)

```go
func SaImageMakeCache(projectPath, cacheName string, expirationDate time.Duration) (err error)
```

### SaImageMakeCache

English:

Creates a cached image used as a basis for creating new images\.

```
Input:
  projectPath: path of the project folder
  cacheName: name of the cache image
  expirationDate: expiration date of the image

Output:
  err: standard object error
```

The way to use this function is:

First option:

```
* Create a folder containing the Dockerfile file to be used as a base for creating new images;
* Enable the use of image cache in your projects with the container.SetCacheEnable(true)
  function;
* Define the name of the cache image used in your projects, with the
  container.SetImageCacheName() function;
* Use container.MakeDefaultDockerfileForMeWithInstallExtras() or
  container.MakeDefaultDockerfileForMe() functions.
```

Second option:

```
* Create a folder containing the Dockerfile file to be used as a base for creating new images;
* Create your own Dockerfile and instead of using `FROM golang:1.16-alpine`, use the name of the
  cacge, eg `FROM cache:latest`;
```

Português:

Cria uma imagem cache usada como base para a criação de novas imagens\.

```
Input:
  projectPath: caminha da pasta do projeto
  cacheName: nome da imagem cache
  expirationDate: data de expiração da imagem.

Output:
  err: standard object error
```

A forma de usar esta função é:

Primeira opção:

```
* Criar uma pasta contendo o arquivo Dockerfile a ser usado como base para a criação de novas
  imagens;
* Habilitar o uso da imagem cache nos seus projetos com a função container.SetCacheEnable(true);
* Definir o nome da imagem cache usada nos seus projetos, com a função
  container.SetImageCacheName();
* Usar as funções container.MakeDefaultDockerfileForMeWithInstallExtras() ou
  container.MakeDefaultDockerfileForMe().
```

Segunda opção:

```
* Criar uma pasta contendo o arquivo Dockerfile a ser usado como base para a criação de novas
  imagens;
* Criar seu próprio Dockerfile e em vez de usar `FROM golang:1.16-alpine`, usar o nome da cacge,
  por exemplo, `FROM cache:latest`;
```

## func [SaImageMakeCacheWithDefaultName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageMakeCacheWithDefaultName.go#L62>)

```go
func SaImageMakeCacheWithDefaultName(projectPath string, expirationDate time.Duration) (err error)
```

### SaImageMakeCache

English:

Creates a cached image used as a basis for creating new images\.

```
Input:
  projectPath: path of the project folder
  expirationDate: expiration date of the image

Output:
  err: standard object error
```

The way to use this function is:

First option:

```
* Create a folder containing the Dockerfile file to be used as a base for creating new images;
* Enable the use of image cache in your projects with the container.SetCacheEnable(true)
  function;
* Use container.MakeDefaultDockerfileForMeWithInstallExtras() or
  container.MakeDefaultDockerfileForMe() functions.
```

Second option:

```
* Create a folder containing the Dockerfile file to be used as a base for creating new images;
* Create your own Dockerfile and instead of using `FROM golang:1.16-alpine`, use the name of the
  cacge, eg `FROM cache:latest`;
```

Português:

Cria uma imagem cache usada como base para a criação de novas imagens\.

```
Input:
  projectPath: caminha da pasta do projeto
  expirationDate: data de expiração da imagem.

Output:
  err: standard object error
```

A forma de usar esta função é:

Primeira opção:

```
* Criar uma pasta contendo o arquivo Dockerfile a ser usado como base para a criação de novas
  imagens;
* Habilitar o uso da imagem cache nos seus projetos com a função container.SetCacheEnable(true);
* Usar as funções container.MakeDefaultDockerfileForMeWithInstallExtras() ou
  container.MakeDefaultDockerfileForMe().
```

Segunda opção:

```
* Criar uma pasta contendo o arquivo Dockerfile a ser usado como base para a criação de novas
  imagens;
* Criar seu próprio Dockerfile e em vez de usar `FROM golang:1.16-alpine`, usar o nome da cacge,
  por exemplo, `FROM cache:latest`;
```

## func [init](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L193>)

```go
func init()
```

init

English: Launch the test theater

Português: Inicializa o teatro de teste

## type [BlkioStatEntry](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeBlkioStatEntry.go#L16-L21>)

### BlkioStatEntry

Português:

Estrutura para armazenar uma peça de estatísticas de Blkio

Não usado no windows\.

English:

Structure to store a piece of Blkio stats

Not used on Windows\.

```go
type BlkioStatEntry struct {
    Major uint64 `json:"major"`
    Minor uint64 `json:"minor"`
    Op    string `json:"op"`
    Value uint64 `json:"value"`
}
```

## type [BlkioStats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeBlkioStats.go#L16-L26>)

### BlkioStats

English:

Stores All IO service stats for data read and write\.

This is a Linux specific structure as the differences between expressing block I/O on Windows and Linux are sufficiently significant to make little sense attempting to morph into a combined structure\.

Português:

Armazena todos os estatísticas de serviço de IO para leitura e escrita de dados\.

Este é um estrutura Linux específica devido às diferenças entre expressar o IO de bloco no Windows e Linux são suficientemente significativas para fazer pouco sentido tentar morfar em uma combinação de estrutura\.

```go
type BlkioStats struct {
    // number of bytes transferred to and from the block device
    IoServiceBytesRecursive []BlkioStatEntry `json:"io_service_bytes_recursive"`
    IoServicedRecursive     []BlkioStatEntry `json:"io_serviced_recursive"`
    IoQueuedRecursive       []BlkioStatEntry `json:"io_queue_recursive"`
    IoServiceTimeRecursive  []BlkioStatEntry `json:"io_service_time_recursive"`
    IoWaitTimeRecursive     []BlkioStatEntry `json:"io_wait_time_recursive"`
    IoMergedRecursive       []BlkioStatEntry `json:"io_merged_recursive"`
    IoTimeRecursive         []BlkioStatEntry `json:"io_time_recursive"`
    SectorsRecursive        []BlkioStatEntry `json:"sectors_recursive"`
}
```

## type [CPUStats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeCPUStats.go#L14-L26>)

### CPUStats

English:

Aggregates and wraps all CPU related info of container

Português:

Agrega e embrulha todas as informações de CPU do container

```go
type CPUStats struct {
    // CPU Usage. Linux and Windows.
    CPUUsage CPUUsage `json:"cpu_usage"`

    // System Usage. Linux only.
    SystemUsage uint64 `json:"system_cpu_usage,omitempty"`

    // Online CPUs. Linux only.
    OnlineCPUs uint32 `json:"online_cpus,omitempty"`

    // Throttling Data. Linux only.
    ThrottlingData ThrottlingData `json:"throttling_data,omitempty"`
}
```

## type [CPUUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeCPUUsage.go#L12-L33>)

### CPUUsage

English:

Stores All CPU stats aggregated since container inception\.

Português:

Armazena todos os estatísticas de CPU agregadas desde o container\.

```go
type CPUUsage struct {
    // Total CPU time consumed.
    // Units: nanoseconds (Linux)
    // Units: 100's of nanoseconds (Windows)
    TotalUsage uint64 `json:"total_usage"`

    // Total CPU time consumed per core (Linux). Not used on Windows.
    // Units: nanoseconds.
    PercpuUsage []uint64 `json:"percpu_usage,omitempty"`

    // Time spent by tasks of the cgroup in kernel mode (Linux).
    // Time spent by all container processes in kernel mode (Windows).
    // Units: nanoseconds (Linux).
    // Units: 100's of nanoseconds (Windows). Not populated for Hyper-V Containers.
    UsageInKernelmode uint64 `json:"usage_in_kernelmode"`

    // Time spent by tasks of the cgroup in user mode (Linux).
    // Time spent by all container processes in user mode (Windows).
    // Units: nanoseconds (Linux).
    // Units: 100's of nanoseconds (Windows). Not populated for Hyper-V Containers
    UsageInUsermode uint64 `json:"usage_in_usermode"`
}
```

## type [ContainerBuilder](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeContainerBuilder.go#L22-L93>)

### ContainerBuilder

English:

Docker manager

Português:

Gerenciador de containers e imagens docker

```go
type ContainerBuilder struct {
    metadata                map[string]interface{}
    problem                 string
    csvValueSeparator       string
    csvRowSeparator         string
    csvConstHeader          bool
    logCpus                 int
    rowsToPrint             int64
    chaos                   chaos
    enableCache             bool
    network                 isolatedNetwork.ContainerBuilderNetworkInterface
    dockerSys               DockerSystem
    changePointer           chan ContainerPullStatusSendToChannel
    onContainerReady        *chan bool
    onContainerInspect      *chan bool
    imageInspected          bool
    imageInstallExtras      bool
    imageCacheName          string
    imageName               string
    imageID                 string
    imageRepoTags           []string
    imageRepoDigests        []string
    imageParent             string
    imageComment            string
    imageCreated            time.Time
    imageContainer          string
    imageAuthor             string
    imageArchitecture       string
    imageVariant            string
    imageOs                 string
    imageOsVersion          string
    imageSize               int64
    imageVirtualSize        int64
    containerName           string
    buildPath               string
    environmentVar          []string
    changePorts             []dockerfileGolang.ChangePort
    openPorts               []string
    exposePortsOnDockerfile []string
    openAllPorts            bool
    waitString              string
    waitStringTimeout       time.Duration
    containerID             string
    ticker                  *time.Ticker
    inspect                 ContainerInspect
    logs                    string
    logsLastSize            int
    inspectInterval         time.Duration
    gitData                 gitData
    volumes                 []mount.Mount
    IPV4Address             string
    autoDockerfile          DockerfileAuto
    containerConfig         container.Config
    restartPolicy           RestartPolicy

    makeDefaultDockerfile bool
    printBuildOutput      bool
    init                  bool
    startedAfterBuild     bool

    contentIdRsaFile               string
    contentIdRsaFileWithScape      string
    contentKnownHostsFile          string
    contentKnownHostsFileWithScape string
    contentGitConfigFile           string
    contentGitConfigFileWithScape  string

    gitPathPrivateRepository string

    buildOptions        types.ImageBuildOptions
    imageExpirationTime time.Duration
}
```

<details><summary>Example (Func Set Time On Container Paused State On Chaos Scene)</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFailMatchFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFailMatchFlag.go#L22>)

```go
func (e *ContainerBuilder) AddFailMatchFlag(value string)
```

#### AddFailMatchFlag

Similar:

```
AddFailMatchFlag(), AddFailMatchFlagToFileLog(), AddFilterToFail()
```

English:

Error text searched for in the container's standard output\.

```
Input:
  value: Error text
```

Português:

Texto indicativo de erro procurado na saída padrão do container\.

```
Entrada:
  value: Texto indicativo de erro
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageExpirationTime(5 * time.Minute)

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/bug")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.SetCsvFileReader(true)

	container.SetCsvFileRowsToPrint(KLogColumnAll)

	container.AddFilterToCvsLogWithReplace(
		"contador",
		"counter",
		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",
		"\\.",
		",",
	)

	container.AddFailMatchFlag(
		"counter: 40",
	)

	err = container.AddFailMatchFlagToFileLog(
		"bug:",
		"./log1/log2/log3",
	)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)

				break
			}
		}

		if pass == true {
			break
		}
	}

	_ = container.StopMonitor()

	SaGarbageCollector()

	var data []byte
	data, err = ioutil.ReadFile("./log1/log2/log3/log.0.log")
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	if len(data) == 0 {
		fmt.Println("log file error")
	}

	_ = os.Remove("./log1/log2/log3/log.0.log")
	_ = os.Remove("./log1/log2/log3/")
	_ = os.Remove("./log1/log2/")
	_ = os.Remove("./log1/")

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: false
fail: true
error: false
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFailMatchFlagToFileLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFailMatchFlagToFileLog.go#L41>)

```go
func (e *ContainerBuilder) AddFailMatchFlagToFileLog(value, logDirectoryPath string) (err error)
```

#### AddFailMatchFlagToFileLog

Similar:

```
AddFailMatchFlag(), AddFailMatchFlagToFileLog(), AddFilterToFail()
```

English:

Looks for error text in the container's standard output and saves it to a log file on the host computer

```
Input:
  value: Error text
  logDirectoryPath: File path where the container's standard output filed in a `log.N.log` file
    will be saved, where N is an automatically incremented number. e.g.: "./bug/critical/"

Output:
  err: Default error object
```

Português:

Procura por um texto indicativo de erro na saída padrão do container e o salva em um arquivo de log no computador hospedeiro

```
Entrada:
  value: Texto indicativo de erro
  logDirectoryPath: Caminho do arquivo onde será salva a saída padrão do container arquivada em
    um arquivo `log.N.log`, onde N é um número incrementado automaticamente.
    Ex.: "./bug/critical/"

Output:
  err: Objeto de erro padrão
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageExpirationTime(5 * time.Minute)

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/bug")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.SetCsvFileReader(true)

	container.SetCsvFileRowsToPrint(KLogColumnAll)

	container.AddFilterToCvsLogWithReplace(
		"contador",
		"counter",
		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",
		"\\.",
		",",
	)

	container.AddFailMatchFlag(
		"counter: 40",
	)

	err = container.AddFailMatchFlagToFileLog(
		"bug:",
		"./log1/log2/log3",
	)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)

				break
			}
		}

		if pass == true {
			break
		}
	}

	_ = container.StopMonitor()

	SaGarbageCollector()

	var data []byte
	data, err = ioutil.ReadFile("./log1/log2/log3/log.0.log")
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	if len(data) == 0 {
		fmt.Println("log file error")
	}

	_ = os.Remove("./log1/log2/log3/log.0.log")
	_ = os.Remove("./log1/log2/log3/")
	_ = os.Remove("./log1/log2/")
	_ = os.Remove("./log1/")

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: false
fail: true
error: false
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFileOrFolderToLinkBetweenConputerHostAndContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFileOrFolderToLinkBetweenConputerHostAndContainer.go#L33>)

```go
func (e *ContainerBuilder) AddFileOrFolderToLinkBetweenConputerHostAndContainer(computerHostPath, insideContainerPath string) (err error)
```

#### AddFileOrFolderToLinkBetweenConputerHostAndContainer

English:

Links a file or folder between the computer host and the container\.

```
Input:
  computerHostPath:    Path of the file or folder inside the host computer.
  insideContainerPath: Path inside the container.

Output:
  err: Default error object.
```

Português:

Vincula um arquivo ou pasta entre o computador e o container\.

```
Entrada:
  computerHostPath:    Caminho do arquivo ou pasta no computador hospedeiro.
  insideContainerPath: Caminho dentro do container.

Output:
  err: Objeto de erro padrão.
```

<details><summary>Example</summary>
<p>

```go
{

	var err error

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetImageExpirationTime(5 * time.Minute)

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout(
		"Stating server on port 3000",
		10*time.Second,
	)

	container.AddPortToChange(
		"3000",
		"3030",
	)

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer(
		"./test/static",
		"/static",
	)
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// English: Read server inside a container on address http://localhost:3030/
	//
	// Português: Lê o servidor dentro do container em http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFilterToCvsLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToCvsLog.go#L36>)

```go
func (e *ContainerBuilder) AddFilterToCvsLog(label, match, filter string)
```

#### AddFilterToCvsLog

Similar:

```
AddFilterToCvsLogWithReplace(), AddFilterToCvsLog()
```

English:

Adds a filter to search and convert a textual value to a column in the log file\.

```
Input:
  label: Value to be placed in the log file column.
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
```

Note:

```
* This function is used in conjunction with SetCsvLogPath(), StartMonitor(), StopMonitor().
```

Português:

Adiciona um filtro para procurar e converter um valor textual em uma coluna no arquivo de log\.

```
Entrada:
  label: Valor do rótulo a ser colocado na coluna do arquivo de log.
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
```

Nota:

```
* Esta função é usada em conjunto com SetCsvLogPath(), StartMonitor(), StopMonitor()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMeWithInstallExtras()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/counter")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvFileReader(true)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		":",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 40000000",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFilterToCvsLogWithReplace](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToLogWithReplace.go#L42>)

```go
func (e *ContainerBuilder) AddFilterToCvsLogWithReplace(label, match, filter, search, replace string)
```

#### AddFilterToCvsLogWithReplace

Similar:

```
AddFilterToCvsLogWithReplace(), AddFilterToCvsLog()
```

English:

Adds a filter to search and convert a textual value to a column in the CSV log file\.

```
Input:
  label: Value to be placed in the log file column.
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
  search: Regular expression used for search and replacement in the text found in the previous
    step [optional].
  replace: Regular expression replace element [optional].
```

Note:

```
* This function is used in conjunction with SetCsvLogPath(), StartMonitor(), StopMonitor().
```

Português:

Adiciona um filtro para procurar e converter um valor textual em uma coluna no arquivo de log CSV\.

```
Entrada:
  label: Valor do rótulo a ser colocado na coluna do arquivo de log.
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
  search: Expressão regular usada para busca e substituição no texto encontrado na etapa anterior
    [opcional].
  replace: Elemento da troca da expressão regular [opcional].
```

Nota:

```
* Esta função é usada em conjunto com SetCsvLogPath(), StartMonitor(), StopMonitor()
```

### func \(\*ContainerBuilder\) [AddFilterToFail](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToFail.go#L36>)

```go
func (e *ContainerBuilder) AddFilterToFail(match, filter, search, replace string)
```

#### AddFilterToFail

Similar:

```
AddFailMatchFlag(), AddFailMatchFlagToFileLog(), AddFilterToFail()
```

English:

Adds a filter to the container's standard output to look for a textual value indicating test failure\.

```
Input:
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
  search: Regular expression used for search and replacement in the text found in the previous
    step [optional].
  replace: Regular expression replace element [optional].
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual indicador de falha do teste\.

```
Entrada:
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
  search: Expressão regular usada para busca e substituição no texto encontrado na etapa anterior
    [opcional].
  replace: Elemento da troca da expressão regular [opcional].
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/counter")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 40",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFilterToRestartContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToRestartContainer.go#L50>)

```go
func (e *ContainerBuilder) AddFilterToRestartContainer(match, filter, search, replace string)
```

#### AddFilterToRestartContainer

Similar:

```
AddFilterToRestartContainer(), AddRestartMatchFlag(), AddRestartMatchFlagToFileLog()
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando a possibilidade do container ser reinicado durante o teste de caos\.

```
Entrada:
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
  search: Expressão regular usada para busca e substituição no texto encontrado na etapa anterior
    [opcional].
  replace: Elemento da troca da expressão regular [opcional].
```

Nota:

```
* Teste de caos é um teste feito quando há a necessidade de simular falhas dos microsserviços
  envolvidos no projeto.
  Durante o teste de caos, o container pode ser pausado, para simular um container não
  respondendo devido a sobrecarga, ou parado e reiniciado, simulando uma queda crítica, onde um
  microsserviço foi reinicializado depois de um tempo sem resposta.
```

English:

Adds a filter to the standard output of the container to look for a textual value releasing the possibility of the container being restarted during the chaos test\.

```
Input:
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
  search: Regular expression used for search and replacement in the text found in the previous
    step [optional].
  replace: Regular expression replace element [optional].
```

Note:

```
* Chaos testing is a test performed when there is a need to simulate failures of the
  microservices involved in the project.
  During chaos testing, the container can be paused, to simulate a container not responding due
  to overload, or stopped and restarted, simulating a critical crash, where a microservice was
  restarted after an unresponsive time.
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFilterToStartChaos](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToStartChaos.go#L50>)

```go
func (e *ContainerBuilder) AddFilterToStartChaos(match, filter, search, replace string)
```

#### AddFilterToStartChaos

Similar:

```
AddStartChaosMatchFlag(), AddStartChaosMatchFlagToFileLog(), AddFilterToStartChaos()
```

English:

Adds a filter to the container's standard output to look for a textual value releasing the start of the chaos test\.

```
Input:
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
  search: Regular expression used for search and replacement in the text found in the previous
    step [optional].
  replace: Regular expression replace element [optional].
```

Note:

```
* Chaos testing is a test performed when there is a need to simulate failures of the
  microservices involved in the project.
  During chaos testing, the container can be paused, to simulate a container not responding due
  to overload, or stopped and restarted, simulating a critical crash, where a microservice was
  restarted after an unresponsive time.
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando o início do teste de caos\.

```
Entrada:
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
  search: Expressão regular usada para busca e substituição no texto encontrado na etapa anterior
    [opcional].
  replace: Elemento da troca da expressão regular [opcional].
```

Nota:

```
* Teste de caos é um teste feito quando há a necessidade de simular falhas dos microsserviços
  envolvidos no projeto.
  Durante o teste de caos, o container pode ser pausado, para simular um container não
  respondendo devido a sobrecarga, ou parado e reiniciado, simulando uma queda crítica, onde um
  microsserviço foi reinicializado depois de um tempo sem resposta.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddFilterToSuccess](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddFilterToSuccess.go#L30>)

```go
func (e *ContainerBuilder) AddFilterToSuccess(match, filter, search, replace string)
```

#### AddFilterToFail

English:

Adds a filter to the container's standard output to look for a textual value indicating test success\.

```
Input:
  match: Simple text searched in the container's standard output to activate the filter
  filter: Regular expression used to filter what goes into the log using the `valueToGet`
    parameter.
  search: Regular expression used for search and replacement in the text found in the previous
    step [optional].
  replace: Regular expression replace element [optional].
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual indicador de sucesso do teste\.

```
Entrada:
  match: Texto simples procurado na saída padrão do container para ativar o filtro
  filter: Expressão regular usada para filtrar o que vai para o log usando o parâmetro
    `valueToGet`.
  search: Expressão regular usada para busca e substituição no texto encontrado na etapa anterior
    [opcional].
  replace: Elemento da troca da expressão regular [opcional].
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddImageBuildOptionsBuildArgs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddImageBuildOptionsBuildArgs.go#L60>)

```go
func (e *ContainerBuilder) AddImageBuildOptionsBuildArgs(key string, value *string)
```

#### AddImageBuildOptionsBuildArgs

English:

Set build\-time variables \(\-\-build\-arg\)

```
Input:
  key: Argument name
  value: Argument value
```

Example:

```
key:   argument key (e.g. Dockerfile: ARG key)
value: argument value

https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg
docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234

  code:
    var key = "GIT_PRIVATE_REPO"
    var value = "github.com/yourgit"

    var container = ContainerBuilder{}
    container.AddImageBuildOptionsBuildArgs(key, &value)

  Dockerfile:
    FROM golang:1.16-alpine as builder
    ARG GIT_PRIVATE_REPO
    RUN go env -w GOPRIVATE=$GIT_PRIVATE_REPO
```

Português:

Adiciona uma variável durante a construção \(\-\-build\-arg\)

```
Input:
  key: Nome do argumento.
  value: Valor do argumento.
```

Exemplo:

```
key:   chave do argumento (ex. Dockerfile: ARG key)
value: valor do argumento

https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg
docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234

  code:
    var key = "GIT_PRIVATE_REPO"
    var value = "github.com/yourgit"

    var container = ContainerBuilder{}
    container.AddImageBuildOptionsBuildArgs(key, &value)

  Dockerfile:
    FROM golang:1.16-alpine as builder
    ARG GIT_PRIVATE_REPO
    RUN go env -w GOPRIVATE=$GIT_PRIVATE_REPO
```

### func \(\*ContainerBuilder\) [AddPortToChange](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddPortToChange.go#L39>)

```go
func (e *ContainerBuilder) AddPortToChange(imagePort string, newPort string)
```

#### AddPortToChange

English:

Defines a new port to be exposed on the network and links with the port defined in the image

```
Input:
  imagePort: port defined in the image, in the form of a numeric string
  newPort: new port value to be exposed on the network
```

Nota:

```
* The ports exposed in the creation of the container can be defined by
  SetOpenAllContainersPorts(), AddPortToChange() e AddPortToExpose();
* By default, all doors are closed;
* The ImageListExposedPorts() function returns all ports defined in the image to be exposed.
```

Português:

Define uma nova porta a ser exposta na rede e vincula com a porta definida na imagem

```
Entrada:
  imagePort: porta definida na imagem, na forma de string numérica
  newPort: novo valor da porta a se exposta na rede
```

Nota:

```
* As portas expostas na criação do container pode ser definidas por SetOpenAllContainersPorts(),
  AddPortToChange() e AddPortToExpose();
* Por padrão, todas as portas ficam fechadas;
* A função ImageListExposedPorts() retorna todas as portas definidas na imagem para serem
  expostas.
```

<details><summary>Example</summary>
<p>

```go
{

	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// English: read server inside a container on address http://localhost:3030/
	//
	// Português: lê o servidor dentro do container na porta http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddPortToDockerfileExpose](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddPortToDockerfileExpose.go#L18>)

```go
func (e *ContainerBuilder) AddPortToDockerfileExpose(value string)
```

#### AddPortToDockerfileExpose

English:

Add ports to dockerfile expose tag\.

```
Input:
  value: port in string form (without a colon, ":")
```

Português:

Adiciona portas a tag expose do dockerfile\.

```
Entrada:
  value: porta na forma de string (sem dois pontos, ":")
```

### func \(\*ContainerBuilder\) [AddPortToExpose](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddPortToExpose.go#L33>)

```go
func (e *ContainerBuilder) AddPortToExpose(value string)
```

#### AddPortToExpose

English:

Defines the port to be exposed on the network

```
Input:
  value: port in the form of a numeric string
```

Note:

```
* The ports exposed in the creation of the container can be defined by
  SetOpenAllContainersPorts(), AddPortToChange() and AddPortToExpose();
* By default, all doors are closed;
* The ImageListExposedPorts() function returns all ports defined in the image to be exposed.
```

Português:

```
Define a porta a ser expostas na rede

Entrada:
  value: porta na forma de string numérica
```

Nota:

```
* As portas expostas na criação do container pode ser definidas por SetOpenAllContainersPorts(),
  AddPortToChange() e AddPortToExpose();
* Por padrão, todas as portas ficam fechadas;
* A função ImageListExposedPorts() retorna todas as portas definidas na imagem para serem
  expostas.
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/helmutkemper/util"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

func main() {
	AddPortToExpose()
}

func AddPortToExpose() {
	var err error

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	SaGarbageCollector()

	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	container.SetPrintBuildOnStrOut()

	// English: If there is an image named `cache:latest`, it will be used as a base to create the container.
	//
	// Português: Caso exista uma imagem de nome `cache:latest`, ela será usada como base para criar o container.
	container.SetCacheEnable(true)

	// English: Name of the new image to be created.
	//
	// Português: Nome da nova imagem a ser criada.
	container.SetImageName("delete:latest")

	// English: Defines the name of the docker container to be created.
	//
	// Português: Define o nome do container docker a ser criado.
	container.SetContainerName("container_delete_server_after_test")

	//todo: documentar
	// git project to clone https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git
	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	// see SetGitCloneToBuildWithUserPassworh(), SetGitCloneToBuildWithPrivateSshKey() and
	// SetGitCloneToBuildWithPrivateToken()

	// English: Set a waits for the text to appear in the standard container output to proceed [optional]
	//
	// Português: Define a espera pelo texto aguardado aparecer na saída padrão do container para prosseguir [opcional]
	container.SetWaitStringWithTimeout("Stating server on port 3000", 20*time.Second)

	// open port 3000 [optional in this case: default code open all ports]
	container.AddPortToExpose("3000")

	// English: Replace container folder /static to host folder ./test/static
	//
	// Português: Substitua a pasta do container /static para a pasta da máquina ./test/static
	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	// English: Initializes the container manager object.
	//
	// Português: Inicializa o objeto gerenciador de container.
	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	// builder new image from git project
	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	// container build from image delete:latest
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// container "container_delete_server_after_test" running and ready for use on this code point on port 3030

	// read server inside a container on address http://localhost:3000/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3000/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	// print output
	fmt.Printf("%s", body)

	SaGarbageCollector()

	// Output:
	// <html><body><p>C is life! Golang is a evolution of C</p></body></html>
}
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddRestartMatchFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddRestartMatchFlag.go#L40>)

```go
func (e *ContainerBuilder) AddRestartMatchFlag(value string)
```

#### AddRestartMatchFlag

Similar:

```
AddFilterToRestartContainer(), AddRestartMatchFlag(), AddRestartMatchFlagToFileLog()
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando a possibilidade do container ser reinicado durante o teste de caos\.

```
Entrada:
  value: Texto simples procurado na saída padrão do container para ativar o filtro
```

Nota:

```
* Teste de caos é um teste feito quando há a necessidade de simular falhas dos microsserviços
  envolvidos no projeto.
  Durante o teste de caos, o container pode ser pausado, para simular um container não
  respondendo devido a sobrecarga, ou parado e reiniciado, simulando uma queda crítica, onde um
  microsserviço foi reinicializado depois de um tempo sem resposta.
```

English:

Adds a filter to the standard output of the container to look for a textual value releasing the possibility of the container being restarted during the chaos test\.

```
Input:
  value: Simple text searched in the container's standard output to activate the filter
```

Note:

```
* Chaos testing is a test performed when there is a need to simulate failures of the
  microservices involved in the project.
  During chaos testing, the container can be paused, to simulate a container not responding due
  to overload, or stopped and restarted, simulating a critical crash, where a microservice was
  restarted after an unresponsive time.
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddRestartMatchFlag(

		"restart-me!",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddRestartMatchFlagToFileLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddRestartMatchFlagToFileLog.go#L51>)

```go
func (e *ContainerBuilder) AddRestartMatchFlagToFileLog(value, logDirectoryPath string) (err error)
```

#### AddRestartMatchFlagToFileLog

Similar:

```
AddFilterToRestartContainer(), AddRestartMatchFlag(), AddRestartMatchFlagToFileLog()
```

English:

Adds a filter to the standard output of the container to look for a textual value releasing the possibility of the container being restarted during the chaos test\.

```
Input:
  value: Simple text searched in the container's standard output to activate the filter
  logDirectoryPath: File path where the container's standard output filed in a `log.N.log` file
    will be saved, where N is an automatically incremented number. e.g.: "./bug/critical/"
```

Note:

```
* Chaos testing is a test performed when there is a need to simulate failures of the
  microservices involved in the project.
  During chaos testing, the container can be paused, to simulate a container not responding due
  to overload, or stopped and restarted, simulating a critical crash, where a microservice was
  restarted after an unresponsive time.
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando a possibilidade do container ser reinicado durante o teste de caos\.

```
Entrada:
  value: Texto simples procurado na saída padrão do container para ativar o filtro
  logDirectoryPath: Caminho do arquivo onde será salva a saída padrão do container arquivada em
    um arquivo `log.N.log`, onde N é um número incrementado automaticamente.
    Ex.: "./bug/critical/"
```

Nota:

```
* Teste de caos é um teste feito quando há a necessidade de simular falhas dos microsserviços
  envolvidos no projeto.
  Durante o teste de caos, o container pode ser pausado, para simular um container não
  respondendo devido a sobrecarga, ou parado e reiniciado, simulando uma queda crítica, onde um
  microsserviço foi reinicializado depois de um tempo sem resposta.
```

<details><summary>Example</summary>
<p>

```go
{

	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	err = container.AddRestartMatchFlagToFileLog(

		"restart-me!",

		"./log1/log2/log3",
	)
	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [AddStartChaosMatchFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddStartChaosMatchFlag.go#L22>)

```go
func (e *ContainerBuilder) AddStartChaosMatchFlag(value string)
```

#### AddStartChaosMatchFlag

Similar:

```
AddStartChaosMatchFlag(), AddStartChaosMatchFlagToFileLog(), AddFilterToStartChaos()
```

English:

Adds a filter to the container's standard output to look for a textual value releasing the start of the chaos test\.

```
Input:
  value: Error text
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando o início do teste de caos\.

```
Entrada:
  value: Texto indicativo de erro
```

### func \(\*ContainerBuilder\) [AddStartChaosMatchFlagToFileLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddStartChaosMatchFlagToFileLog.go#L42>)

```go
func (e *ContainerBuilder) AddStartChaosMatchFlagToFileLog(value, logDirectoryPath string) (err error)
```

#### AddStartChaosMatchFlagToFileLog

Similar:

```
AddStartChaosMatchFlag(), AddStartChaosMatchFlagToFileLog(), AddFilterToStartChaos()
```

English:

Adds a filter to the container's standard output to look for a textual value releasing the start of the chaos test\.

```
Input:
  value: Error text
  logDirectoryPath: File path where the container's standard output filed in a `log.N.log` file
    will be saved, where N is an automatically incremented number.
    e.g.: "./bug/critical/"

Output:
  err: Default error object
```

Português:

Adiciona um filtro na saída padrão do container para procurar um valor textual liberando o início do teste de caos\.

```
Entrada:
  value: Texto indicativo de erro
  logDirectoryPath: Caminho do arquivo onde será salva a saída padrão do container arquivada em
    um arquivo `log.N.log`, onde N é um número incrementado automaticamente.
    Ex.: "./bug/critical/"

Output:
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [AddSuccessMatchFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddSuccessMatchFlag.go#L18>)

```go
func (e *ContainerBuilder) AddSuccessMatchFlag(value string)
```

#### AddSuccessMatchFlag

English:

Adds a text to be searched for in the container's standard output\, indicating test success

```
Input:
  value: Text searched for in the container's standard output
```

Português:

Adiciona um texto a ser procurado na saída padrão do conteiner\, indicando sucesso do teste

```
Entrada:
  value: Texto procurado na saída padrão do container
```

### func \(\*ContainerBuilder\) [ContainerBuildAndStartFromImage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerBuildAndStartFromImage.go#L25>)

```go
func (e *ContainerBuilder) ContainerBuildAndStartFromImage() (err error)
```

#### ContainerBuildAndStartFromImage

English:

Transforms an image downloaded by ImagePull\(\) or created by ImageBuildFromFolder\(\) into a container and start it\.

```
Output:
  err: Default object error from golang
```

Português:

Transforma uma imagem baixada por ImagePull\(\) ou criada por ImageBuildFromFolder\(\) em container e o inicializa\.

```
Saída:
  err: Objeto padrão de erro golang
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// read server inside a container on address http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [ContainerBuildWithoutStartingItFromImage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerBuildWithoutStartingItFromImage.go#L28>)

```go
func (e *ContainerBuilder) ContainerBuildWithoutStartingItFromImage() (err error)
```

#### ContainerBuildWithoutStartingItFromImage

English:

Transforms an image downloaded by ImagePull\(\) or created by ImageBuildFromFolder\(\) into a container

```
Output:
  err: Default object error from golang
```

Português:

Transforma uma imagem baixada por ImagePull\(\) ou criada por ImageBuildFromFolder\(\) em container

```
Saída:
  err: Objeto padrão de erro golang
```

### func \(\*ContainerBuilder\) [ContainerCopyFrom](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerCopyFrom.go#L36-L42>)

```go
func (e *ContainerBuilder) ContainerCopyFrom(containerPathList []string, hostPathList []string) (statsList []types.ContainerPathStat, err error)
```

#### ContainerCopyFrom

Português:

Copia um arquivo contido no container para uma pasta local

```
Entrada:
  containerPathList: lista de arquivos contidos no container (caminho + nome do arquivo)
  hostPathList:      lista de caminhos dos arquivos a serem salvos no host (caminho + nome do
    arquivo)

Saída:
  statsList: Lista de informações dos arquivos
  err:       Objeto padrão de error
```

English:

Copy a file contained in the container to a local folder

```
Input:
  containerPathList: list of files contained in the container (folder path + file name)
  hostPathList:      list of file paths to be saved on the host (folder path + file name)

Output:
  statsList: List of file information
  err:       Default error object
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/docker/docker/api/types"
	"log"
	"os"
)

func main() {
	var err error

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	err = buildGoLintImageCopyFromExample()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = builAlpineImageCopyFromExample()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	_ = os.Remove("./example/golint/golangci-lint")

}

func buildGoLintImageCopyFromExample() (err error) {
	var imageInspect types.ImageInspect
	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	// [optional/opcional]
	container.SetPrintBuildOnStrOut()

	// English: Name of the new image to be created.
	//
	// Português: Nome da nova imagem a ser criada.
	container.SetImageName("golint_delete:latest")

	// English: Golang project path to be turned into docker image
	//
	// Português: Caminho do projeto em Golang a ser transformado em imagem docker
	container.SetBuildFolderPath("./example/golint/imageGolintBuild")

	// English: Defines the name of the docker container to be created.
	//
	// Português: Define o nome do container docker a ser criado.
	container.SetContainerName("container_golint_delete_after_test")

	// English: Initializes the container manager object.
	//
	// Português: Inicializa o objeto gerenciador de container.
	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Creates an image from a project folder.
	//
	// Português: Cria uma imagem a partir de uma pasta de projeto.
	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	// English: Creates and initializes the container based on the created image.
	//
	// Português: Cria e inicializa o container baseado na imagem criada.
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	var copyResponse []types.ContainerPathStat
	copyResponse, err = container.ContainerCopyFrom(
		[]string{"/go/pkg/mod/github.com/golangci/golangci-lint@v1.23.6/bin/golangci-lint"},
		[]string{"./example/golint/golangci-lint"},
	)
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	fmt.Printf("file name: %v\n", copyResponse[0].Name)

	return
}

func builAlpineImageCopyFromExample() (err error) {
	var imageInspect types.ImageInspect
	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	// [optional/opcional]
	container.SetPrintBuildOnStrOut()

	// English: Name of the new image to be created.
	//
	// Português: Nome da nova imagem a ser criada.
	container.SetImageName("alpine_delete:latest")

	// English: Golang project path to be turned into docker image
	//
	// Português: Caminho do projeto em Golang a ser transformado em imagem docker
	container.SetBuildFolderPath("./example/golint/imageAlpineBuild")

	// English: Defines the name of the docker container to be created.
	//
	// Português: Define o nome do container docker a ser criado.
	container.SetContainerName("container_alpine_delete_after_test")

	// English: Initializes the container manager object.
	//
	// Português: Inicializa o objeto gerenciador de container.
	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Creates an image from a project folder.
	//
	// Português: Cria uma imagem a partir de uma pasta de projeto.
	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	// English: Creates and initializes the container based on the created image.
	//
	// Português: Cria e inicializa o container baseado na imagem criada.
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.ContainerCopyTo(
		[]string{"./example/golint/golangci-lint"},
		[]string{"/go"},
	)

	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	var exitCode int
	var runing bool
	var stdOutput []byte
	var stdError []byte
	exitCode, runing, stdOutput, stdError, err = container.ContainerExecCommand([]string{"ls", "-l"})

	log.Printf("exitCode: %v", exitCode)
	log.Printf("runing: %v", runing)
	log.Printf("stdOutput: %v", string(stdOutput))
	log.Printf("stdError: %v", string(stdError))

	exitCode, runing, stdOutput, stdError, err = container.ContainerExecCommand([]string{"./golangci-lint"})

	log.Printf("exitCode: %v", exitCode)
	log.Printf("runing: %v", runing)
	log.Printf("stdOutput: %v", string(stdOutput))
	log.Printf("stdError: %v", string(stdError))

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	return
}
```

#### Output

```
image size: 510.9 MB
image os: linux
file name: golangci-lint
image size: 281.8 MB
image os: linux
```

</p>
</details>

### func \(\*ContainerBuilder\) [ContainerCopyTo](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerCopyTo.go#L33-L38>)

```go
func (e *ContainerBuilder) ContainerCopyTo(hostPathList []string, containerPathList []string) (err error)
```

#### ContainerCopyTo

Português:

Copia um arquivo contido no computador local para dentro do container

```
Entrada:
  hostPathList: lista de arquivos a serem salvos no computador hospedeiro (caminho + nome do
    arquivo)
  containerPathList: lista de arquivos contidos no container (apenas o caminho)

Saída:
  err: Objeto de erro padrão
```

English:

Copy a file contained on the local computer into the container

```
Input:
  hostPathList: list of files to be saved on the host computer (path + filename)
  containerPathList: list of files contained in the container (path only)

Output:
  err: standard error object
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/docker/docker/api/types"
	"log"
	"os"
)

func main() {
	var err error

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	err = buildGoLintImageCopyToExample()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = builAlpineImageCopyToExample()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	_ = os.Remove("./example/golint/golangci-lint")

}

func buildGoLintImageCopyToExample() (err error) {
	var imageInspect types.ImageInspect
	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	// [optional/opcional]
	container.SetPrintBuildOnStrOut()

	// English: Name of the new image to be created.
	//
	// Português: Nome da nova imagem a ser criada.
	container.SetImageName("golint_delete:latest")

	// English: Golang project path to be turned into docker image
	//
	// Português: Caminho do projeto em Golang a ser transformado em imagem docker
	container.SetBuildFolderPath("./example/golint/imageGolintBuild")

	// English: Defines the name of the docker container to be created.
	//
	// Português: Define o nome do container docker a ser criado.
	container.SetContainerName("container_golint_delete_after_test")

	// English: Initializes the container manager object.
	//
	// Português: Inicializa o objeto gerenciador de container.
	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Creates an image from a project folder.
	//
	// Português: Cria uma imagem a partir de uma pasta de projeto.
	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	// English: Creates and initializes the container based on the created image.
	//
	// Português: Cria e inicializa o container baseado na imagem criada.
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	var copyResponse []types.ContainerPathStat
	copyResponse, err = container.ContainerCopyFrom(
		[]string{"/go/pkg/mod/github.com/golangci/golangci-lint@v1.23.6/bin/golangci-lint"},
		[]string{"./example/golint/golangci-lint"},
	)
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	fmt.Printf("file name: %v\n", copyResponse[0].Name)

	return
}

func builAlpineImageCopyToExample() (err error) {
	var imageInspect types.ImageInspect
	var container = ContainerBuilder{}

	// English: print the standard output of the container
	//
	// Português: imprime a saída padrão do container
	// [optional/opcional]
	container.SetPrintBuildOnStrOut()

	// English: Name of the new image to be created.
	//
	// Português: Nome da nova imagem a ser criada.
	container.SetImageName("alpine_delete:latest")

	// English: Golang project path to be turned into docker image
	//
	// Português: Caminho do projeto em Golang a ser transformado em imagem docker
	container.SetBuildFolderPath("./example/golint/imageAlpineBuild")

	// English: Defines the name of the docker container to be created.
	//
	// Português: Define o nome do container docker a ser criado.
	container.SetContainerName("container_alpine_delete_after_test")

	// English: Initializes the container manager object.
	//
	// Português: Inicializa o objeto gerenciador de container.
	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	// English: Creates an image from a project folder.
	//
	// Português: Cria uma imagem a partir de uma pasta de projeto.
	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	// English: Creates and initializes the container based on the created image.
	//
	// Português: Cria e inicializa o container baseado na imagem criada.
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.ContainerCopyTo(
		[]string{"./example/golint/golangci-lint"},
		[]string{"/go"},
	)

	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	var exitCode int
	var runing bool
	var stdOutput []byte
	var stdError []byte
	exitCode, runing, stdOutput, stdError, err = container.ContainerExecCommand([]string{"ls", "-l"})

	log.Printf("exitCode: %v", exitCode)
	log.Printf("runing: %v", runing)
	log.Printf("stdOutput: %v", string(stdOutput))
	log.Printf("stdError: %v", string(stdError))

	exitCode, runing, stdOutput, stdError, err = container.ContainerExecCommand([]string{"./golangci-lint"})

	log.Printf("exitCode: %v", exitCode)
	log.Printf("runing: %v", runing)
	log.Printf("stdOutput: %v", string(stdOutput))
	log.Printf("stdError: %v", string(stdError))

	// English: Deletes all docker elements with the term `delete` in the name.
	//
	// Português: Apaga todos os elementos docker com o termo `delete` no nome.
	// [optional/opcional]
	SaGarbageCollector()

	return
}
```

#### Output

```
image size: 510.9 MB
image os: linux
file name: golangci-lint
image size: 281.8 MB
image os: linux
```

</p>
</details>

### func \(\*ContainerBuilder\) [ContainerExecCommand](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerExecCommand.go#L34-L42>)

```go
func (e *ContainerBuilder) ContainerExecCommand(commands []string) (exitCode int, runing bool, stdOutput []byte, stdError []byte, err error)
```

#### ContainerExecCommand

Português:

Executa comandos dentro do container\.

```
Entrada:
  commands: lista de comandos. Ex.: []string{"ls", "-l"}

Saída:
  exitCode: código de saída do comando.
  runing: indica se o comando está rodando.
  stdOutput: saída padrão do comando.
  stdError: saída de erro do comando.
  err: objeto de erro padrão.
```

English:

Execute commands inside the container\.

```
Input:
  commands: command list. Eg: []string{"ls", "-l"}

Output:
  exitCode: command exit code.
  runing: indicates whether the command is running.
  stdOutput: standard output of the command.
  stdError: error output from the command.
  err: standard error object.
```

### func \(\*ContainerBuilder\) [ContainerFindIdByName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerFindIdByName.go#L35>)

```go
func (e *ContainerBuilder) ContainerFindIdByName(name string) (id string, err error)
```

#### ContainerFindIdByName

Similar:

```
ContainerFindIdByName(), ContainerFindIdByNameContains()
```

English:

Searches and returns the ID of the container\, if it exists

```
Input:
  name: Full name of the container.

Output:
  id: container ID
  err: standard error object
```

Português:

Procura e retorna o ID do container\, caso o mesmo exista

```
Entrada:
  name: Nome completo do container.

Saída:
  id: ID do container
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerFindIdByNameContains](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerFindIdByNameContains.go#L35>)

```go
func (e *ContainerBuilder) ContainerFindIdByNameContains(containsName string) (list []NameAndId, err error)
```

#### ContainerFindIdByNameContains

Similar:

```
ContainerFindIdByName(), ContainerFindIdByNameContains()
```

English:

Searches and returns the ID list of the container name

```
Input:
  name: name of the container.

Output:
  id: list of containers ID
  err: standard error object
```

Português:

Procura e retorna uma lista de IDs de containers

```
Entrada:
  name: Nome do container.

Saída:
  id: lista de IDs dos containers
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerInspect](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerInspect.go#L25>)

```go
func (e *ContainerBuilder) ContainerInspect() (inspect ContainerInspect, err error)
```

#### ContainerInspect

English:

Inspects the container

```
Output:
  inspect: Contains information about the container, such as ID, name, status, volumes, etc.
  err: Standard error object.
```

Português:

Inspeciona o container

```
Saída:
  inspect: Contém informações sobre o container, como ID, nome, status, volumes, etc.
  err: Objeto de erro padrão.
```

### func \(\*ContainerBuilder\) [ContainerPause](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerPause.go#L43>)

```go
func (e *ContainerBuilder) ContainerPause() (err error)
```

#### ContainerPause

English:

Pause the container\.

```
Output:
  err: Default error object.
```

Note:

```
* There are two ways to create a container:
  ContainerBuildAndStartFromImage, initializes the oncontainer and initializes the registry to
  the docker network, so that it works correctly.
  ContainerBuildWithoutStartingItFromImage just creates the container, so the first time it runs,
  it must have its network registry initialized so it can work properly.
* After initializing the first time, use the functions, ContainerStart, ContainerPause and
  ContainerStop, if you need to control the container.
```

Português:

Pausa o container\.

```
Saída:
  err: Objeto de erro padrão.
```

Nota:

```
* Ha duas formas de criar um container:
  ContainerBuildAndStartFromImage, inicializa o oncontainer e inicializa o registro aa rede
  docker, para que o mesmo funcione de forma correta.
  ContainerBuildWithoutStartingItFromImage apenas cria o container, por isto, a primeira vez que
  o mesmo roda, ele deve ter o seu registro de rede inicializado para que possa funcionar de
  forma correta.
* Apos inicializado a primeira vez, use as funções, ContainerStart, ContainerPause e
  ContainerStop, caso necessite controlar o container.
```

### func \(\*ContainerBuilder\) [ContainerRemove](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerRemove.go#L28>)

```go
func (e *ContainerBuilder) ContainerRemove(removeVolumes bool) (err error)
```

#### ContainerRemove

English:

Stop and remove the container

```
Input:
  removeVolumes: removes docker volumes linked to the container

Output:
  err: standard error object
```

Português:

Parar e remover o container

```
Entrada:
  removeVolumes: remove os volumes docker vinculados ao container

Saída:
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerRestart](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerRestart.go#L22>)

```go
func (e *ContainerBuilder) ContainerRestart() (err error)
```

#### ContainerRestart

English:

Restarts a container stopped by ContainerStop\(\)\.

```
Output:
  err: standard error object
```

Português:

Reinicia um container parado por ContainerStop\(\)\.

```
Saída:
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerRestartWithTimeout](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerRestartWithTimeout.go#L29>)

```go
func (e *ContainerBuilder) ContainerRestartWithTimeout(timeout time.Duration) (err error)
```

#### ContainerRestartWithTimeout

English:

Restarts a container stopped by ContainerStop\(\)\.

```
Input:
  timeout: timeout to restar container

Output:
  err: standard error object
```

Português:

Reinicia um container parado por ContainerStop\(\)\.

```
Entrada:
  timeout: tempo limite para reinício do container

Saída:
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerSetDisabePauseOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerSetDisabePauseOnChaosScene.go#L50>)

```go
func (e *ContainerBuilder) ContainerSetDisabePauseOnChaosScene(value bool)
```

#### ContainerSetDisabePauseOnChaosScene

English:

Set the container pause functionality to be disabled when the chaos scene is running

```
Input:
  value: true to disable the container pause functionality
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define se a funcionalidade de pausar o container será desabilitada quando a cena de chaos estiver em execução

```
Entrada:
  value: true para desabilitar a funcionalidade de pausar o container
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

### func \(\*ContainerBuilder\) [ContainerSetDisabeStopOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerSetDisabeStopOnChaosScene.go#L50>)

```go
func (e *ContainerBuilder) ContainerSetDisabeStopOnChaosScene(value bool)
```

#### ContainerSetDisabeStopOnChaosScene

English:

Set the container stop functionality to be disabled when the chaos scene is running

```
Input:
  value: true to disable the container stop functionality
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define se a funcionalidade de parar o container será desabilitada quando a cena de chaos estiver em execução

```
Entrada:
  value: true para desabilitar a funcionalidade de parar o container
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

### func \(\*ContainerBuilder\) [ContainerStart](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerStart.go#L43>)

```go
func (e *ContainerBuilder) ContainerStart() (err error)
```

#### ContainerStart

English:

Initialize a paused or stoped container

```
Output:
  err: Default error object.
```

Note:

```
* There are two ways to create a container:
  ContainerBuildAndStartFromImage, initializes the oncontainer and initializes the registry to
  the docker network, so that it works correctly.
  ContainerBuildWithoutStartingItFromImage just creates the container, so the first time it runs,
  it must have its network registry initialized so it can work properly.
* After initializing the first time, use the functions, ContainerStart, ContainerPause and
  ContainerStop, if you need to control the container.
```

Português:

Inicializar um container pausado ou parado\.

```
Saída:
  err: Objeto de erro padrão.
```

Nota:

```
* Ha duas formas de criar um container:
  ContainerBuildAndStartFromImage, inicializa o oncontainer e inicializa o registro aa rede
  docker, para que o mesmo funcione de forma correta.
  ContainerBuildWithoutStartingItFromImage apenas cria o container, por isto, a primeira vez que
  o mesmo roda, ele deve ter o seu registro de rede inicializado para que possa funcionar de
  forma correta.
* Apos inicializado a primeira vez, use as funções, ContainerStart, ContainerPause e
  ContainerStop, caso necessite controlar o container.
```

### func \(\*ContainerBuilder\) [ContainerStartAfterBuild](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerStartAfterBuild.go#L45>)

```go
func (e *ContainerBuilder) ContainerStartAfterBuild() (err error)
```

#### ContainerStartAfterBuild

English:

Starts a newly created container\.

```
Output:
  err: standard error object
```

Note:

```
* There are two ways to create a container:
  ContainerBuildAndStartFromImage, initializes the oncontainer and initializes the registry to
  the docker network, so that it works correctly.
  ContainerBuildWithoutStartingItFromImage just creates the container, so the first time it runs
  it must have its network registry initialized so it can work properly.
* After initializing the first time, use the functions, ContainerStart, ContainerPause and
  ContainerStop, in case you need to control the container.
```

Português:

Inicia um container recem criado\.

```
Saída:
  err: Objeto de erro padrão
```

Nota:

```
* Ha duas formas de criar um container:
  ContainerBuildAndStartFromImage, inicializa o oncontainer e inicializa o registro aa rede
  docker, para que o mesmo funcione de forma correta.
  ContainerBuildWithoutStartingItFromImage apenas cria o container, por isto, a primeira vez que
  o mesmo roda, ele deve ter o seu registro de rede inicializado para que possa funcionar de
  forma correta.
* Apos inicializado a primeira vez, use as funções, ContainerStart, ContainerPause e
  ContainerStop, caso necessite controlar o container.
```

### func \(\*ContainerBuilder\) [ContainerStatisticsOneShot](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerStatisticsOneShot.go#L26-L29>)

```go
func (e *ContainerBuilder) ContainerStatisticsOneShot() (stats types.Stats, err error)
```

#### ContainerStatisticsOneShot

English:

Returns the container's memory and system consumption data at the time of the query\.

```
Output:
  stats: Container statistics such as memory, bytes read/written, CPUs, access times, etc.
  err: standard error object
```

Português:

Retorna os dados de consumo de memória e sistema do container no instante da consulta\.

```
Saída:
  stats: Estatísticas do conbtainer, como memória, bytes lidos/escritos, CPUs, tempos de acesso,
    etc.
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ContainerStop](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerStop.go#L43>)

```go
func (e *ContainerBuilder) ContainerStop() (err error)
```

#### ContainerStop

English:

Stop the container

```
Output:
  err: Default error object.
```

Note:

```
* There are two ways to create a container:
  ContainerBuildAndStartFromImage, initializes the oncontainer and initializes the registry to
  the docker network, so that it works correctly.
  ContainerBuildWithoutStartingItFromImage just creates the container, so the first time it runs,
  it must have its network registry initialized, so it can work properly.
* After initializing the first time, use the functions, ContainerStart, ContainerPause and
  ContainerStop, if you need to control the container.
```

Português:

Para o container\.

```
Saída:
  err: Objeto de erro padrão.
```

Nota:

```
* Ha duas formas de criar um container:
  ContainerBuildAndStartFromImage, inicializa o oncontainer e inicializa o registro aa rede
  docker, para que o mesmo funcione de forma correta.
  ContainerBuildWithoutStartingItFromImage apenas cria o container, por isto, a primeira vez que
  o mesmo roda, ele deve ter o seu registro de rede inicializado para que possa funcionar de
  forma correta.
* Apos inicializado a primeira vez, use as funções, ContainerStart, ContainerPause e
  ContainerStop, caso necessite controlar o container.
```

### func \(\*ContainerBuilder\) [ContainerUnpause](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcContainerUnpause.go#L22>)

```go
func (e *ContainerBuilder) ContainerUnpause() (err error)
```

#### ContainerUnpause

English:

Remove the pause from the previously paused container with the container\.Pause\(\) command

```
Output:
  err: Standard error object.
```

Português:

Remove a pausa do container previamente pausado com o comando container\.Pause\(\)

```
Saída:
  err: Objeto de erro padrão.
```

### func \(\*ContainerBuilder\) [EnableChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcEnableChaosScene.go#L50>)

```go
func (e *ContainerBuilder) EnableChaosScene(enable bool)
```

#### EnableChaosScene

English:

Enables chaos functionality in containers\.

```
Input:
  enable: enable chaos manager
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Habilita a funcionalidade de caos nos containers\.

```
Entrada:
  enable: habilita o gerenciador de caos
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [FindCurrentIPV4Address](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcFindCurrentIPV4Address.go#L24>)

```go
func (e *ContainerBuilder) FindCurrentIPV4Address() (IP string, err error)
```

#### FindCurrentIPV4Address

English:

Inspects the docker's network and returns the current IP of the container

```
Output:
  IP: container IP address IPV4
  err: standard error object
```

Português:

Inspeciona a rede do docker e devolve o IP atual do container

```
Saída:
  IP: endereço IP do container IPV4
  err: objeto de erro padrão
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetImageName("nats:latest")

	container.SetContainerName("container_delete_nats_after_test")

	container.SetWaitStringWithTimeout("Listening for route connections on 0.0.0.0:6222", 10*time.Second)

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = container.ImagePull()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var IP string
	IP, err = container.FindCurrentIPV4Address()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	if IP != container.GetIPV4Address() {
		err = errors.New("all ip address must be a samer IP")
		util.TraceToLog()
		panic(err)
	}

	SaGarbageCollector()

	err = container.ImageRemoveByName("nats:latest")
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

}
```

#### Output

```

```

</p>
</details>

### func \(\*ContainerBuilder\) [FindTextInsideContainerLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcFindTextInsideContainerLog.go#L31>)

```go
func (e *ContainerBuilder) FindTextInsideContainerLog(value string) (contains bool, err error)
```

#### FindTextInsideContainerLog

English:

Search for text in standard container output\.

```
Input:
  value: searched text

Output:
  contains: true if text was found
  err: standard error object
```

Português:

Procurar por um texto na saída padrão do container\.

```
Entrada:
  value: texto procurado

Saída:
  contains: true se o texto foi encontrado
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [GetBuildFolderPath](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetBuildFolderPath.go#L19>)

```go
func (e *ContainerBuilder) GetBuildFolderPath() (buildPath string)
```

#### GetBuildFolderPath

English:

Returns the project path used to mount the image

```
Output:
  buildPath: string with the project path
```

Português:

Retorna o caminho do projeto usado para montar a imagem

```
Saída:
  buildPath: string com o caminho do projeto
```

### func \(\*ContainerBuilder\) [GetChannelEvent](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetChannelEvent.go#L32>)

```go
func (e *ContainerBuilder) GetChannelEvent() (channel *chan ContainerPullStatusSendToChannel)
```

GetChannelEvent \(english\):

GetChannelEvent \(português\): Canal disparado durante o processo de image build ou container build e retorna informações como andamento do download da imagem\, processo de extração da mesma entre outras informações Waiting: Esperando o processo ser iniciado pelo docker Downloading: Estado do download da imagem\, caso a mesma não exista na máquina host Count: Quantidade de blocos a serem baixados Current: Total de bytes baixados até o momento Total: Total de bytes a serem baixados Percent: Percentual atual do processo com uma casa decimal de precisão DownloadComplete: todo: fazer Extracting: Estado da extração da imagem baixada Count: Quantidade de blocos a serem extraídos Current: Total de bytes extraídos até o momento Total: Total de bytes a serem extraídos Percent: Percentual atual do processo com uma casa decimal de precisão PullComplete: todo: fazer ImageName: nome da imagem baixada ImageID: ID da imagem baixada\. \(Cuidado: este valor só é definido ao final do processo\) ContainerID: ID do container criado\. \(Cuidado: este valor só é definido ao final do processo\) Closed: todo: fazer Stream: saída padrão do container durante o processo de build SuccessfullyBuildContainer: sucesso ao fim do processo de build do container SuccessfullyBuildImage: sucesso ao fim do processo de build da imagem IdAuxiliaryImages: usado pelo coletor de lixo para apagar as imagens axiliares ao fim do processo de build

### func \(\*ContainerBuilder\) [GetChannelOnContainerInspect](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetChannelOnContainerInspect.go#L12>)

```go
func (e *ContainerBuilder) GetChannelOnContainerInspect() (channel *chan bool)
```

#### GetChannelOnContainerInspect

English:

Channel triggered at each ticker cycle defined in SetInspectInterval\(\)

Português:

Canal disparado a cada ciclo do ticker definido em SetInspectInterval\(\)

### func \(\*ContainerBuilder\) [GetChannelOnContainerReady](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetChannelOnContainerReady.go#L23>)

```go
func (e *ContainerBuilder) GetChannelOnContainerReady() (channel *chan bool)
```

#### GetChannelOnContainerReady

English:

Channel fired when the container is ready for use

Note:

```
* This channel expects the container to signal that it is ready, but it does not take into
  account whether the application contained in the container is ready. For this reason, it is
  recommended to use SetWaitString()
```

Português:

```
Canal disparado quando o container está pronto para uso
```

Nota:

```
* Este canal espera o container sinalizar que está pronto, mas, ele não considera se a aplicação
  contida no container está pronta. Por isto, é recomendado o uso de SetWaitString()
```

### func \(\*ContainerBuilder\) [GetChaosEvent](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetChaosEvent.go#L32>)

```go
func (e *ContainerBuilder) GetChaosEvent() (eventChannel chan Event)
```

#### GetChaosEvent

English:

Returns channel of Chaos Winds\.

```
Output:
  eventChannel: chaos event channel
    ContainerName: container name
```

```
Message: Error message or event suffered by container, as aborted by system.
     Error: True if there is an error
     Done: Trick for when the chaos roll was successful. See the AddSuccessMatchFlag() function
     Fail: True for when the chaos test failed. See the functions AddFailMatchFlag(),
           AddFailMatchFlagToFileLog(), AddFilterToFail()
     Metadata: Data defined by the SetMetadata() function
```

Português:

Retorna o canal de ventos de caos\.

```
Saída:
  eventChannel: canal de eventos de caos
    ContainerName: Nome do container
```

```
Message: Mensagem de erro ou evento sofrido pelo container, como abortado pelo sistema.
     Error: True se houver erro
     Done: True para quando o teste de caos foi bem sucessido. Veja a função AddSuccessMatchFlag()
     Fail: True para quando o teste de caos falhou. Veja as funções AddFailMatchFlag(),
           AddFailMatchFlagToFileLog(), AddFilterToFail()
     Metadata: Dados definidos pela função SetMetadata()
```

### func \(\*ContainerBuilder\) [GetContainerID](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetContainerID.go#L18>)

```go
func (e *ContainerBuilder) GetContainerID() (ID string)
```

#### GetContainerID

English:

Returns the ID of the created container

```
Output:
  ID: ID of the container
```

Português:

Retorna o ID do container criado

```
Saída:
  ID: ID do container
```

### func \(\*ContainerBuilder\) [GetContainerInfo](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetContainerInfo.go#L24>)

```go
func (e *ContainerBuilder) GetContainerInfo() (info types.Info, err error)
```

#### GetContainerInfo

English:

Returns a series of information about the container\.

```
Output:
  info: Container information.
  err: Standard error object.
```

Português:

Retorna uma séries de informações sobre o container\.

```
Saída:
  info: Informações sobre o container.
  err: Objeto padrão de erro.
```

### func \(ContainerBuilder\) [GetContainerIsStarted](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetContainerIsStarted.go#L18>)

```go
func (e ContainerBuilder) GetContainerIsStarted() (started bool)
```

#### GetContainerIsStarted

English:

Returns if the container was initialized after it was generated\.

```
Output:
  started: true for container initialized after generated
```

Português:

Retorna se o container foi inicializado depois de gerado\.

```
Saída:
  started: true para container inicializado depois de gerado
```

### func \(\*ContainerBuilder\) [GetContainerLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetContainerLog.go#L24>)

```go
func (e *ContainerBuilder) GetContainerLog() (log []byte, err error)
```

#### GetContainerLog

English:

Returns the current standard output of the container\.

```
Output:
  log: Texts contained in the container's standard output
  err: Standard error object
```

Português:

Retorna a saída padrão atual do container\.

```
Saída:
  log: Textos contidos na saída padrão do container
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [GetContainerName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetContainerName.go#L18>)

```go
func (e *ContainerBuilder) GetContainerName() (containerName string)
```

#### GetContainerName

English:

Returns container name

```
Output:
  containerName: Container name
```

Português:

Retorna o nome do container

```
Saída:
  containerName: Nome do container
```

### func \(\*ContainerBuilder\) [GetFailFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetFailFlag.go#L21>)

```go
func (e *ContainerBuilder) GetFailFlag() (fail bool)
```

#### GetFailFlag

English:

Returns the fail indicator flag set by the AddFailMatchFlag\(\)\, AddFailMatchFlagToFileLog\(\)\, AddFilterToFail\(\) functions\,

```
Output:
  fail: true if test failed
```

Português:

Retorna o flag indicador de falha definido pelas funções AddFailMatchFlag\(\)\, AddFailMatchFlagToFileLog\(\)\, AddFilterToFail\(\)

```
Saída:
  fail: true se o teste tiver falhado
```

### func \(\*ContainerBuilder\) [GetGitCloneToBuild](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetGitCloneToBuild.go#L20>)

```go
func (e *ContainerBuilder) GetGitCloneToBuild() (url string)
```

#### GetGitCloneToBuild

English:

Returns the URL of the repository to clone for image transformation

Note:

```
* See the SetGitCloneToBuild() function for more details.
```

Português:

Retorna a URL do repositório a ser clonado para a transformação em imagem

Nota:

```
* Veja a função SetGitCloneToBuild() para mais detalhes.
```

### func \(\*ContainerBuilder\) [GetIPV4Address](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetIpAddress.go#L22>)

```go
func (e *ContainerBuilder) GetIPV4Address() (IP string)
```

#### GetIPV4Address

English:

Returns the last IP read from the container

Note:

```
* If the container is disconnected or connected to another network after creation, this
  information may change
```

Português:

Retorna o último IP lido do container

Nota:

```
* Caso o container seja desconectado ou conectado a outra rede após a criação, esta informação
  pode mudar
```

### func \(\*ContainerBuilder\) [GetImageArchitecture](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageArchitecture.go#L18>)

```go
func (e *ContainerBuilder) GetImageArchitecture() (architecture string)
```

#### GetImageArchitecture

English:

Returns the architecture of the image\.

```
Output:
  architecture: image architecture
```

Português:

Retorna a arquitetura da imagem\.

```
Saída:
  architecture: arquitetura da imagem
```

### func \(\*ContainerBuilder\) [GetImageAuthor](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageAuthor.go#L18>)

```go
func (e *ContainerBuilder) GetImageAuthor() (author string)
```

#### GetImageAuthor

English:

Returns the author of the image\.

```
Output:
  author: image author
```

Português:

Retorna o autor da imagem\.

```
Saída:
  author: autor da imagem
```

### func \(\*ContainerBuilder\) [GetImageCacheName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageCacheName.go#L18>)

```go
func (e *ContainerBuilder) GetImageCacheName() (name string)
```

#### GetImageCacheName

English:

Returns the name of the image cache used to create the image

```
Output:
  name: name of the image cache
```

Português:

Devolve o nome da imagem cache usada para criar a imagem

```
Saída:
  name: nome da imagem cache
```

### func \(\*ContainerBuilder\) [GetImageComment](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageComment.go#L18>)

```go
func (e *ContainerBuilder) GetImageComment() (comment string)
```

#### GetImageComment

English:

Returns the archived comment of the image

```
Output:
  comment: image comment
```

Português:

Retorna o comentário arquivado na imagem

```
Saída:
  comment: comentário da imagem
```

### func \(\*ContainerBuilder\) [GetImageContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageContainer.go#L18>)

```go
func (e *ContainerBuilder) GetImageContainer() (imageName string)
```

#### GetImageContainer

English:

Returns the name of the image used to create the container

```
Output:
  imageName: Name of the image used to create the container
```

Português:

Retorna o nome da imagem usada para criar o container

```
Saída:
  imageName: Nome da imagem usada para criar o container
```

### func \(\*ContainerBuilder\) [GetImageCreatedTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageCreatedTime.go#L20>)

```go
func (e *ContainerBuilder) GetImageCreatedTime() (created time.Time)
```

#### GetImageCreatedTime

English:

Returns the date of creation of the image\.

```
Output:
  created: Time.Time object with the date of creation of the image.
```

Português:

Retorna a data de criação da imagem\.

```
Saída:
  created: Objeto time.Time com a data de criação da imagem.
```

### func \(\*ContainerBuilder\) [GetImageExpirationTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageExpirationTime.go#L22>)

```go
func (e *ContainerBuilder) GetImageExpirationTime() (expiration time.Duration)
```

#### GetImageExpirationTime

Português:

Retorna a data de expiração da imagem\, ou seja\, a data usada como base para impedir que a mesma imagem seja gerada várias vezes em um único teste\.

```
Saída:
  expiration: Objeto time.Duration com a data de validade da imagem
```

English:

Returns the image's expiration date\, that is\, the date used as a basis to prevent the same image from being generated multiple times in a single test\.

```
Output:
  expiration: time.Duration object with the image's expiration date
```

### func \(\*ContainerBuilder\) [GetImageID](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageID.go#L18>)

```go
func (e *ContainerBuilder) GetImageID() (ID string)
```

#### GetImageID

English:

Returns the image ID\.

```
Output:
  ID: image ID
```

Português:

Retorna o ID da imagem\.

```
Saída:
  ID: ID da imagem
```

### func \(\*ContainerBuilder\) [GetImageName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageName.go#L18>)

```go
func (e *ContainerBuilder) GetImageName() (name string)
```

#### GetImageName

English:

Returns the name of the image\.

```
Output:
  name: Name of the image
```

Português:

Retorna o nome da imagem\.

```
Saída:
  name: Nome da imagem
```

### func \(\*ContainerBuilder\) [GetImageOs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageOs.go#L18>)

```go
func (e *ContainerBuilder) GetImageOs() (os string)
```

#### GetImageOs

English:

Returns the operating system used to create the image\.

```
Output:
  os: name of the operating system used to create the image
```

Português:

Retorna o sistema operacional usado para criar a imagem\.

```
Saída:
  os: nome do sistema operacional usado para criar a imagem
```

### func \(\*ContainerBuilder\) [GetImageOsVersion](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageOsVersion.go#L18>)

```go
func (e *ContainerBuilder) GetImageOsVersion() (osVersion string)
```

#### GetImageOsVersion

English:

Returns the operating system version of the image

```
Output:
  osVersion: operating system version of the image
```

Português:

Retorna a versão do sistema operacional da imagem

```
Saída:
  osVersion: versão do sistema operacional da imagem
```

### func \(\*ContainerBuilder\) [GetImageParent](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageParent.go#L16>)

```go
func (e *ContainerBuilder) GetImageParent() (parent string)
```

#### GetImageParent

 Retorna o nome da imagem base

```
Saída:
  parent: nome da imagem base
```

English:

Returns the name of the base image

```
Output:
  parent: name of the base image
```

### func \(\*ContainerBuilder\) [GetImageRepoDigests](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageRepoDigests.go#L25>)

```go
func (e *ContainerBuilder) GetImageRepoDigests() (repoDigests []string)
```

#### GetImageRepoDigests

English:

Get image reports

```
Output:
  repoDigests: image reports
```

Português:

Obtém relatórios simplificados da imagem

```
Saída:
  repoDigests: relatórios da imagem
```

English:

Get image reports

```
Output:
  repoDigests: image reports
```

### func \(\*ContainerBuilder\) [GetImageRepoTags](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageRepoTags.go#L18>)

```go
func (e *ContainerBuilder) GetImageRepoTags() (repoTags []string)
```

#### GetImageRepoTags

English:

Get the list of tags of an image repository\.

```
Output:
  repoTags: list of image repository tags.
```

Português:

Obtém a lista de tags de um repositório de imagens\.

```
Saída:
  repoTags: lista de tags do repositório de imagens.
```

### func \(\*ContainerBuilder\) [GetImageSize](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageSize.go#L18>)

```go
func (e *ContainerBuilder) GetImageSize() (size int64)
```

#### GetImageSize

English:

Returns the image size

```
Output:
  size: image size
```

Português:

Retorna o tamanho da imagem

```
Saída:
  size: tamanho da imagem
```

### func \(\*ContainerBuilder\) [GetImageVariant](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageVariant.go#L3>)

```go
func (e *ContainerBuilder) GetImageVariant() (variant string)
```

### func \(\*ContainerBuilder\) [GetImageVirtualSize](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetImageVirtualSize.go#L18>)

```go
func (e *ContainerBuilder) GetImageVirtualSize() (virtualSize int64)
```

#### GetImageVirtualSize

English:

Returns the virtual size of the image

```
Output:
  virtualSize: virtual size of the image
```

Português:

Retorna o tamanho virtual da imagem

```
Saída:
  virtualSize: tamanho virtual da imagem
```

### func \(\*ContainerBuilder\) [GetInitialized](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetInitialized.go#L18>)

```go
func (e *ContainerBuilder) GetInitialized() (initialized bool)
```

#### GetInitialized

English:

Returns if the container control object was initialized

```
Output:
  initialized: true if the container control object was initialized
```

Português:

Retorna se o objeto de controle do container foi inicializado

```
Saída:
  inicializado: true caso o objeto de controle do container foi inicializado
```

### func \(\*ContainerBuilder\) [GetLastInspect](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetLastInspect.go#L32>)

```go
func (e *ContainerBuilder) GetLastInspect() (inspect ContainerInspect)
```

#### GetLastInspect

English:

Returns the container data based on the last ticker cycle defined in SetInspectInterval\(\)

```
Output:
  inspect: Container information such as name, ID, volumes, network, etc.
```

Note:

```
* The GetChannelOnContainerInspect() function returns the channel triggered by the ticker when
  the information is ready for use
```

Português:

Retorna os dados do container baseado no último ciclo do ticker definido em SetInspectInterval\(\)

```
Output:
  inspect: Informações sobre o container, como nome, ID, volumes, rede, etc.
```

Nota:

```
* A função GetChannelOnContainerInspect() retorna o canal disparado pelo ticker quando as
  informações estão prontas para uso
```

### func \(\*ContainerBuilder\) [GetLastLineOfOccurrenceBySearchTextInsideContainerLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetLastLineOfOccurrenceBySearchTextInsideContainerLog.go#L33>)

```go
func (e *ContainerBuilder) GetLastLineOfOccurrenceBySearchTextInsideContainerLog(value string) (text string, contains bool, err error)
```

#### GetLastLineOfOccurrenceBySearchTextInsideContainerLog

English:

```
Returns the last line of output standard output container that contains the text searched

Input:
  value: text to be searched in the standard output of the container

Output:
  text: string with the last line that contains the text searched
  contains: true if the text was found
  err: default error object
```

Português:

Retorna a ultima linha sa saída padrão do container que contém o texto procurado

```
Input:
  value: texto procurado na saída padrão do container

Saída:
  text: string com a última linha que contém o texto procurado
  contains: true se o texto foi encontrado
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [GetLastLogs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetLastLogs.go#L30>)

```go
func (e *ContainerBuilder) GetLastLogs() (logs string)
```

#### GetLastLogs

English:

Returns the standard container output based on the last ticker cycle defined in SetInspectInterval\(\)

```
Output:
  logs: container standard output text
```

Note:

```
* The GetChannelOnContainerInspect() function returns the channel triggered by the ticker when
  the information is ready for use
```

Português:

Retorna a saída padrão do container baseado no último ciclo do ticker definido em SetInspectInterval\(\)

```
Saída:
  logs: saída padrão do container
```

Nota:

```
* A função GetChannelOnContainerInspect() retorna o canal disparado pelo ticker quando as
  informações estão prontas para uso
```

### func \(\*ContainerBuilder\) [GetMetadata](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetMetadata.go#L18>)

```go
func (e *ContainerBuilder) GetMetadata() (metadata map[string]interface{})
```

#### GetMetadata

English:

Returns a list of user\-defined data

```
Output:
  metadata: map[string]interface{} with user defined data
```

Português:

Retorna uma lista de dados definida oelo usuário

```
Saída:
  metadata: map[string]interface{} com dados definidos oelo usuário
```

### func \(\*ContainerBuilder\) [GetNetworkGatewayIPV4](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetNetworkGatewayIPV4.go#L23>)

```go
func (e *ContainerBuilder) GetNetworkGatewayIPV4() (IPV4 string)
```

#### GetNetworkGatewayIPV4

English:

Returns the gateway from the network to the IPV4 network

```
Output:
  IPV4: IPV4 address of the gateway
```

Português:

Retorna o gateway da rede para rede IPV4

```
Saída:
  IPV4: endereço IPV4 do gateway
```

### func \(\*ContainerBuilder\) [GetNetworkGatewayIPV4ByNetworkName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetNetworkGatewayIPV4ByNetworkName.go#L42>)

```go
func (e *ContainerBuilder) GetNetworkGatewayIPV4ByNetworkName(networkName string) (IPV4 string, err error)
```

#### GetNetworkGatewayIPV4ByNetworkName

English:

If the container is connected to more than one network\, this function returns the gateway of the chosen network\.

```
Input:
  networkName: name of the network

Output:
  IPV4: address of the gateway of the network
  err: standard object error
```

Note:

```
* The default docker network is named "bridge"
```

Português:

Caso o container esteja ligado em mais de uma rede\, esta função devolve o gateway da rede escolhida\.

```
Entrada:
  networkName: nome da rede

Saída:
  IPV4: endereço do gateway da rede
  err: objeto de erro padrão
```

Nota:

```
* A rede padrão do docker tem o nome "bridge"
```

### func \(\*ContainerBuilder\) [GetNetworkIPV4](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetNetworkIPV4.go#L23>)

```go
func (e *ContainerBuilder) GetNetworkIPV4() (IPV4 string)
```

#### GetNetworkIPV4

English:

Return the IPV4 from the docker network

```
Output:
  IPV4: network address IPV4
```

Português:

Retorno o IPV4 da rede do docker

```
Saída:
  IPV4: endereço IPV4 da rede
```

### func \(\*ContainerBuilder\) [GetNetworkIPV4ByNetworkName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetNetworkIPV4ByNetworkName.go#L41>)

```go
func (e *ContainerBuilder) GetNetworkIPV4ByNetworkName(networkName string) (IPV4 string, err error)
```

#### GetNetworkIPV4ByNetworkName

English:

If the container is connected to more than one network\, this function returns the IPV4 of the chosen network\.

```
Input:
  networkName: string with the name of the network

Output:
  IPV4 IPV4 address of the network
  err: standard object error
```

Note:

```
* The default docker network is named "bridge"
```

Português:

Caso o container esteja ligado em mais de uma rede\, esta função devolve o IPV4 da rede escolhida\.

```
Entrada:
  networkName: string com o nome da rede

Saída:
  IPV4: endereço IPV4 da rede
  err: objeto de erro padrão
```

Nota:

```
* A rede padrão do docker tem o nome "bridge"
```

### func \(\*ContainerBuilder\) [GetNetworkInterface](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetNetworkInterface.go#L22>)

```go
func (e *ContainerBuilder) GetNetworkInterface() (network isolatedNetwork.ContainerBuilderNetworkInterface)
```

#### GetNetworkInterface

English:

Returns the object defined for the network control

```
Output:
  network: Object pointer used to configure the network
```

Português:

Retorna o objeto definido para o controle da rede

```
Saída:
  network: Ponteiro do objeto usado para configurar a rede
```

### func \(\*ContainerBuilder\) [GetProblem](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetProblem.go#L18>)

```go
func (e *ContainerBuilder) GetProblem() (problem string)
```

#### GetProblem

English:

Return problem description when possible\.

```
Output:
  problem: descrição do problema
```

Português:

Retorna a descrição do problema\, quando possível

```
Saída:
  problem: descrição do problema
```

### func \(\*ContainerBuilder\) [GetSuccessFlag](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetSuccessFlag.go#L18>)

```go
func (e *ContainerBuilder) GetSuccessFlag() (success bool)
```

#### GetSuccessFlag

English:

Get success flag

```
Output:
  success: success flag
```

Português:

Retorna a bandeira indicadora de sucesso no teste

```
Saída:
  success: bandeira indicadora de sucesso no teste
```

### func \(\*ContainerBuilder\) [ImageBuildFromFolder](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageBuildFromFolder.go#L55>)

```go
func (e *ContainerBuilder) ImageBuildFromFolder() (inspect types.ImageInspect, err error)
```

#### ImageBuildFromFolder

English:

Transforms the contents of the folder defined in SetBuildFolderPath\(\) into a docker image

```
Output:
  inspect: Contém informações sobre a imagem criada
  err: standard object error
```

Note:

```
* The folder must contain a dockerfile file, but since different uses can have different
  dockerfiles, the following order will be given when searching for the file:
  "Dockerfile-iotmaker", "Dockerfile", "dockerfile" in the root folder;
* If not found, a recursive search will be done for "Dockerfile" and "dockerfile";
* If the project is in golang and the main.go file, containing the package main, is contained in
  the root folder, with the go.mod file, the MakeDefaultDockerfileForMe() and
  MakeDefaultDockerfileForMeWithInstallExtras() functions can be used to make a standard
  Dockerfile file automatically.
```

Português:

Transforma o conteúdo da pasta definida em SetBuildFolderPath\(\) em uma imagem docker

```
Saída:
  inspect: contém informações sobre a imagem criada
  err: objeto de erro padrão
```

Nota:

```
* A pasta deve conter um arquivo dockerfile, mas, como diferentes usos podem ter diferentes
  dockerfiles, será dada a seguinte ordem na busca pelo arquivo: "Dockerfile-iotmaker",
  "Dockerfile", "dockerfile" na pasta raiz;
* Se não houver encontrado, será feita uma busca recursiva por "Dockerfile" e "dockerfile";
* Caso o projeto seja em golang e o arquivo main.go, contendo o pacote main, esteja contido na
  pasta raiz, com o arquivo go.mod, podem ser usadas as funções MakeDefaultDockerfileForMe() e
  MakeDefaultDockerfileForMeWithInstallExtras() para ser gerar um arquivo Dockerfile padrão de
  forma automática.
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/helmutkemper/util"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"time"
)

func ImageBuildViewer(ch *chan ContainerPullStatusSendToChannel) {
	go func(ch *chan ContainerPullStatusSendToChannel) {
		for {

			select {
			case event := <-*ch:
				var stream = event.Stream
				stream = strings.ReplaceAll(stream, "\n", "")
				stream = strings.ReplaceAll(stream, "\r", "")
				stream = strings.Trim(stream, " ")

				if stream == "" {
					continue
				}

				log.Printf("%v", stream)

				if event.Closed == true {
					return
				}
			}
		}
	}(ch)
}

func main() {
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}
	// new image name delete:latest
	container.SetImageName("delete:latest")
	// set a folder path to make a new image
	container.SetBuildFolderPath("./test/server")
	container.MakeDefaultDockerfileForMeWithInstallExtras()
	// container name container_delete_server_after_test
	container.SetContainerName("container_delete_server_after_test")
	// set a waits for the text to appear in the standard container output to proceed [optional]
	container.SetWaitStringWithTimeout("starting server at port 3000", 10*time.Second)
	// change and open port 3000 to 3030
	container.AddPortToExpose("3000")
	// replace container folder /static to host folder ./test/static
	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		panic(err)
	}

	// show image build stram on std out
	ImageBuildViewer(container.GetChannelEvent())

	// inicialize container object
	err = container.Init()
	if err != nil {
		panic(err)
	}

	// todo: fazer o teste do inspect

	// builder new image from folder
	_, err = container.ImageBuildFromFolder()
	if err != nil {
		panic(err)
	}

	// build a new container from image
	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		panic(err)
	}

	// Server is ready for use o port 3000

	// read server inside a container on address http://localhost:3000/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3000/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	// print output
	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [ImageBuildFromServer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageBuildFromServer.go#L54>)

```go
func (e *ContainerBuilder) ImageBuildFromServer() (inspect types.ImageInspect, err error)
```

#### ImageBuildFromServer

English:

Build a docker image from a project contained in a git repository\.

```
Output:
  inspect: Contém informações sobre a imagem criada
  err: standard object error
```

Note:

```
* The repository must be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh();
* SetPrivateRepositoryAutoConfig() copies the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig;
* The SetGitConfigFile(), SetSshIdRsaFile() and SetSshKnownHostsFile() functions can be used to
  set git security and configuration files manually.
```

Português: Monta uma imagem docker a partir de um projeto contido em um repositório git\.

```
Saída:
  inspect: contém informações sobre a imagem criada
  err: objeto de erro padrão
```

Nota:

```
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e
  SetGitCloneToBuildWithUserPassworh();
* SetPrivateRepositoryAutoConfig() copia as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig;
* As funções SetGitConfigFile(), SetSshIdRsaFile() e SetSshKnownHostsFile() podem ser usadas para
  definir os arquivos de configurações se segurança do git manualmente.
```

### func \(\*ContainerBuilder\) [ImageFindIdByName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageFindIdByName.go#L31>)

```go
func (e *ContainerBuilder) ImageFindIdByName(name string) (id string, err error)
```

#### ImageFindIdByName

English:

Find an image by name

```
Input:
  name: image name

Output:
  id: image ID
  err: default error object
```

Português:

Encontra uma imagem pelo nome

```
Input:
  name: nome da imagem

Output:
  id: ID da imagem
  err: Objeto padrão de erro
```

### func \(\*ContainerBuilder\) [ImageFindIdByNameContains](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageFindIdByNameContains.go#L31>)

```go
func (e *ContainerBuilder) ImageFindIdByNameContains(containsName string) (list []NameAndId, err error)
```

#### ImageFindIdByNameContains

English:

Find an image by part of the name

```
Input:
  containerName: Part of the name of the image

Output:
  list: List of images found
  err: Default error object
```

Português:

Encontra uma imagem por parte do nome

```
Entrada:
  containerName: Parte do nome da imagem

Saída:
  list: Lista de imagens encontradas
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ImageInspect](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageInspect.go#L29>)

```go
func (e *ContainerBuilder) ImageInspect() (inspect types.ImageInspect, err error)
```

#### ImageInspect

English:

Inspects the image and returns information type\, ID\, name\, size\, creation date\, update date\, author\, tags\, etc

```
Output:
  inspect: Image information
  err: Default error object
```

Português:

Inspeciona a imagem e retorna informações tipo\, ID\, nome\, tamanho\, data de criação\, data de atualização\, autor\, tags\, etc

```
Saída:
 inspect: Informações da imagem
 err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [ImageListExposedPorts](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageListExposedPorts.go#L37>)

```go
func (e *ContainerBuilder) ImageListExposedPorts() (portList []nat.Port, err error)
```

#### ImageListExposedPorts

English:

Lists all the ports defined in the image to be exposed\.

```
Output:
  portList: List of ports exposed on image creation. (Dockerfile expose port)
  err: standard error object
```

Note:

```
* The ports exposed in the creation of the container can be defined by
  SetOpenAllContainersPorts(), AddPortToChange() and AddPortToExpose();
* By default, all doors are closed.
```

Português:

Lista todas as portas definidas na imagem para serem expostas\.

```
Saída:
  portList: Lista de portas expostas na criação da imagem. (Dockerfile expose port)
  err: Objeto de erro padrão
```

Nota:

```
* As portas expostas na criação do container podem ser definidas por SetOpenAllContainersPorts(),
  AddPortToChange() e AddPortToExpose();
* Por padrão, todas as portas ficam fechadas.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var portList []nat.Port

	// create a container
	var container = ContainerBuilder{}

	container.SetImageName("nats:latest")
	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = container.ImagePull()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	portList, err = container.ImageListExposedPorts()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var portsToPrint = make([]string, 0)

	for _, p := range portList {
		portsToPrint = append(portsToPrint, fmt.Sprintf("port: %v/%v\n", p.Port(), p.Proto()))
	}

	sort.Strings(portsToPrint)

	for _, print := range portsToPrint {
		fmt.Printf("%v", print)
	}

	err = container.ImageRemove()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

}
```

#### Output

```
port: 4222/tcp
port: 6222/tcp
port: 8222/tcp
```

</p>
</details>

### func \(\*ContainerBuilder\) [ImageListExposedVolumes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageListExposedVolumes.go#L34>)

```go
func (e *ContainerBuilder) ImageListExposedVolumes() (list []string, err error)
```

#### ImageListExposedVolumes

English:

Lists all volumes defined in the image\.

```
Output:
  list: List of exposed volumes
  err: Standard error object
```

Note:

```
* Use the AddFileOrFolderToLinkBetweenConputerHostAndContainer() function to link folders and
  files between the host computer and the container
```

Português:

Lista todos os volumes definidos na imagem\.

```
Saída:
```

list: Lista de volumes expostos err: Objeto de erro padrão

Nota:

```
* Use a função AddFileOrFolderToLinkBetweenConputerHostAndContainer() para vincular pastas e
  arquivos entre o computador hospedeiro e o container
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var volumes []string

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetImageName("delete:latest")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")
	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	volumes, err = container.ImageListExposedVolumes()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	fmt.Printf("%v", volumes[0])

	SaGarbageCollector()

}
```

#### Output

```
/static
```

</p>
</details>

### func \(\*ContainerBuilder\) [ImagePull](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImagePull.go#L25>)

```go
func (e *ContainerBuilder) ImagePull() (err error)
```

#### ImagePull

English:

Downloads the image to be mounted\. \(equivalent to the docker pull image command\)

```
Output:
  err: standart error object
```

Português:

Baixa a imagem a ser montada\. \(equivale ao comando docker pull image\)

```
Saída:
  err: objeto de erro padrão
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	// create a network [optional]
	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	// create a container
	var container = ContainerBuilder{}

	container.SetNetworkDocker(&netDocker)

	container.SetImageName("nats:latest")

	container.SetContainerName("container_delete_nats_after_test")

	container.SetWaitStringWithTimeout("Listening for route connections on 0.0.0.0:6222", 10*time.Second)

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = container.ImagePull()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	SaGarbageCollector()

	err = container.ImageRemoveByName("nats:latest")
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

}
```

#### Output

```

```

</p>
</details>

### func \(\*ContainerBuilder\) [ImageRemove](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageRemove.go#L30>)

```go
func (e *ContainerBuilder) ImageRemove() (err error)
```

#### ImageRemove

English:

Remove the image if there are no containers using the image

```
Output:
  err: Standard error object
```

Note:

```
* Remove all containers before use, including stopped containers
```

Português:

Remove a imagem se não houver containers usando a imagem

```
Saída:
  err: Objeto de erro padrão
```

Nota:

```
* Remova todos os containers antes do uso, inclusive os containers parados
```

### func \(\*ContainerBuilder\) [ImageRemoveByName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageRemoveByName.go#L36>)

```go
func (e *ContainerBuilder) ImageRemoveByName(name string) (err error)
```

#### ImageRemoveByName

English:

Remove the image if there are no containers using the image

```
Input:
  name: full image name

Output:
  err: standard error object
```

Note:

```
* Remove all containers before use, including stopped containers
```

Português:

Remove a imagem se não houver containers usando a imagem

```
Entrada:
  name: nome completo da imagem

Saída:
  err: objeto de erro padrão
```

Nota:

```
* Remova todos os containers antes do uso, inclusive os containers parados
```

### func \(\*ContainerBuilder\) [Init](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcInit.go#L34>)

```go
func (e *ContainerBuilder) Init() (err error)
```

#### Init

English:

Initializes the object\.

```
Output:
  err: Standard error object
```

Note:

```
* Should be called only after all settings have been configured
```

Português:

Inicializa o objeto\.

```
Saída:
  err: Objeto de erro padrão
```

Nota:

```
* Deve ser chamado apenas depois de toas as configurações serem definidas
```

### func \(\*ContainerBuilder\) [MakeDefaultDockerfileForMe](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcMakeDefaultDockerfileForMe.go#L61>)

```go
func (e *ContainerBuilder) MakeDefaultDockerfileForMe()
```

#### MakeDefaultDockerfileForMe

Similar:

```
MakeDefaultDockerfileForMe(), MakeDefaultDockerfileForMeWithInstallExtras()
```

English:

Automatically mount the Dockerfile\-iotmaker inside the target folder\.

Caution:

```
* The Dockerfile-iotmaker may be overwritten
```

Rules:

```
* For Golang projects, the go.mod file is mandatory;
* The main.go file containing the main package must be at the root folder.
```

Note:

```
* If there are ports exposed in the configurations, they will be defined automatically and the
  same goes for volumes, where files shared between the host and the container will expose the
  folder containing the file inside the container as volume;
* If you need a dockerfile made for another programming language, see the DockerfileAuto
  interface and the SetDockerfileBuilder() function;
* If the image cache is enabled and image cahe is not found, the
  MakeDefaultDockerfileForMeWithInstallExtras() function will be used. It will download git,
  open-ssh and other tools necessary for the first part of the build in two steps;
* The tools downloaded in the first step of the build and the ssh and git credentials will be
  discarded, only the binary generated by Golang will be transferred to the second image.
```

Português:

Monta o arquivo Dockerfile\-iotmaker dentro da pasta alvo de forma automática\.

Cuidado:

```
* O arquivo Dockerfile-iotmaker pode ser sobrescrito.
```

Regras:

```
* Para projetos Golang, o arquivo go.mod é obrigatório;
* O arquivo main.go contendo o package main deve está na raiz do diretório.
```

Nota:

```
* Caso haja portas expostas ou volumes nas configurações, as mesmas serão definidas
  automaticamente, o mesmo serve para arquivos compartilhados entre o host e o container;
* Caso necessite de um dockerfile feito para outra linguagem de programação, veja a interface
  DockerfileAuto e a função SetDockerfileBuilder();
* Caso a imagem cache esteja habilitada e não seja encontrada, será usada a função
  MakeDefaultDockerfileForMeWithInstallExtras(), que baixará git, open-ssh e outras ferramentas
  necessárias para a primeira parte do build em duas etapas;
* As ferramentas baixadas na primeira etapa do build e as credenciais ssh e git serão descartadas
  e apenas o binário gerado pelo Golang será transferido para a segunda imagem.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [MakeDefaultDockerfileForMeWithInstallExtras](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcMakeDefaultDockerfileForMeWithInstallExtras.go#L59>)

```go
func (e *ContainerBuilder) MakeDefaultDockerfileForMeWithInstallExtras()
```

#### MakeDefaultDockerfileForMeWithInstallExtras

Similar:

```
MakeDefaultDockerfileForMe(), MakeDefaultDockerfileForMeWithInstallExtras()
```

English:

Automatically mount the Dockerfile\-iotmaker inside the target folder\.

Caution:

```
* The Dockerfile-iotmaker may be overwritten
```

Rules:

```
* For Golang projects, the go.mod file is mandatory;
* The main.go file containing the main package must be at the root folder.
```

Note:

```
* If there are ports exposed in the configurations, they will be defined automatically and the
  same goes for volumes, where files shared between the host and the container will expose the
  folder containing the file inside the container as volume;
* If you need a dockerfile made for another programming language, see the DockerfileAuto
  interface and the SetDockerfileBuilder() function;
* If the image cache is enabled and image cahe is not found, the
  MakeDefaultDockerfileForMeWithInstallExtras() function will be used. It will download git,
  open-ssh and other tools necessary for the first part of the build in two steps;
* The tools downloaded in the first step of the build and the ssh and git credentials will be
  discarded, only the binary generated by Golang will be transferred to the second image.
```

Português:

Monta o arquivo Dockerfile\-iotmaker dentro da pasta alvo de forma automática\.

Cuidado:

```
* O arquivo Dockerfile-iotmaker pode ser sobrescrito.
```

Regras:

```
* Para projetos Golang, o arquivo go.mod é obrigatório;
* O arquivo main.go contendo o package main deve está na raiz do diretório.
```

Nota:

```
* Caso haja portas expostas ou volumes nas configurações, as mesmas serão definidas
  automaticamente, o mesmo serve para arquivos compartilhados entre o host e o container;
* Caso necessite de um dockerfile feito para outra linguagem de programação, veja a interface
  DockerfileAuto e a função SetDockerfileBuilder();
* Caso a imagem cache esteja habilitada e não seja encontrada, será usada a função
  MakeDefaultDockerfileForMeWithInstallExtras(), que baixará git, open-ssh e outras ferramentas
  necessárias para a primeira parte do build em duas etapas;
* As ferramentas baixadas na primeira etapa do build e as credenciais ssh e git serão descartadas
  e apenas o binário gerado pelo Golang será transferido para a segunda imagem.
```

### func \(\*ContainerBuilder\) [NetworkChangeIp](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcNetworkChangeIp.go#L23>)

```go
func (e *ContainerBuilder) NetworkChangeIp() (err error)
```

#### NetworkChangeIp

English:

Change the IP address of the container\, to the next IP in the docker network manager list

```
Output:
  err: Default object error from golang
```

Português:

Troca o endereço IP do container\, para o próximo IP da lista do gerenciador de rede docker

```
Saída:
  err: Objeto padrão de erro golang
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	SaGarbageCollector()

	var netDocker = &dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		panic(err)
	}

	err = netDocker.NetworkCreate("delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		panic(err)
	}

	var container = ContainerBuilder{}

	container.SetNetworkDocker(netDocker)

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/doNothing")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetWaitStringWithTimeout("done!", 15*time.Second)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	var containerInspect ContainerInspect
	containerInspect, err = container.ContainerInspect()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("IP: %v\n", containerInspect.Network.Networks["delete_after_test"].IPAddress)

	err = container.ContainerStop()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.NetworkChangeIp()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.ContainerStart()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	containerInspect, err = container.ContainerInspect()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("IP: %v\n", containerInspect.Network.Networks["delete_after_test"].IPAddress)

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.31 MB
image os: linux
IP: 10.0.0.2
IP: 10.0.0.3
```

</p>
</details>

### func \(\*ContainerBuilder\) [RemoveAllByNameContains](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcRemoveAllByNameContains.go#L30>)

```go
func (e *ContainerBuilder) RemoveAllByNameContains(value string) (err error)
```

#### RemoveAllByNameContains

English:

Searches for networks\, volumes\, containers and images that contain the term defined in "value" in the name\, and tries to remove them from docker

```
Input:
  value: part of the wanted name

Output:
  err: Standard error object
```

Português:

Procura por redes\, volumes\, container e imagens que contenham o termo definido em "value" no nome\, e tenta remover os mesmos do docker

```
Entrada:
  value: parte do nome desejado

Saída:
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [SetBuildFolderPath](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetBuildFolderPath.go#L38>)

```go
func (e *ContainerBuilder) SetBuildFolderPath(value string)
```

#### SetBuildFolderPath

English:

Defines the path of the folder to be transformed into an image

```
Input:
  value: path of the folder to be transformed into an image
```

Note:

```
* The folder must contain a dockerfile file, but since different uses can have different
  dockerfiles, the following order will be given when searching for the file:
  "Dockerfile-iotmaker", "Dockerfile", "dockerfile" in the root folder;
* If not found, a recursive search will be done for "Dockerfile" and "dockerfile";
* If the project is in golang and the main.go file, containing the package main, is contained in
  the root folder, with the go.mod file, the MakeDefaultDockerfileForMe() function can be used to
  use a standard Dockerfile file
```

Português:

Define o caminho da pasta a ser transformada em imagem

```
Entrada:
  value: caminho da pasta a ser transformada em imagem
```

Nota:

```
* A pasta deve conter um arquivo dockerfile, mas, como diferentes usos podem ter diferentes
  dockerfiles, será dada a seguinte ordem na busca pelo arquivo: "Dockerfile-iotmaker",
  "Dockerfile", "dockerfile" na pasta raiz.
* Se não houver encontrado, será feita uma busca recursiva por "Dockerfile" e "dockerfile"
* Caso o projeto seja em golang e o arquivo main.go, contendo o pacote main, esteja contido na
  pasta raiz, com o arquivo go.mod, pode ser usada a função MakeDefaultDockerfileForMe() para ser
  usado um arquivo Dockerfile padrão
```

### func \(\*ContainerBuilder\) [SetCacheEnable](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCacheEnable.go#L124>)

```go
func (e *ContainerBuilder) SetCacheEnable(value bool)
```

#### SetCacheEnable

English:

When true\, looks for an image named \`chache:latest\` as a basis for creating new images when the MakeDefaultDockerfileForMe\(\) function is used\.

```
Input:
  value: true to enable the use of image named cache:latest as the basis for new images if it
    exists
```

Note:

```
* This function is extremely useful when developing new applications, reducing the time to create
  images with each new test.
```

Example:

```
Folder: cache
File: Dockerfile-iotmaker
Need: Image with nats.io drive installed
Content:

FROM golang:1.16-alpine as builder
RUN mkdir -p /root/.ssh/ && \
    apk update && \
    apk add --no-cache build-base && \
    apk add --no-cache alpine-sdk && \
    rm -rf /var/cache/apk/*
ARG CGO_ENABLED=0

RUN go get -u github.com/nats-io/nats.go

Code Golang:

var imageCacheName = "cache:latest"
var imageId string
var container = &dockerBuilder.ContainerBuilder{}

imageId, err = container.ImageFindIdByName(imageCacheName)
if err != nil && err.Error() != "image name not found" {
  return
}

if imageId != "" {
  return
}

container.SetImageName(imageCacheName)
container.SetPrintBuildOnStrOut()
container.SetContainerName(imageCacheName)
container.SetBuildFolderPath("./cache")
err = container.Init()
if err != nil {
  return
}

err = container.ImageBuildFromFolder()
if err != nil {
  return
}
```

Português:

Quando true\, procura por uma imagem de nome \`chache:latest\` como base para a criação de novas imagens quando a função MakeDefaultDockerfileForMe\(\) é usada\.

```
Entrada:
  value: true para habilitar o uso da imagem de nome cache:latest como base para novas imagens,
    caso a mesma exista
```

Nota:

```
* Esta função é extremamente útil no desenvolvimento de novas aplicações, reduzindo o tempo de
  criação de imagens a cada novo teste.
```

Exemplo:

```
Pasta: cache
Arquivo: Dockerfile-iotmaker
Necessidade: Imagem com o drive do nats.io instalada
Conteúdo:

FROM golang:1.16-alpine as builder
RUN mkdir -p /root/.ssh/ && \
    apk update && \
    apk add --no-cache build-base && \
    apk add --no-cache alpine-sdk && \
    rm -rf /var/cache/apk/*
ARG CGO_ENABLED=0

RUN go get -u github.com/nats-io/nats.go

Código Golang:

var imageCacheName = "cache:latest"
var imageId string
var container = &dockerBuilder.ContainerBuilder{}

imageId, err = container.ImageFindIdByName(imageCacheName)
if err != nil && err.Error() != "image name not found" {
  return
}

if imageId != "" {
  return
}

container.SetImageName(imageCacheName)
container.SetPrintBuildOnStrOut()
container.SetContainerName(imageCacheName)
container.SetBuildFolderPath("./cache")
err = container.Init()
if err != nil {
  return
}

err = container.ImageBuildFromFolder()
if err != nil {
  return
}
```

### func \(\*ContainerBuilder\) [SetContainerAttachStandardStreamsToTty](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerAttachStandardStreamsToTty.go#L18>)

```go
func (e *ContainerBuilder) SetContainerAttachStandardStreamsToTty(value bool)
```

#### SetContainerAttachStandardStreamsToTty

English:

Attach standard streams to tty

```
Entrada:
  value: true to attach standard streams to tty
```

Português:

Anexa a saída padrão do tty

```
Entrada:
  value: true para anexar a saída padrão do tty
```

### func \(\*ContainerBuilder\) [SetContainerCommandToRunWhenStartingTheContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerCommandToRunWhenStartingTheContainer.go#L18>)

```go
func (e *ContainerBuilder) SetContainerCommandToRunWhenStartingTheContainer(values []string)
```

#### SetContainerCommandToRunWhenStartingTheContainer

English:

Command to run when stating the container \(style Dockerfile CMD\)

```
Input:
  values: List of commands. Eg.: []string{"ls", "-l"}
```

Português:

Comando a ser executado quando o container inicia \(estilo Dockerfile CMD\)

```
Entrada:
  values: Lista de comandos. Ex.: []string{"ls", "-l"}
```

### func \(\*ContainerBuilder\) [SetContainerEntrypointToRunWhenStartingTheContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerEntrypointToRunWhenStartingTheContainer.go#L18>)

```go
func (e *ContainerBuilder) SetContainerEntrypointToRunWhenStartingTheContainer(values []string)
```

#### SetContainerEntrypointToRunWhenStartingTheContainer

English:

Entrypoint to run when stating the container

```
Input:
  values: entrypoint. Eg.: docker run --entrypoint [new_command] [docker_image] [optional:value]
```

Português:

Entrypoint a ser executado quando o container iniciar

```
Entrada:
  values: entrypoint. Ex.: docker run --entrypoint [new_command] [docker_image] [optional:value]
```

### func \(\*ContainerBuilder\) [SetContainerHealthcheck](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerHealthcheck.go#L54>)

```go
func (e *ContainerBuilder) SetContainerHealthcheck(value *HealthConfig)
```

#### SetContainerHealthcheck

English:

Holds configuration settings for the HEALTHCHECK feature\.

```
Input:
  value: Ponteiro para HealthConfig
    Test: Test is the test to perform to check that the container is healthy.
          An empty slice means to inherit the default.
          The options are:
            {}: inherit healthcheck
            {"NONE"}: disable healthcheck
            {"CMD", args...}: exec arguments directly
            {"CMD-SHELL", command}: run command with system's default shell

    Interval: Interval is the time to wait between checks (Zero means inherit).

    Timeout: Timeout is the time to wait before considering the check to have hung (Zero means
             inherit).

    StartPeriod: The start period for the container to initialize before the retries starts to
                 count down (Zero means inherit).

    Retries: Retries is the number of consecutive failures needed to consider a container as
             unhealthy (Zero means inherit).
```

Português:

Adiciona definições de configuração para o recurso HEALTHCHECK\.

```
Entrada:
  value: Ponteiro para HealthConfig
    Test: Test é o teste a ser executado para testar a saúde do container se não for definido,
          herda o teste padrão
          As opções são:
            {}: herda o teste padrão
            {"NONE"}: desabilita o healthcheck
            {"CMD", args...}: executa os argumentos diretamente
            {"CMD-SHELL", command} : executa o comando com shell padrão do sistema

    Interval: intervalo entre testes (zero herda o valor padrão).

    Timeout: intervalo de espera antes de considerar o teste com problemas (zero herda o valor
             padrão).

    StartPeriod: tempo de espera pela incialização do container antes dos testes começarem
                 (zero herda o valor padrão).

    Retries: número de testes consecutivos antes de considerar o teste com problemas (zero
    herda o valor padrão).
```

### func \(\*ContainerBuilder\) [SetContainerName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerName.go#L18>)

```go
func (e *ContainerBuilder) SetContainerName(value string)
```

#### SetContainerName

English:

Defines the name of the container

```
Input:
  value: container name
```

Português:

Define o nome do container

```
Entrada:
  value: nome do container
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// English: read server inside a container on address http://localhost:3030/
	//
	// Português: lê o servidor dentro do container na porta http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetContainerRestartPolicyAlways](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerRestartPolicyAlways.go#L18>)

```go
func (e *ContainerBuilder) SetContainerRestartPolicyAlways()
```

#### SetContainerRestartPolicyAlways

English:

Always restart the container if it stops\. If it is manually stopped\, it is restarted only when Docker daemon restarts or the container itself is manually restarted\.

Português:

Define a política de reinício do container como sempre reinicia o container quando ele para\, mesmo quando ele é parado manualmente\.

### func \(\*ContainerBuilder\) [SetContainerRestartPolicyNo](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerRestartPolicyNo.go#L16>)

```go
func (e *ContainerBuilder) SetContainerRestartPolicyNo()
```

#### SetContainerRestartPolicyNo

English:

Do not automatically restart the container\. \(the default\)

Português:

Define a política de reinício do container como não reiniciar o container \(padrão\)\.

### func \(\*ContainerBuilder\) [SetContainerRestartPolicyOnFailure](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerRestartPolicyOnFailure.go#L17>)

```go
func (e *ContainerBuilder) SetContainerRestartPolicyOnFailure()
```

#### SetContainerRestartPolicyOnFailure

English:

Restart the container if it exits due to an error\, which manifests as a non\-zero exit code

Português:

Define a política de reinício do container como reinicia o container se houver um erro \(com o manifesto informando um código de erro diferente de zero\)\.

### func \(\*ContainerBuilder\) [SetContainerRestartPolicyUnlessStopped](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerRestartPolicyUnlessStopped.go#L18>)

```go
func (e *ContainerBuilder) SetContainerRestartPolicyUnlessStopped()
```

#### SetContainerRestartPolicyUnlessStopped

English:

Similar to always\, except that when the container is stopped \(manually or otherwise\)\, it is not restarted even after Docker daemon restarts\.

Português:

Define a política de reinício do container como sempre reinicia o container\, caso ele não tenha sido parado manualmente\.

### func \(\*ContainerBuilder\) [SetContainerShellForShellFormOfRunCmdEntrypoint](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetContainerShellForShellFormOfRunCmdEntrypoint.go#L12>)

```go
func (e *ContainerBuilder) SetContainerShellForShellFormOfRunCmdEntrypoint(values []string)
```

#### SetContainerShellForShellFormOfRunCmdEntrypoint

English:

shell for shell\-form of run cmd entrypoint

Português:

define o terminal \(shell\) para executar o entrypoint

### func \(\*ContainerBuilder\) [SetCsvFileReader](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCsvFileReader.go#L35>)

```go
func (e *ContainerBuilder) SetCsvFileReader(value bool)
```

#### SetCsvFileReader

English:

Prints in the header of the file the name of the constant responsible for printing the column in the log\.

```
Input:
  value: true to print the name of the constant responsible for printing the column in the log
    in the header of the file.
```

Nota:

```
* The constants printed in the first line of the file are used in the SetCsvFileRowsToPrint()
  function. Simply separate the constants by pipe (|).
  Example: container.SetCsvFileRowsToPrint( KLogColumnReadingTime
           | KLogColumnCurrentNumberOfOidsInTheCGroup | ... )
```

Português:

Imprime no cabeçalho do arquivo o nome da constante responsável por imprimir a coluna no log\.

```
Entrada:
  value: true para imprimir no cabeçalho do arquivo o nome da constante responsável por imprimir
    a coluna no log.
```

Nota:

```
* As constantes impressas na primeira linha do arquivo são usadas na função
  SetCsvFileRowsToPrint(). Basta separar as contantes por pipe (|).
  Exemplo: container.SetCsvFileRowsToPrint( KLogColumnReadingTime
           | KLogColumnCurrentNumberOfOidsInTheCGroup | ... )
```

### func \(\*ContainerBuilder\) [SetCsvFileRowSeparator](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCsvFileRowSeparator.go#L32>)

```go
func (e *ContainerBuilder) SetCsvFileRowSeparator(value string)
```

#### SetCsvFileRowSeparator

English:

Defines the log file line separator\, in CSV format\, containing container usage statistics\.

```
Input:
  value: separador de linha do arquivo CSV (valor padrão: "\n")
```

Nota:

```
* Esta função é usada em conjunto com as funções SetCsvLogPath(), StartMonitor(), StopMonitor(),
  SetCsvFileRowSeparator(), SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog() e
  AddFilterToCvsLogWithReplace();
* As colunas de dados preenchidos varia de acordo com o sistema operacional.
```

Português:

Define o separador de linha do arquivo de log\, em formato CSV\, contendo estatísticas de uso do container\.

```
Entrada:
  value: separador de linha do arquivo CSV (valor padrão: "\n")
```

Nota:

```
* Esta função é usada em conjunto com as funções SetCsvLogPath(), StartMonitor(), StopMonitor(),
  SetCsvFileRowSeparator(), SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog() e
  AddFilterToCvsLogWithReplace();
* As colunas de dados preenchidos varia de acordo com o sistema operacional.
```

### func \(\*ContainerBuilder\) [SetCsvFileRowsToPrint](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCsvFileRowsToPrint.go#L37>)

```go
func (e *ContainerBuilder) SetCsvFileRowsToPrint(value int64)
```

#### SetCsvFileRowsToPrint

English:

Defines which columns will be printed in the log\, in the form of a CSV file\, with container performance information\, memory consumption indicators and access times\.

```
Input:
  value: List of columns printed in CSV file. Eg.: KLogColumnMacOs, KLogColumnWindows,
    KLogColumnAll or any combination of KLogColumn... concatenated with pipe.
    Eg.: KLogColumnReadingTime | KLogColumnCurrentNumberOfOidsInTheCGroup | ...
```

Nota:

```
* To see the complete list of columns, use SetCsvFileRowsToPrint(KLogColumnAll) and
  SetCsvFileReader(true).
  This will print the constant names on top of each column in the log.
```

Português:

Define quais colunas vão ser impressas no log\, na forma de arquivo CSV\, com informações de desempenho do container\, indicadores de consumo de memória e tempos de acesso\.

```
Entrada:

  value: Lista das colunas impressas no arquivo CSV. Ex.: KLogColumnMacOs, KLogColumnWindows,
    KLogColumnAll ou qualquer combinação de KLogColumn... concatenado com pipe.
    Ex.: KLogColumnReadingTime | KLogColumnCurrentNumberOfOidsInTheCGroup | ...
```

Nota:

```
* Para vê a lista completa de colunas, use SetCsvFileRowsToPrint(KLogColumnAll) e
  SetCsvFileReader(true).
  Isto irá imprimir os nomes das constantes em cima de cada coluna do log.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/counter")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.36.csv", true)
	container.AddFilterToCvsLog(
		"contador",
		"counter",
		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",
	)
	container.AddFilterToSuccess(
		"done!",
		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",
		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)
	container.AddFilterToFail(
		"counter: 40",
		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",
		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.SetCsvFileRowsToPrint(KLogColumnAll)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	_, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var end = false

		select {
		case e := <-event:
			if e.Done == true || e.Fail == true || e.Error == true {
				end = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				log.Printf("message: %v\n", e.Message)
				break
			}
		}

		if end == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
container name: container_counter_delete_after_test
done: true
fail: false
error: false
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetCsvFileValueSeparator](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCsvFileValueSeparator.go#L34>)

```go
func (e *ContainerBuilder) SetCsvFileValueSeparator(value string)
```

#### SetCsvFileValueSeparator

English:

Defines the column separator of the log file\, in CSV format\, containing container usage statistics\.

```
Input:
  value: CSV file column separator (default value: ",")
```

Note:

```
* This function is used in conjunction with the SetCsvLogPath(), StartMonitor(), StopMonitor(),
  SetCsvFileRowSeparator(), SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog() and
  AddFilterToCvsLogWithReplace() functions;
* The data columns populated varies by operating system.
```

Português:

Define o separador de coluna do arquivo de log\, em formato CSV\, contendo estatísticas de uso do container\.

```
Entrada:
  value: separador de coluna do arquivo CSV (valor padrão: ",")
```

Nota:

```
* Esta função é usada em conjunto com as funções SetCsvLogPath(), StartMonitor(), StopMonitor(),
  SetCsvFileRowSeparator(), SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog() e
  AddFilterToCvsLogWithReplace();
* As colunas de dados preenchidos varia de acordo com o sistema operacional.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetCsvLogPath](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetCsvLogPath.go#L39>)

```go
func (e *ContainerBuilder) SetCsvLogPath(path string, removeOldFile bool)
```

#### SetCsvLogPath

English:

Defines the log file path\, in CSV format\, containing container usage statistics\.

```
Input:
  path: Log file path.
  removeOldFile: true deletes the file if it exists; false adds more records to the existing
    file.
```

Note:

```
* This function must be used in conjunction with the StartMonitor() and StopMonitor() functions;
* The data columns populated varies by operating system;
* See the SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog(),
  AddFilterToCvsLogWithReplace(), SetCsvFileValueSeparator() and SetCsvFileRowSeparator() functions
  to change some log settings.
```

Português:

Define o caminho do arquivo de log\, em formato CSV\, contendo estatísticas de uso do container\.

```
Entrada:
  path: Caminho do arquivo de log.
  removeOldFile: true apaga o arquivo caso o mesmo exista; false adiciona mais registros ao arquivo existente.
```

Nota:

```
* Esta função deve ser usada em conjunto com as funções StartMonitor() e StopMonitor();
* As colunas de dados preenchidos varia de acordo com o sistema operacional;
* Veja as funções SetCsvFileReader(), SetCsvFileRowsToPrint(), AddFilterToCvsLog(),
  AddFilterToCvsLogWithReplace(), SetCsvFileValueSeparator() e SetCsvFileRowSeparator() para alterar
  algumas configurações do log.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/counter")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)
	container.SetCsvFileValueSeparator("\t")
	container.AddFilterToCvsLogWithReplace(
		"contador",
		"counter",
		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",
		"\\.",
		",",
	)
	container.AddFilterToSuccess(
		"done!",
		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",
		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)
	container.AddFilterToFail(
		"counter: 40",
		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",
		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	select {
	case e := <-event:
		fmt.Printf("container name: %v\n", e.ContainerName)
		fmt.Printf("done: %v\n", e.Done)
		fmt.Printf("fail: %v\n", e.Fail)
		fmt.Printf("error: %v\n", e.Error)
		fmt.Printf("message: %v\n", e.Message)
	}

	container.StopMonitor()

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.38 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetDockerfileBuilder](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetDockerfileBuilder.go#L26>)

```go
func (e *ContainerBuilder) SetDockerfileBuilder(value DockerfileAuto)
```

#### SetDockerfileBuilder

English:

Defines a new object containing the builder of the dockerfile\.

```
Input:
  value: Object compatible with DockerfileAuto interface
```

Note:

```
* Eee the DockerfileAuto interface for further instructions.
```

Português:

Define um novo objeto contendo o construtor do arquivo dockerfile\.

```
Entrada:
  value: Objeto compatível com a interface DockerfileAuto
```

Nota:

```
* Veja a interface DockerfileAuto para mais instruções.
```

### func \(\*ContainerBuilder\) [SetEnvironmentVar](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetEnvironmentVar.go#L12>)

```go
func (e *ContainerBuilder) SetEnvironmentVar(value []string)
```

#### SetEnvironmentVar

English: Defines environment variables

```
value: slice of string containing one environment variable per key
```

Português: Define as variáveis de ambiente

```
value: slice de string contendo um variável de ambiente por chave
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		panic(err)
	}

	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		panic(err)
	}

	var mongoDocker = &ContainerBuilder{}

	mongoDocker.SetImageName("mongo:latest")

	mongoDocker.SetContainerName("container_delete_mongo_after_test")

	mongoDocker.AddPortToExpose("27017")

	mongoDocker.SetEnvironmentVar(
		[]string{
			"--host 0.0.0.0",
		},
	)

	if err != nil {
		panic(err)
	}

	mongoDocker.SetWaitStringWithTimeout(`"msg":"Waiting for connections","attr":{"port":27017`, 20*time.Second)

	err = mongoDocker.Init()
	if err != nil {
		panic(err)
	}

	err = mongoDocker.ContainerBuildAndStartFromImage()
	if err != nil {
		panic(err)
	}

}
```

#### Output

```

```

</p>
</details>

### func \(\*ContainerBuilder\) [SetGitCloneToBuild](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitCloneToBuild.go#L62>)

```go
func (e *ContainerBuilder) SetGitCloneToBuild(url string)
```

#### SetGitCloneToBuild

English:

Defines the path of a repository to be used as the base of the image to be mounted\.

```
Input:
  url: Address of the repository containing the project
```

Note:

```
* If the repository is private and the host computer has access to the git server, use
  SetPrivateRepositoryAutoConfig() to copy the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig automatically;
* To be able to access private repositories from inside the container, build the image in two or
  more steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh
  folder, and the ~/.gitconfig file to the /root folder;
* The MakeDefaultDockerfileForMe() function make a standard dockerfile with the procedures above;
* If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the
  password;
* If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and
  SetSshIdRsaFile() to define the files manually;
* This function must be used with the ImageBuildFromServer() and SetImageName() function to
  download and generate an image from the contents of a git repository;
* The repository must contain a Dockerfile file and it will be searched for in the following
  order:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' and '.*dockerfile.*';
* The repository can be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh().
```

Português:

Define o caminho de um repositório para ser usado como base da imagem a ser montada\.

```
Entrada:
  url: Endereço do repositório contendo o projeto
```

Nota:

```
* Caso o repositório seja privado e o computador hospedeiro tenha acesso ao servidor git, use
  SetPrivateRepositoryAutoConfig() para copiar as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig de forma automática;
* Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas
  ou mais etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta
  /root/.ssh e o arquivo .gitconfig para a pasta /root/;
* A função MakeDefaultDockerfileForMe() monta um dockerfile padrão com os procedimentos acima;
* Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para
  definir a senha da mesma;
* Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile()
  e SetSshIdRsaFile() para definir os arquivos de forma manual;
* Esta função deve ser usada com a função ImageBuildFromServer() e SetImageName() para baixar e
  gerar uma imagem a partir do conteúdo de um repositório git;
* O repositório deve contar um arquivo Dockerfile e ele será procurado na seguinte ordem:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' e '.*dockerfile.*';
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e SetGitCloneToBuildWithUserPassworh().
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		panic(err)
	}

	err = container.Init()
	if err != nil {
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		panic(err)
	}

	SaGarbageCollector()

}
```

#### Output

```

```

</p>
</details>

### func \(\*ContainerBuilder\) [SetGitCloneToBuildWithPrivateSSHKey](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitCloneToBuildWithPrivateSshKey.go#L109>)

```go
func (e *ContainerBuilder) SetGitCloneToBuildWithPrivateSSHKey(url, privateSSHKeyPath, password string)
```

#### SetGitCloneToBuildWithPrivateSSHKey

English:

Defines the path of a repository to be used as the base of the image to be mounted\.

```
Input:
  url: Address of the repository containing the project
  privateSSHKeyPath: this is the path of the private ssh key compatible with the public key
    registered in git
  password: password used when the ssh key was generated or empty string
```

Note:

```
* If the repository is private and the host computer has access to the git server, use
  SetPrivateRepositoryAutoConfig() to copy the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig automatically;
* To be able to access private repositories from inside the container, build the image in two or
  more steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh
  folder, and the ~/.gitconfig file to the /root folder;
* The MakeDefaultDockerfileForMe() function make a standard dockerfile with the procedures above;
* If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the
  password;
* If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and
  SetSshIdRsaFile() to define the files manually;
* This function must be used with the ImageBuildFromServer() and SetImageName() function to
  download and generate an image from the contents of a git repository;
* The repository must contain a Dockerfile file and it will be searched for in the following
  order:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' and '.*dockerfile.*';
* The repository can be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh().
```

code:

```
var err error
var usr *user.User
var privateSSHKeyPath string
var userGitConfigPath string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

privateSSHKeyPath = filepath.Join(usr.HomeDir, ".shh", "id_rsa")
userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateSSHKey(url, privateSSHKeyPath, password)
container.SetGitConfigFile(string(file))
```

Português:

Define o caminho de um repositório para ser usado como base da imagem a ser montada\.

```
Entrada:
  url: Endereço do repositório contendo o projeto
  privateSSHKeyPath: este é o caminho da chave ssh privada compatível com a chave pública
    cadastrada no git
  password: senha usada no momento que a chave ssh foi gerada ou string em branco
```

Nota:

```
* Caso o repositório seja privado e o computador hospedeiro tenha acesso ao servidor git, use
  SetPrivateRepositoryAutoConfig() para copiar as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig de forma automática;
* Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas
  ou mais etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta
  /root/.ssh e o arquivo .gitconfig para a pasta /root/;
* A função MakeDefaultDockerfileForMe() monta um dockerfile padrão com os procedimentos acima;
* Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para
  definir a senha da mesma;
* Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile()
  e SetSshIdRsaFile() para definir os arquivos de forma manual;
* Esta função deve ser usada com a função ImageBuildFromServer() e SetImageName() para baixar e
  gerar uma imagem a partir do conteúdo de um repositório git;
* O repositório deve contar um arquivo Dockerfile e ele será procurado na seguinte ordem:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' e '.*dockerfile.*';
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e
  SetGitCloneToBuildWithUserPassworh().
```

code:

```
var err error
var usr *user.User
var privateSSHKeyPath string
var userGitConfigPath string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

privateSSHKeyPath = filepath.Join(usr.HomeDir, ".shh", "id_rsa")
userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateSSHKey(url, privateSSHKeyPath, password)
container.SetGitConfigFile(string(file))
```

### func \(\*ContainerBuilder\) [SetGitCloneToBuildWithPrivateToken](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitCloneToBuildWithPrivateToken.go#L100>)

```go
func (e *ContainerBuilder) SetGitCloneToBuildWithPrivateToken(url, privateToken string)
```

#### SetGitCloneToBuildWithPrivateToken

English:

Defines the path of a repository to be used as the base of the image to be mounted\.

```
Input:
  url: Address of the repository containing the project
  privateToken: token defined on your git tool portal
```

Note:

```
* If the repository is private and the host computer has access to the git server, use
  SetPrivateRepositoryAutoConfig() to copy the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig automatically;
* To be able to access private repositories from inside the container, build the image in two or
  more steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh
  folder, and the ~/.gitconfig file to the /root folder;
* The MakeDefaultDockerfileForMe() function make a standard dockerfile with the procedures above;
* If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the
  password;
* If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and
  SetSshIdRsaFile() to define the files manually;
* This function must be used with the ImageBuildFromServer() and SetImageName() function to
  download and generate an image from the contents of a git repository;
* The repository must contain a Dockerfile file and it will be searched for in the following
  order:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' and '.*dockerfile.*';
* The repository can be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh().
```

code: var err error var usr \*user\.User var userGitConfigPath string var file \[\]byte usr\, err = user\.Current\(\) if err \!= nil \{ panic\(err\) \}

```
userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateToken(url, privateToken)
container.SetGitConfigFile(string(file))
```

Português:

Define o caminho de um repositório para ser usado como base da imagem a ser montada\.

```
Entrada:
  url: Endereço do repositório contendo o projeto
  privateToken: token definido no portal da sua ferramenta git
```

Nota:

```
* Caso o repositório seja privado e o computador hospedeiro tenha acesso ao servidor git, use
  SetPrivateRepositoryAutoConfig() para copiar as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig de forma automática;
* Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas
  ou mais etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta
  /root/.ssh e o arquivo .gitconfig para a pasta /root/;
* A função MakeDefaultDockerfileForMe() monta um dockerfile padrão com os procedimentos acima;
* Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para
  definir a senha da mesma;
* Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile()
  e SetSshIdRsaFile() para definir os arquivos de forma manual;
* Esta função deve ser usada com a função ImageBuildFromServer() e SetImageName() para baixar e
  gerar uma imagem a partir do conteúdo de um repositório git;
* O repositório deve contar um arquivo Dockerfile e ele será procurado na seguinte ordem:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' e '.*dockerfile.*';
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e
  SetGitCloneToBuildWithUserPassworh().
```

code:

```
var err error
var usr *user.User
var userGitConfigPath string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateToken(url, privateToken)
container.SetGitConfigFile(string(file))
```

### func \(\*ContainerBuilder\) [SetGitCloneToBuildWithUserPassworh](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitCloneToBuildWithUserPassworh.go#L103>)

```go
func (e *ContainerBuilder) SetGitCloneToBuildWithUserPassworh(url, user, password string)
```

#### SetGitCloneToBuildWithUserPassworh

English:

Defines the path of a repository to be used as the base of the image to be mounted\.

```
Input:
  url: Address of the repository containing the project
  user: git user
  password: git password
```

Note:

```
* If the repository is private and the host computer has access to the git server, use
  SetPrivateRepositoryAutoConfig() to copy the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig automatically;
* To be able to access private repositories from inside the container, build the image in two or
  more steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh
  folder, and the ~/.gitconfig file to the /root folder;
* The MakeDefaultDockerfileForMe() function make a standard dockerfile with the procedures above;
* If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the
  password;
* If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and
  SetSshIdRsaFile() to define the files manually;
* This function must be used with the ImageBuildFromServer() and SetImageName() function to
  download and generate an image from the contents of a git repository;
* The repository must contain a Dockerfile file and it will be searched for in the following
  order:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' and '.*dockerfile.*';
* The repository can be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh().
```

code:

```
var err error
var usr *user.User
var userGitConfigPath string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateToken(url, privateToken)
container.SetGitConfigFile(string(file))
```

Português:

Define o caminho de um repositório para ser usado como base da imagem a ser montada\.

```
Entrada:
  url: Endereço do repositório contendo o projeto
  user: git user
  password: git password
```

Nota:

```
* Caso o repositório seja privado e o computador hospedeiro tenha acesso ao servidor git, use
  SetPrivateRepositoryAutoConfig() para copiar as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig de forma automática;
* Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas
  ou mais etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta
  /root/.ssh e o arquivo .gitconfig para a pasta /root/;
* A função MakeDefaultDockerfileForMe() monta um dockerfile padrão com os procedimentos acima;
* Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para
  definir a senha da mesma;
* Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile()
  e SetSshIdRsaFile() para definir os arquivos de forma manual;
* Esta função deve ser usada com a função ImageBuildFromServer() e SetImageName() para baixar e
  gerar uma imagem a partir do conteúdo de um repositório git;
* O repositório deve contar um arquivo Dockerfile e ele será procurado na seguinte ordem:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' e '.*dockerfile.*';
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e
  SetGitCloneToBuildWithUserPassworh().
```

code:

```
var err error
var usr *user.User
var userGitConfigPath string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

userGitConfigPath = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(userGitConfigPath)

var container = ContainerBuilder{}
container.SetGitCloneToBuildWithPrivateToken(url, privateToken)
container.SetGitConfigFile(string(file))
```

### func \(\*ContainerBuilder\) [SetGitConfigFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitConfigFile.go#L58>)

```go
func (e *ContainerBuilder) SetGitConfigFile(value string)
```

#### SetGitConfigFile

English:

Defines the contents of the \.gitconfig file

```
Input:
  value: .gitconfig file contents
```

Example:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetGitConfigFile(string(file))
```

Português:

Define o conteúdo do arquivo \.gitconfig

```
Entrada:
```

```
value: conteúdo do arquivo .gitconfig
```

Exemplo:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".gitconfig")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetGitConfigFile(string(file))
```

### func \(\*ContainerBuilder\) [SetGitPathPrivateRepository](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitPathPrivateRepository.go#L18>)

```go
func (e *ContainerBuilder) SetGitPathPrivateRepository(value string)
```

#### SetGitPathPrivateRepository

English:

Path do private repository defined in "go env \-w GOPRIVATE=$GIT\_PRIVATE\_REPO"

```
Input:
  value: Caminho do repositório privado. Eg.: github.com/helmutkemper
```

Português:

Caminho do repositório privado definido em "go env \-w GOPRIVATE=$GIT\_PRIVATE\_REPO"

```
Entrada:
  value: Caminho do repositório privado. Ex.: github.com/helmutkemper
```

<details><summary>Example</summary>
<p>

this test only work on my acount \(sorry\)

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}
	container.SetPrintBuildOnStrOut()
	container.SetGitPathPrivateRepository("github.com/helmutkemper")

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("git@github.com:helmutkemper/iotmaker.docker.builder.private.example.git")
	container.MakeDefaultDockerfileForMeWithInstallExtras()
	err = container.SetPrivateRepositoryAutoConfig()
	if err != nil {
		panic(err)
	}

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		panic(err)
	}

	err = container.Init()
	if err != nil {
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		panic(err)
	}

	// read server inside a container on address http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetGitSshPassword](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetGitSshPassword.go#L63>)

```go
func (e *ContainerBuilder) SetGitSshPassword(password string)
```

#### SetGitSshPassword

English:

Sets the password for the ssh key for private git repositories\.

```
Input:
  password: git ssh certificate password
```

Note:

```
* If the repository is private and the host computer has access to the git server, use
  SetPrivateRepositoryAutoConfig() to copy the git credentials contained in ~/.ssh and the
  settings of ~/.gitconfig automatically;
* To be able to access private repositories from inside the container, build the image in two or
  more steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh
  folder, and the ~/.gitconfig file to the /root folder;
* The MakeDefaultDockerfileForMe() function make a standard dockerfile with the procedures above;
* If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the
  password;
* If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and
  SetSshIdRsaFile() to define the files manually;
* This function must be used with the ImageBuildFromServer() and SetImageName() function to
  download and generate an image from the contents of a git repository;
* The repository must contain a Dockerfile file and it will be searched for in the following
  order:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' and '.*dockerfile.*';
* The repository can be defined by the methods SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() and
  SetGitCloneToBuildWithUserPassworh().
```

Português:

Define a senha da chave ssh para repositórios git privados\.

```
Entrada:
  password: senha da chave ssh
```

Nota:

```
* Caso o repositório seja privado e o computador hospedeiro tenha acesso ao servidor git, use
  SetPrivateRepositoryAutoConfig() para copiar as credências do git contidas em ~/.ssh e as
  configurações de ~/.gitconfig de forma automática;
* Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas
  ou mais etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta
  /root/.ssh e o arquivo .gitconfig para a pasta /root/;
* A função MakeDefaultDockerfileForMe() monta um dockerfile padrão com os procedimentos acima;
* Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para
  definir a senha da mesma;
* Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile()
  e SetSshIdRsaFile() para definir os arquivos de forma manual;
* Esta função deve ser usada com a função ImageBuildFromServer() e SetImageName() para baixar e
  gerar uma imagem a partir do conteúdo de um repositório git;
* O repositório deve contar um arquivo Dockerfile e ele será procurado na seguinte ordem:
  './Dockerfile-iotmaker', './Dockerfile', './dockerfile', 'Dockerfile.*', 'dockerfile.*',
  '.*Dockerfile.*' e '.*dockerfile.*';
* O repositório pode ser definido pelos métodos SetGitCloneToBuild(),
  SetGitCloneToBuildWithPrivateSshKey(), SetGitCloneToBuildWithPrivateToken() e
  SetGitCloneToBuildWithUserPassworh().
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCPUPeriod](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCPUPeriod.go#L27>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCPUPeriod(value int64)
```

#### SetImageBuildOptionsCPUPeriod

English:

Specify the CPU CFS scheduler period\, which is used alongside \-\-cpu\-quota\.

```
Input:
  value: CPU CFS scheduler period
```

Defaults to 100000 microseconds \(100 milliseconds\)\. Most users do not change this from the default\.

For most use\-cases\, \-\-cpus is a more convenient alternative\.

Português:

Especifique o período do agendador CFS da CPU\, que é usado junto com \-\-cpu\-quota\.

```
Entrada:
  value: período do agendador CFS da CPU
```

O padrão é 100\.000 microssegundos \(100 milissegundos\)\. A maioria dos usuários não altera o padrão\.

Para a maioria dos casos de uso\, \-\-cpus é uma alternativa mais conveniente\.

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCPUQuota](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCPUQuota.go#L40>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCPUQuota(value int64)
```

#### SetImageBuildOptionsCPUQuota

English:

Defines the host machine’s CPU cycles\.

```
Input:
  value: machine’s CPU cycles. (Default: 1024)
```

Set this flag to a value greater or less than the default of 1024 to increase or reduce the container’s weight\, and give it access to a greater or lesser proportion of the host machine’s CPU cycles\.

This is only enforced when CPU cycles are constrained\. When plenty of CPU cycles are available\, all containers use as much CPU as they need\. In that way\, this is a soft limit\. \-\-cpu\-shares does not prevent containers from being scheduled in swarm mode\. It prioritizes container CPU resources for the available CPU cycles\.

It does not guarantee or reserve any specific CPU access\.

Português:

Define os ciclos de CPU da máquina hospedeira\.

```
Entrada:
  value: ciclos de CPU da máquina hospedeira. (Default: 1024)
```

Defina este flag para um valor maior ou menor que o padrão de 1024 para aumentar ou reduzir o peso do container e dar a ele acesso a uma proporção maior ou menor dos ciclos de CPU da máquina hospedeira\.

Isso só é aplicado quando os ciclos da CPU são restritos\. Quando muitos ciclos de CPU estão disponíveis\, todos os containeres usam a quantidade de CPU de que precisam\. Dessa forma\, é um limite flexível\. \-\-cpu\-shares não impede que os containers sejam agendados no modo swarm\. Ele prioriza os recursos da CPU do container para os ciclos de CPU disponíveis\.

Não garante ou reserva nenhum acesso específico à CPU\.

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCPUSetCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCPUSetCPUs.go#L34>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCPUSetCPUs(value string)
```

#### SetImageBuildOptionsCPUSetCPUs

English:

Limit the specific CPUs or cores a container can use\.

```
Input:
  value: string with the format "1,2,3"
```

A comma\-separated list or hyphen\-separated range of CPUs a container can use\, if you have more than one CPU\.

The first CPU is numbered 0\.

A valid value might be 0\-3 \(to use the first\, second\, third\, and fourth CPU\) or 1\,3 \(to use the second and fourth CPU\)\.

Português:

Limite a quantidade de CPUs ou núcleos específicos que um container pode usar\.

```
Entrada:
  value: string com o formato "1,2,3"
```

Uma lista separada por vírgulas ou intervalo separado por hífen de CPUs que um container pode usar\, se você tiver mais de uma CPU\.

A primeira CPU é numerada como 0\.

Um valor válido pode ser 0\-3 \(para usar a primeira\, segunda\, terceira e quarta CPU\) ou 1\,3 \(para usar a segunda e a quarta CPU\)\.

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCPUSetMems](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCPUSetMems.go#L30>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCPUSetMems(value string)
```

#### SetImageBuildOptionsCPUSetMems

English:

Define a memory nodes \(MEMs\) \(\-\-cpuset\-mems\)

```
Input:
  value: string with the format "0-3,5-7"
```

\-\-cpuset\-mems="" Memory nodes \(MEMs\) in which to allow execution \(0\-3\, 0\,1\)\. Only effective on NUMA systems\.

If you have four memory nodes on your system \(0\-3\)\, use \-\-cpuset\-mems=0\,1 then processes in your Docker container will only use memory from the first two memory nodes\.

Português:

Define memory node \(MEMs\) \(\-\-cpuset\-mems\)

```
Entrada:
  value: string com o formato "0-3,5-7"
```

\-\-cpuset\-mems="" Memory nodes \(MEMs\) no qual permitir a execução \(0\-3\, 0\,1\)\. Só funciona em sistemas NUMA\.

Se você tiver quatro nodes de memória em seu sistema \(0\-3\)\, use \-\-cpuset\-mems=0\,1 então\, os processos em seu container do Docker usarão apenas a memória dos dois primeiros nodes\.

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCPUShares](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCPUShares.go#L45>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCPUShares(value int64)
```

#### SetImageBuildOptionsCPUShares

English:

Set the CPU shares of the image build options\.

```
Input:
  value: CPU shares (Default: 1024)
```

Set this flag to a value greater or less than the default of 1024 to increase or reduce the container’s weight\, and give it access to a greater or lesser proportion of the host machine’s CPU cycles\.

This is only enforced when CPU cycles are constrained\.

When plenty of CPU cycles are available\, all containers use as much CPU as they need\.

In that way\, this is a soft limit\. \-\-cpu\-shares does not prevent containers from being scheduled in swarm mode\.

It prioritizes container CPU resources for the available CPU cycles\.

It does not guarantee or reserve any specific CPU access\.

Português:

Define o compartilhamento de CPU na construção da imagem\.

```
Entrada:
  value: Compartilhamento de CPU (Default: 1024)
```

Defina este sinalizador para um valor maior ou menor que o padrão de 1024 para aumentar ou reduzir o peso do container e dar a ele acesso a uma proporção maior ou menor dos ciclos de CPU da máquina host\.

Isso só é aplicado quando os ciclos da CPU são restritos\. Quando muitos ciclos de CPU estão disponíveis\, todos os container usam a quantidade de CPU de que precisam\. Dessa forma\, este é um limite flexível\. \-\-cpu\-shares não impede que os containers sejam agendados no modo swarm\.

Ele prioriza os recursos da CPU do container para os ciclos de CPU disponíveis\.

Não garante ou reserva nenhum acesso específico à CPU\.

### func \(\*ContainerBuilder\) [SetImageBuildOptionsCacheFrom](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsCacheFrom.go#L26>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsCacheFrom(values []string)
```

#### SetImageBuildOptionsCacheFrom

English:

Specifies images that are used for matching cache\.

```
Entrada:
  values: images that are used for matching cache.
```

Note:

```
Images specified here do not need to have a valid parent chain to match cache.
```

Português:

Especifica imagens que são usadas para correspondência de cache\.

```
Entrada:
  values: imagens que são usadas para correspondência de cache.
```

Note:

```
As imagens especificadas aqui não precisam ter uma cadeia pai válida para corresponder a cache.
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsExtraHosts](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsExtraHosts.go#L46>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsExtraHosts(values []string)
```

#### SetImageBuildOptionsExtraHosts

English:

Add hostname mappings at build\-time\. Use the same values as the docker client \-\-add\-host parameter\.

```
Input:
  values: hosts to mapping
```

Example:

```
values = []string{
  "somehost:162.242.195.82",
  "otherhost:50.31.209.229",
}

An entry with the ip address and hostname is created in /etc/hosts inside containers for this
build, e.g:

  162.242.195.82 somehost
  50.31.209.229 otherhost
```

Português:

Adiciona itens ao mapa de hostname durante o processo de construção da imagem\. Use os mesmos valores que em docker client \-\-add\-host parameter\.

```
Entrada:
  values: hosts para mapeamento
```

Exemplo:

```
values = []string{
  "somehost:162.242.195.82",
  "otherhost:50.31.209.229",
}

Uma nova entrada com o endereço ip e hostname será criada dentro de /etc/hosts do container.
Exemplo:

  162.242.195.82 somehost
  50.31.209.229 otherhost
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsIsolationDefault](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsIsolationDefault.go#L16>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsIsolationDefault()
```

#### SetImageBuildOptionsIsolationDefault

English:

Set default isolation mode on current daemon

Português:

Define o método de isolamento do processo como sendo o mesmo do deamon

### func \(\*ContainerBuilder\) [SetImageBuildOptionsIsolationHyperV](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsIsolationHyperV.go#L16>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsIsolationHyperV()
```

#### SetImageBuildOptionsIsolationHyperV

English:

Set HyperV isolation mode

Português:

Define o método de isolamento como sendo HyperV

### func \(\*ContainerBuilder\) [SetImageBuildOptionsIsolationProcess](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsIsolationProcess.go#L16>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsIsolationProcess()
```

#### SetImageBuildOptionsIsolationProcess

English:

Set process isolation mode

Português:

Determina o método de isolamento do processo

### func \(\*ContainerBuilder\) [SetImageBuildOptionsMemory](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsMemory.go#L78>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsMemory(value int64)
```

#### SetImageBuildOptionsMemory

English:

The maximum amount of memory the container can use\.

```
Input:
  value: amount of memory in bytes
```

Note:

```
* If you set this option, the minimum allowed value is 4 * 1024 * 1024 (4 megabyte);
* Use value * KKiloByte, value * KMegaByte and value * KGigaByte
  See https://docs.docker.com/engine/reference/run/#user-memory-constraints
```

Português:

Memória máxima total que o container pode usar\.

```
Entrada:
  value: Quantidade de memória em bytes
```

Nota:

```
* Se você vai usar esta opção, o máximo permitido é 4 * 1024 * 1024 (4 megabyte)
* Use value * KKiloByte, value * KMegaByte e value * KGigaByte
  See https://docs.docker.com/engine/reference/run/#user-memory-constraints
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	select {
	case e := <-event:
		fmt.Printf("container name: %v\n", e.ContainerName)
		fmt.Printf("done: %v\n", e.Done)
		fmt.Printf("fail: %v\n", e.Fail)
		fmt.Printf("error: %v\n", e.Error)
		fmt.Printf("message: %v\n", e.Message)
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.38 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetImageBuildOptionsMemorySwap](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsMemorySwap.go#L70>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsMemorySwap(value int64)
```

#### SetImageBuildOptionsMemorySwap

English:

Set memory swap \(\-\-memory\-swap\)

Note:

```
* Use value * KKiloByte, value * KMegaByte and value * KGigaByte
  See https://docs.docker.com/engine/reference/run/#user-memory-constraints
```

Português:

habilita a opção memory swp

Note:

```
* Use value * KKiloByte, value * KMegaByte e value * KGigaByte
  See https://docs.docker.com/engine/reference/run/#user-memory-constraints
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsNoCache](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsNoCache.go#L12>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsNoCache()
```

#### SetImageBuildOptionsNoCache

English:

```
Set image build no cache
```

Português:

```
Define a opção `sem cache` para a construção da imagem
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsPlatform](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsPlatform.go#L31>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsPlatform(value string)
```

#### SetImageBuildOptionsPlatform

English:

Target platform containers for this service will run on\, using the os\[/arch\[/variant\]\] syntax\.

```
Input:
  value: target platform
```

Examples:

```
osx
windows/amd64
linux/arm64/v8
```

Português:

Especifica a plataforma de container onde o serviço vai rodar\, usando a sintaxe os\[/arch\[/variant\]\]

```
Entrada:
  value: plataforma de destino
```

Exemplos:

```
osx
windows/amd64
linux/arm64/v8
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsSecurityOpt](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsSecurityOpt.go#L43>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsSecurityOpt(value []string)
```

#### SetImageBuildOptionsSecurityOpt

English:

Set the container security options

```
Input:
  values: container security options
```

Examples:

```
label=user:USER        — Set the label user for the container
label=role:ROLE        — Set the label role for the container
label=type:TYPE        — Set the label type for the container
label=level:LEVEL      — Set the label level for the container
label=disable          — Turn off label confinement for the container
apparmor=PROFILE       — Set the apparmor profile to be applied to the container
no-new-privileges:true — Disable container processes from gaining new privileges
seccomp=unconfined     — Turn off seccomp confinement for the container
seccomp=profile.json   — White-listed syscalls seccomp Json file to be used as a seccomp filter
```

Português:

Modifica as opções de segurança do container

```
Entrada:
  values: opções de segurança do container
```

Exemplos:

```
label=user:USER        — Determina o rótulo user para o container
label=role:ROLE        — Determina o rótulo role para o container
label=type:TYPE        — Determina o rótulo type para o container
label=level:LEVEL      — Determina o rótulo level para o container
label=disable          — Desliga o confinamento do rótulo para o container
apparmor=PROFILE       — Habilita o perfil definido pelo apparmor do linux para ser definido ao container
no-new-privileges:true — Impede o processo do container a ganhar novos privilégios
seccomp=unconfined     — Desliga o confinamento causado pelo seccomp do linux ao container
seccomp=profile.json   — White-listed syscalls seccomp Json file to be used as a seccomp filter
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsSquash](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsSquash.go#L20>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsSquash(value bool)
```

#### SetImageBuildOptionsSquash

English:

Squash the resulting image's layers to the parent preserves the original image and creates a new one from the parent with all the changes applied to a single layer

```
Input:
  value: true preserve the original image and creates a new one from the parent
```

Português:

Usa o conteúdo dos layers da imagem pai para criar uma imagem nova\, preservando a imagem pai\, e aplica todas as mudanças a um novo layer

```
Entrada:
  value: true preserva a imagem original e cria uma nova imagem a partir da imagem pai
```

### func \(\*ContainerBuilder\) [SetImageBuildOptionsTarget](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageBuildOptionsTarget.go#L28>)

```go
func (e *ContainerBuilder) SetImageBuildOptionsTarget(value string)
```

#### SetImageBuildOptionsTarget

English:

Build the specified stage as defined inside the Dockerfile\.

```
Input:
  value: stage name
```

Note:

```
* See the multi-stage build docs for details.
  See https://docs.docker.com/develop/develop-images/multistage-build/
```

Português:

Monta o container a partir do estágio definido no arquivo Dockerfile\.

```
Entrada:
  value: nome do estágio
```

Nota:

```
* Veja a documentação de múltiplos estágios para mais detalhes.
  See https://docs.docker.com/develop/develop-images/multistage-build/
```

### func \(\*ContainerBuilder\) [SetImageCacheName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageCacheName.go#L28>)

```go
func (e *ContainerBuilder) SetImageCacheName(name string)
```

#### SetImageCacheName

English::

Defines the name of the cache image

```
Input:
  name: Name of the cached image. (Default: "cache:lastest")
```

Note:

```
* See SaImageMakeCache(), SetCacheEnable(), MakeDefaultDockerfileForMe() and
  MakeDefaultDockerfileForMeWithInstallExtras() functions
```

Português:

Define o nome da imagem cache

```
Entrada:
  name: Nome da imagem cacge. (Default: "cache:lastest")
```

Nota:

```
* Veja as funções SaImageMakeCache(), SetCacheEnable(), MakeDefaultDockerfileForMe() e
  MakeDefaultDockerfileForMeWithInstallExtras()
```

### func \(\*ContainerBuilder\) [SetImageExpirationTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageExpirationTime.go#L31>)

```go
func (e *ContainerBuilder) SetImageExpirationTime(expiration time.Duration)
```

#### SetImageExpirationTime

English:

Sets image validity time\, preventing image build more than once within a certain period of time\.

```
Input:
  expiration: Image expiration time
```

Note:

```
* This feature prevents creation of the same image when the test uses loops to generate multiple
  containers from the same image.
```

Português:

Define o tempo de validade da imagem\, evitando o build da imagem mais de uma vez dentro de um certo período de tempo\.

```
Entrada:
  expiration: Tempo de validade da imagem
```

Nota:

```
* Esta funcionalidade impede a criação da mesma imagem quando o teste usa laços para gerar vários
  containers da mesma imagem.
```

### func \(\*ContainerBuilder\) [SetImageName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetImageName.go#L26>)

```go
func (e *ContainerBuilder) SetImageName(value string)
```

#### SetImageName

English:

Defines the name of the image to be used or created

```
Input:
  value: name of the image to be downloaded or created
```

Note:

```
* the image name must have the version tag. E.g.: name:latest
```

Português:

Define o nome da imagem a ser usada ou criada

```
Entrada:
  value: noma da imagem a ser baixada ou criada
```

Nota:

\* o nome da imagem deve ter a tag de versão\. Ex\.: nome:latest

<details><summary>Example</summary>
<p>

```go
{

	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// English: read server inside a container on address http://localhost:3030/
	//
	// Português: lê o servidor dentro do container na porta http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetInspectInterval](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetInspectInterval.go#L32>)

```go
func (e *ContainerBuilder) SetInspectInterval(value time.Duration)
```

#### SetInspectInterval

English:

Defines the container's monitoring interval \[optional\]

```
Input:
  value: time interval between container inspection events
```

Note:

```
* This function has a high computational cost and should be used sparingly.
* The captured values are presented by GetLastInspect() and GetChannelOnContainerInspect()
```

Português:

Define o intervalo de monitoramento do container \[opcional\]

```
Entrada:
  value: intervalo de tempo entre os eventos de inspeção do container
```

Nota:

```
* Esta função tem um custo computacional elevado e deve ser usada com moderação.
* Os valores capturados são apresentados por GetLastInspect() e GetChannelOnContainerInspect()
```

### func \(\*ContainerBuilder\) [SetMetadata](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetMetadata.go#L18>)

```go
func (e *ContainerBuilder) SetMetadata(metadata map[string]interface{})
```

#### SetMetadata

English:

Sets a list of user\-defined data

```
Input:
  metadata: map[string]interface{} with user defined data
```

Português:

Define uma lista de dados definidos pelo usuário

```
Entrada:
  metadata: map[string]interface{} com dados definidos oelo usuário
```

### func \(\*ContainerBuilder\) [SetNetworkDocker](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetNetworkDocker.go#L30>)

```go
func (e *ContainerBuilder) SetNetworkDocker(network isolatedNetwork.ContainerBuilderNetworkInterface)
```

#### SetNetworkDocker

English:

Sets the docker network manager pointer

```
Input:
  network: pointer to the network manager object.
```

Note:

```
* Compatible with dockerBuilderNetwork.ContainerBuilderNetwork{} object
```

Português:

Define o ponteiro do gerenciador de rede docker

```
Entrada:
  network: ponteiro para o objeto gerenciador de rede.
```

Nota:

```
* Compatível com o objeto dockerBuilderNetwork.ContainerBuilderNetwork{}
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	var netDocker = dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		panic(err)
	}

	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		panic(err)
	}

	var mongoDocker = &ContainerBuilder{}

	mongoDocker.SetNetworkDocker(&netDocker)

	mongoDocker.SetImageName("mongo:latest")

	mongoDocker.SetContainerName("container_delete_mongo_after_test")

	mongoDocker.AddPortToExpose("27017")

	mongoDocker.SetEnvironmentVar(
		[]string{
			"--host 0.0.0.0",
		},
	)

	err = mongoDocker.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/data", "/data")
	if err != nil {
		panic(err)
	}

	mongoDocker.SetWaitStringWithTimeout(`"msg":"Waiting for connections","attr":{"port":27017`, 20*time.Second)

	err = mongoDocker.Init()
	if err != nil {
		panic(err)
	}

	err = mongoDocker.ContainerBuildAndStartFromImage()
	if err != nil {
		panic(err)
	}

	SaGarbageCollector()

}
```

#### Output

```

```

</p>
</details>

### func \(\*ContainerBuilder\) [SetOnBuild](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetOnBuild.go#L129>)

```go
func (e *ContainerBuilder) SetOnBuild(onBuild []string)
```

#### SetOnBuild

English:

Adds to the image a trigger instruction to be executed at a later time\, when the image is used as the base for another build\.

```
Input:
  onBuild: List of trigger instruction to be executed at a later time, when the image is used as
   the base for another build
```

The trigger will be executed in the context of the downstream build\, as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile\.

Any build instruction can be registered as a trigger\.

This is useful if you are building an image which will be used as a base to build other images\, for example an application build environment or a daemon which may be customized with user\-specific configuration\.

For example\, if your image is a reusable Python application builder\, it will require application source code to be added in a particular directory\, and it might require a build script to be called after that\. You can’t just call ADD and RUN now\, because you don’t yet have access to the application source code\, and it will be different for each application build\. You could simply provide application developers with a boilerplate Dockerfile to copy\-paste into their application\, but that is inefficient\, error\-prone and difficult to update because it mixes with application\-specific code\.

The solution is to use ONBUILD to register advance instructions to run later\, during the next build stage\.

Here’s how it works:

When it encounters an OnBuild instruction\, the builder adds a trigger to the metadata of the image being built\. The instruction does not otherwise affect the current build\. At the end of the build\, a list of all triggers is stored in the image manifest\, under the key OnBuild\. They can be inspected with the docker inspect command\.

Later the image may be used as a base for a new build\, using the FROM instruction\. As part of processing the FROM instruction\, the downstream builder looks for OnBuild triggers\, and executes them in the same order they were registered\. If any of the triggers fail\, the FROM instruction is aborted which in turn causes the build to fail\.

If all triggers succeed\, the FROM instruction completes and the build continues as usual\.

Triggers are cleared from the final image after being executed\. In other words they are not inherited by “grand\-children” builds\.

For example you might add something like this:

```
[]string{
  "ADD . /app/src",
  "RUN /usr/local/bin/python-build --dir /app/src",
}
```

Warning:

```
The ONBUILD instruction may not trigger FROM or MAINTAINER instructions.
```

Note:

```
See https://docs.docker.com/engine/reference/builder/#onbuild
```

Português:

Adiciona à imagem uma instrução de gatilho a ser executada posteriormente\, quando a imagem for usada como base para outra construção\.

```
Entrada:
  onBuild: Lista de instruções de gatilho a serem executadas posteriormente, quando a imagem for
    usada como base para outra construção
```

O gatilho será executado no contexto do downstream build \, como se tivesse sido inserido imediatamente após a instrução FROM no downstream Dockerfile\.

Qualquer instrução de construção pode ser registrada como um gatilho\.

Isso é útil se você estiver construindo uma imagem que será usada como base para construir outras imagens\, por exemplo\, um ambiente de construção de aplicativo ou um daemon que pode ser personalizado com configuração específica do usuário\.

Por exemplo\, se sua imagem for um construtor de aplicativo Python reutilizável\, ela exigirá que o código\-fonte do aplicativo seja adicionado em um diretório específico e pode exigir que um script de construção seja chamado depois disso\. Você não pode simplesmente chamar ADD e RUN agora\, porque você ainda não tem acesso ao código\-fonte do aplicativo e será diferente para cada construção de aplicativo\. Você poderia simplesmente fornecer aos desenvolvedores de aplicativos um Dockerfile padrão para copiar e colar em seus aplicativos\, mas isso é ineficiente\, sujeito a erros e difícil de atualizar porque se mistura com o código específico do aplicativo\.

A solução é usar o OnBuild para registrar instruções antecipadas para executar mais tarde\, durante o próximo estágio de compilação\.

Funciona assim:

Ao encontrar uma instrução OnBuild\, o construtor adiciona um gatilho aos metadados da imagem que está sendo construída\. A instrução não afeta de outra forma a construção atual\.

No final da construção\, uma lista de todos os gatilhos é armazenada no manifesto da imagem\, sob a chave OnBuild\. Eles podem ser inspecionados com o comando docker inspect\. Posteriormente\, a imagem pode ser usada como base para uma nova construção\, usando a instrução FROM\. Como parte do processamento da instrução FROM\, o downstream builder procura gatilhos OnBuild e os executa na mesma ordem em que foram registrados\. Se qualquer um dos gatilhos falhar\, a instrução FROM é abortada\, o que\, por sua vez\, faz com que o build falhe\. Se todos os gatilhos forem bem\-sucedidos\, a instrução FROM será concluída e a construção continuará normalmente\.

Os gatilhos são apagados da imagem final após serem executados\. Em outras palavras\, eles não são herdados por construções de "netos"\.

Por exemplo\, você pode adicionar algo assim:

```
[]string{
  "ADD . /app/src",
  "RUN /usr/local/bin/python-build --dir /app/src",
}
```

Atenção:

```
A instrução ONBUILD não pode disparar as instruções FROM ou MAINTAINER.
```

Nota:

```
https://docs.docker.com/engine/reference/builder/#onbuild
```

### func \(\*ContainerBuilder\) [SetOpenAllContainersPorts](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetOpenAllContainersPorts.go#L26>)

```go
func (e *ContainerBuilder) SetOpenAllContainersPorts()
```

#### SetOpenAllContainersPorts

English:

Automatically exposes all ports listed in the image used to generate the container

Note:

```
* The ports exposed in the creation of the container can be defined by
  SetOpenAllContainersPorts(), AddPortToChange() and AddPortToExpose();
* By default, all doors are closed;
* The ImageListExposedPorts() function returns all ports defined in the image to be exposed.
```

Português:

Expõe automaticamente todas as portas listadas na imagem usada para gerar o container

Nota:

```
* As portas expostas na criação do container pode ser definidas por SetOpenAllContainersPorts(),
  AddPortToChange() e AddPortToExpose();
* Por padrão, todas as portas ficam fechadas;
* A função ImageListExposedPorts() retorna todas as portas definidas na imagem para serem expostas.
```

### func \(\*ContainerBuilder\) [SetPrintBuildOnStrOut](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetPrintBuildOnStrOut.go#L13>)

```go
func (e *ContainerBuilder) SetPrintBuildOnStrOut()
```

#### SetPrintBuildOnStrOut

English:

Prints the standard output used when building the image or the container to the standard output of the log\.

Português:

Imprime a saída padrão usada durante a construção da imagem ou do container no log\.

### func \(\*ContainerBuilder\) [SetPrivateRepositoryAutoConfig](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetPrivateRepositoryAutoConfig.go#L28>)

```go
func (e *ContainerBuilder) SetPrivateRepositoryAutoConfig() (err error)
```

#### SetPrivateRepositoryAutoConfig

English:

Copies the ssh \~/\.ssh/id\_rsa file and the \~/\.gitconfig file to the SSH\_ID\_RSA\_FILE and GITCONFIG\_FILE variables\.

```
Output:
  err: Standard error object
```

Português:

Copia o arquivo ssh \~/\.ssh/id\_rsa e o arquivo \~/\.gitconfig para as variáveis SSH\_ID\_RSA\_FILE e GITCONFIG\_FILE\.

```
Saída:
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [SetRestartProbability](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetRestartProbability.go#L23>)

```go
func (e *ContainerBuilder) SetRestartProbability(restartProbability, restartChangeIpProbability float64, limit int)
```

#### SetRestartProbability

English:

```
Set the restart probability and the probability of changing the ip of the container when it restarts.

Input:
  restartProbability: Probability of restarting a container during the chaos test.
  restartChangeIpProbability: Probability of changing the ip of the container when it restarts.
  limit: Limit of how many times the container will restart.
```

Português:

Define a probabilidade de reiniciar um container durante o teste de caos e a probabilidade de trocar o ip do container quando ele reiniciar\.

```
Entrada:
  restartProbability: Probabilidade de reiniciar um container durante o teste de caos.
  restartChangeIpProbability: Probabilidade de trocar o ip do container quando ele reiniciar.
  limit: Limite de quantas vezes o container vai reiniciar.
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetSceneNameOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetSceneNameOnChaosScene.go#L48>)

```go
func (e *ContainerBuilder) SetSceneNameOnChaosScene(name string)
```

#### SetSceneNameOnChaosScene

English:

Adds the container to a scene

Scenes help control the maximum amount of container stopped or paused at the same time

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Adiciona o container a uma cena

Cenas ajudam a controlar a quantidade máxima de container parados ou pausados ao mesmo tempo

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

### func \(\*ContainerBuilder\) [SetSshIdRsaFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetSshIdRsaFile.go#L52>)

```go
func (e *ContainerBuilder) SetSshIdRsaFile(value string)
```

#### SetSshIdRsaFile

English:

Set a id\_rsa file from shh

Example:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".ssh", "id_rsa")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetSshIdRsaFile(string(file))
```

Português:

Define o arquivo id\_rsa do shh

Exemplo:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".ssh", "id_rsa")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetSshIdRsaFile(string(file))
```

### func \(\*ContainerBuilder\) [SetSshKnownHostsFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetSshKnownHostsFile.go#L52>)

```go
func (e *ContainerBuilder) SetSshKnownHostsFile(value string)
```

#### SetSshKnownHostsFile

English:

Set a sseh knownhosts file

Example:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".ssh", "known_hosts")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetSshKnownHostsFile(string(file))
```

Português:

Define o arquivo knownhosts do ssh

Exemplo:

```
var err error
var usr *user.User
var path string
var file []byte
usr, err = user.Current()
if err != nil {
  panic(err)
}

path = filepath.Join(usr.HomeDir, ".ssh", "known_hosts")
file, err = ioutil.ReadFile(path)
if err != nil {
  panic(err)
}

var container = ContainerBuilder{}
container.SetSshKnownHostsFile(string(file))
```

### func \(\*ContainerBuilder\) [SetTimeBeforeStartChaosInThisContainerOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetTimeBeforeStartChaosInThisContainerOnChaosScene.go#L60>)

```go
func (e *ContainerBuilder) SetTimeBeforeStartChaosInThisContainerOnChaosScene(min, max time.Duration)
```

#### SetTimeBeforeStartChaosInThisContainerOnChaosScene

English:

Defines the minimum and maximum waiting times before enabling the restart of containers in a chaos scenario

The choice of time will be made randomly between the minimum and maximum values

```
Input:
  min: minimum waiting time
  max: maximum wait time
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define os tempos mínimo e máximos de espera antes de habilitar o reinício dos containers em um cenário de caos

A escolha do tempo será feita de forma aleatória entre os valores mínimo e máximo

```
Entrada:
  min: tempo de espera mínimo
  max: tempo de espera máximo
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

### func \(\*ContainerBuilder\) [SetTimeOnContainerPausedStateOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetTimeOnContainerPausedStateOnChaosScene.go#L54>)

```go
func (e *ContainerBuilder) SetTimeOnContainerPausedStateOnChaosScene(min, max time.Duration)
```

#### SetTimeOnContainerPausedStateOnChaosScene

English:

Sets the minimum and maximum times for the container pause

```
Input:
  min: minimum time for container pause
  max: maximum time for container pause
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define os tempos mínimos e máximos para a pausa do container

```
Entrada:
  min: tempo mínimo para a pausa do container
  max: tempo máximo para a pausa do container
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetTimeOnContainerUnpausedStateOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetTimeOnContainerUnpausedStateOnChaosScene.go#L54>)

```go
func (e *ContainerBuilder) SetTimeOnContainerUnpausedStateOnChaosScene(min, max time.Duration)
```

#### SetTimeOnContainerUnpausedStateOnChaosScene

English:

Defines the minimum and maximum times where the container is kept out of the paused state

```
Input:
  min: minimum time out of sleep state
  max: maximum time out of sleep state
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define os tempos mínimos e máximos onde o container é mantido fora do estado de pausa

```
Entrada:
  min: tempo mínimo fora do estado de pausa
  max: tempo máximo fora do estado de pausa
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetTimeToRestartThisContainerAfterStopEventOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetTimeToRestartThisContainerAfterStopEventOnChaosScene.go#L54>)

```go
func (e *ContainerBuilder) SetTimeToRestartThisContainerAfterStopEventOnChaosScene(min, max time.Duration)
```

#### SetTimeToRestartThisContainerAfterStopEventOnChaosScene

English

Defines the minimum and maximum times to restart the container after the container stop event\.

```
Input:
  min: minimum timeout before restarting container
  max: maximum timeout before restarting container
```

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Define os tempos mínimos e máximos para reiniciar o container após o evento de parar container\.

```
Entrada:
  min: tempo mínimo de espera antes de reiniciar o container
  max: tempo máximo de espera antes de reiniciar o container
```

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetTimeToStartChaosOnChaosScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetTimeToStartChaosOnChaosScene.go#L64>)

```go
func (e *ContainerBuilder) SetTimeToStartChaosOnChaosScene(min, max time.Duration)
```

#### SetTimeToStartChaosOnChaosScene

English:

This function sets a timeout before the chaos test starts\, when indicator text is encountered in the standard output\.

```
Input:
  min: minimum waiting time until chaos test starts
  max: maximum waiting time until chaos test starts
```

Basically\, the idea is that you put at some point in the test a text like\, chaos can be initialized\, in the container's standard output and the time gives a random character to when the chaos starts\.

Note:

```
* The following functions are used together during chaos testing:
    [optional] iotmakerdockerbuilder.ConfigChaosScene()

    Mandatory set:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [optional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

Português:

Esta função define um tempo de espera antes do teste de caos começar\, quando o texto indicador é incontrado na saída padrão\.

```
Entrada:
  min: tempo mínimo de espera até o teste de caos começar
  max: tempo máximo de espera até o teste de caos começar
```

Basicamente\, a ideia é que você coloque em algum ponto do teste um texto tipo\, caos pode ser inicializado\, na saída padrão do container e o tempo dá um caráter aleatório a quando o caos começa\.

Nota:

```
* As funções a seguir são usadas em conjunto durante o teste de caos:
    [opcional] iotmakerdockerbuilder.ConfigChaosScene()

    Conjunto obrigatório:
    ContainerBuilder.EnableChaosScene()
    ContainerBuilder.SetTimeOnContainerUnpausedStateOnChaosScene()
    ContainerBuilder.SetTimeToStartChaosOnChaosScene()
    ContainerBuilder.SetTimeToRestartThisContainerAfterStopEventOnChaosScene()
    ContainerBuilder.SetTimeOnContainerPausedStateOnChaosScene()
    ContainerBuilder.SetTimeBeforeStartChaosInThisContainerOnChaosScene()
    ContainerBuilder.SetSceneNameOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabePauseOnChaosScene()
    [opcional] ContainerBuilder.ContainerSetDisabeStopOnChaosScene()
```

<details><summary>Example</summary>
<p>

```go
{
	var err error
	var imageInspect types.ImageInspect

	err = SaImageMakeCacheWithDefaultName("./example/cache/", 365*24*60*60*time.Second)
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetCacheEnable(true)

	container.MakeDefaultDockerfileForMe()

	container.SetImageName("delete:latest")

	container.SetBuildFolderPath("./test/chaos")

	container.SetContainerName("container_counter_delete_after_test")

	container.SetImageBuildOptionsMemory(100 * KMegaByte)

	container.SetCsvLogPath("./test.counter.log.csv", true)

	container.SetCsvFileValueSeparator("\t")

	container.AddFilterToCvsLogWithReplace(

		"contador",

		"counter",

		"^.*?counter: (?P<valueToGet>[\\d\\.]+)",

		"\\.",
		",",
	)

	container.AddFilterToRestartContainer(

		"restart-me!",

		"^.*?(?P<valueToGet>restart-me!)",

		"",
		"",
	)

	container.AddFilterToSuccess(

		"done!",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ done!).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+(?P<value>done!).*",
		"${value}",
	)

	container.AddFilterToFail(

		"counter: 340",

		"^.*?(?P<valueToGet>\\d+/\\d+/\\d+ \\d+:\\d+:\\d+ counter: [\\d\\.]+).*",

		"(?P<date>\\d+/\\d+/\\d+)\\s+(?P<hour>\\d+:\\d+:\\d+)\\s+counter:\\s+(?P<value>[\\d\\.]+).*",
		"Test Fail! Counter Value: ${value} - Hour: ${hour} - Date: ${date}",
	)

	container.AddFilterToStartChaos(
		"chaos enable",
		"chaos enable",
		"",
		"",
	)

	container.SetRestartProbability(0.9, 1.0, 1)

	container.SetTimeToStartChaosOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeBeforeStartChaosInThisContainerOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerPausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeOnContainerUnpausedStateOnChaosScene(2*time.Second, 5*time.Second)

	container.SetTimeToRestartThisContainerAfterStopEventOnChaosScene(2*time.Second, 5*time.Second)

	container.EnableChaosScene(true)

	err = container.Init()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	imageInspect, err = container.ImageBuildFromFolder()
	if err != nil {
		fmt.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	fmt.Printf("image size: %v\n", container.SizeToString(imageInspect.Size))
	fmt.Printf("image os: %v\n", imageInspect.Os)

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	container.StartMonitor()

	event := container.GetChaosEvent()

	for {
		var pass = false
		select {
		case e := <-event:
			if e.Done == true || e.Error == true || e.Fail == true {
				pass = true

				fmt.Printf("container name: %v\n", e.ContainerName)
				fmt.Printf("done: %v\n", e.Done)
				fmt.Printf("fail: %v\n", e.Fail)
				fmt.Printf("error: %v\n", e.Error)
				fmt.Printf("message: %v\n", e.Message)

				break
			}
		}

		if pass == true {
			break
		}
	}

	err = container.StopMonitor()
	if err != nil {
		log.Printf("error: %v", err.Error())
		SaGarbageCollector()
		return
	}

	SaGarbageCollector()

}
```

#### Output

```
image size: 1.4 MB
image os: linux
container name: container_counter_delete_after_test
done: true
fail: false
error: false
message: done!
```

</p>
</details>

### func \(\*ContainerBuilder\) [SetWaitString](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetWaitString.go#L20>)

```go
func (e *ContainerBuilder) SetWaitString(value string)
```

#### SetWaitString

English:

Defines a text to be searched for in the container's default output and forces it to wait for the container to be considered ready\-to\-use

```
Input:
  value: searched text
```

Português:

Define um texto a ser procurado na saída padrão do container e força a espera do mesmo para se considerar o container como pronto para uso

```
Entrada:
  value: texto procurado
```

### func \(\*ContainerBuilder\) [SetWaitStringWithTimeout](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSetWaitStringWithTimeout.go#L26>)

```go
func (e *ContainerBuilder) SetWaitStringWithTimeout(value string, timeout time.Duration)
```

#### SetWaitStringWithTimeout

English:

Defines a text to be searched for in the container's default output and forces it to wait for the container to be considered ready\-to\-use

```
Input:
  value: text emitted to default output reporting by an expected event
  timeout: maximum waiting time
```

Português:

Define um texto a ser procurado na saída padrão do container e força a espera do mesmo para se considerar o container como pronto para uso

```
Entrada:
  value: texto emitido na saída padrão informando por um evento esperado
  timeout: tempo máximo de espera
```

<details><summary>Example</summary>
<p>

```go
{
	var err error

	SaGarbageCollector()

	var container = ContainerBuilder{}

	container.SetPrintBuildOnStrOut()

	container.SetImageName("delete:latest")

	container.SetContainerName("container_delete_server_after_test")

	container.SetGitCloneToBuild("https://github.com/helmutkemper/iotmaker.docker.util.whaleAquarium.sample.git")

	container.SetWaitStringWithTimeout("Stating server on port 3000", 10*time.Second)

	container.AddPortToChange("3000", "3030")

	err = container.AddFileOrFolderToLinkBetweenConputerHostAndContainer("./test/static", "/static")
	if err != nil {
		log.Printf("container.AddFileOrFolderToLinkBetweenConputerHostAndContainer().error: %v", err.Error())
		util.TraceToLog()
		panic(err)
	}

	err = container.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	_, err = container.ImageBuildFromServer()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ImageBuildFromServer().error: %v", err.Error())
		panic(err)
	}

	err = container.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		log.Printf("container.ContainerBuildAndStartFromImage().error: %v", err.Error())
		panic(err)
	}

	// English: read server inside a container on address http://localhost:3030/
	//
	// Português: lê o servidor dentro do container na porta http://localhost:3030/
	var resp *http.Response
	resp, err = http.Get("http://localhost:3030/")
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	var body []byte
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		util.TraceToLog()
		log.Printf("http.Get().error: %v", err.Error())
		panic(err)
	}

	fmt.Printf("%s", body)

	SaGarbageCollector()

}
```

#### Output

```
<html><body><p>C is life! Golang is a evolution of C</p></body></html>
```

</p>
</details>

### func \(\*ContainerBuilder\) [SizeToString](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSizeToString.go#L26>)

```go
func (e *ContainerBuilder) SizeToString(value int64) (size string)
```

#### SizeToString

Português:

Formata um valor inteiro em uma string contendo o valor em Bytes\, KBytes\, MBytes e GBytes\.

```
Entrada:
  value: valor inteiro representando um tamanho de memória

Saída:
  size: string contendo o valor em Bytes, KBytes, MBytes e GBytes
```

English:

```
Format an integer value into a string containing the value in Bytes, KBytes, MBytes and GBytes.

Input:
  value: integer value representing a memory size

Output:
  size: string containing the value in Bytes, KBytes, MBytes and GBytes
```

### func \(\*ContainerBuilder\) [StartMonitor](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcStartMonitor.go#L30>)

```go
func (e *ContainerBuilder) StartMonitor()
```

#### StartMonitor

English:

```
Enable a time.Ticker in order to gather performance information from the container in the form of
a CSV log and manage chaos control, if it has been enabled.
```

Note:

```
* This function is used in conjunction with the EnableChaosScene(), SetCsvLogPath() and
  StopMonitor() functions;
* StopMonitor() Must be called at the end of the chaos test.
```

Português:

Habilitar um time\.Ticker com a finalidade de colher informações de desempenho do container na forma de um log CSV e gerencia o controle de caos\, caso o mesmo tenha sido habilitado\.

Nota:

```
* Esta função é usada em conjunto com as funções EnableChaosScene(), SetCsvLogPath() e
  StopMonitor();
* StopMonitor() Must be called at the end of the chaos test.
```

### func \(\*ContainerBuilder\) [StopMonitor](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcStopMonitor.go#L26>)

```go
func (e *ContainerBuilder) StopMonitor() (err error)
```

#### StopMonitor

English:

Disable time\.Ticker in order to gather performance information from the container in the form of a CSV log and manage chaos control\, if it has been enabled\.

Note:

```
* This function is used in conjunction with the EnableChaosScene(), SetCsvLogPath() and
  StopMonitor() functions;
* StopMonitor() Must be called at the end of the chaos test.
```

Português:

Desabilita o time\.Ticker com a finalidade de colher informações de desempenho do container na forma de um log CSV e gerencia o controle de caos\, caso o mesmo tenha sido habilitado\.

Nota:

```
* Esta função é usada em conjunto com as funções EnableChaosScene(), SetCsvLogPath() e
  StopMonitor();
* StopMonitor() Deve ser chamado ao final do teste de caos.
```

### func \(ContainerBuilder\) [TestDockerInstall](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestDockerInstall.go#L23>)

```go
func (e ContainerBuilder) TestDockerInstall() (err error)
```

#### TestDockerInstall

English:

Test if docker is responding correctly

```
Output:
  err: Standard error object
```

Português:

Testa se o docker está respondendo de forma correta

```
Saída:
  err: Standard error object
```

### func \(\*ContainerBuilder\) [WaitForTextInContainerLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWaitForTextInContainerLog.go#L29>)

```go
func (e *ContainerBuilder) WaitForTextInContainerLog(value string) (dockerLogs string, err error)
```

#### WaitForTextInContainerLog

English:

Wait for the text to appear in the container's default output

```
Input:
  value: searched text

Output:
  dockerLogs: container's default output
  err: standard error object
```

Português: Espera pelo texto aparecer na saída padrão do container

```
Entrada:
  value: texto procurado

Saída:
  dockerLogs: saída padrão do container
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [WaitForTextInContainerLogWithTimeout](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWaitForTextInContainerLogWithTimeout.go#L34>)

```go
func (e *ContainerBuilder) WaitForTextInContainerLogWithTimeout(value string, timeout time.Duration) (dockerLogs string, err error)
```

#### WaitForTextInContainerLogWithTimeout

English:

Wait for the text to appear in the container's default output

```
Input:
  value: searched text
  timeout: wait timeout

Output:
  dockerLogs: container's default output
  err: standard error object
```

Português:

Espera pelo texto aparecer na saída padrão do container

```
Entrada:
  value: texto procurado
  timeout: tempo limite de espera

Saída:
  dockerLogs: saída padrão do container
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [addImageBuildOptionsGitCredentials](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddImageBuildOptionsGitCredentials.go#L20>)

```go
func (e *ContainerBuilder) addImageBuildOptionsGitCredentials() (buildOptions types.ImageBuildOptions)
```

addImageBuildOptionsGitCredentials

English:

Prepare the git credentials\.

Called from SetPrivateRepositoryAutoConfig\(\)

Português:

Prepara as credenciais do git\.

Chamada por SetPrivateRepositoryAutoConfig\(\)

### func \(\*ContainerBuilder\) [addProblem](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcAddProblem.go#L14>)

```go
func (e *ContainerBuilder) addProblem(problem string)
```

addProblem

English: Adds a description of a problem to explain the error to the user\.

```
Input:
  problem: problem explanation
```

Português: Adiciona a descrição de um problema para explica o erro ao usuário\.

```
Entrada:
  problem: descrição do problema
```

### func \(\*ContainerBuilder\) [findCurrentIPV4AddressSupport](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcFindCurrentIPV4AddressSupport.go#L31>)

```go
func (e *ContainerBuilder) findCurrentIPV4AddressSupport(networkID string) (IP string, err error)
```

findCurrentIPV4AddressSupport

English:

Support function for FindCurrentIpAddress\(\)

```
Input:
  networkID: Docker's network ID

Output:
  IP: network IPV4 address
  err: standard error object
```

Português: função de apoio a FindCurrentIpAddress\(\)

```
Entrada:
  networkID: ID da rede docker

Saída:
  IP: endereço IPV4 da rede
  err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [getIdByContainerName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetIdByContainerName.go#L23>)

```go
func (e *ContainerBuilder) getIdByContainerName() (err error)
```

getIdByContainerName

English:

Fills the container ID in the control object from the container name defined in SetContainerName\(\)

```
Output:
  err: Standard error object
```

Português:

Preenche o ID do container no objeto de controle a partir do nome do container definido em SetContainerName\(\)

```
Saída:
  err: Objeto de erro padrão
```

### func \(\*ContainerBuilder\) [getProbalityNumber](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetProbalityNumber.go#L18>)

```go
func (e *ContainerBuilder) getProbalityNumber() (probality float64)
```

getProbalityNumber

English:

Returns a random number greater than zero and less than one

```
Output:
  probality: Open point floating point number between 0.0 and 1.0
```

Português:

Retorna um número aleatório maior do que zero e menor do que um

```
Saída:
  probality: Número de ponto flutuante de ponto aberto entre 0.0 e 1.0
```

### func \(\*ContainerBuilder\) [getRandSeed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGetRandSeed.go#L23>)

```go
func (e *ContainerBuilder) getRandSeed() (seed *rand.Rand)
```

getRandSeed

English:

```
Generate random number seed

 Output:
   seed: random number seed
```

Português:

```
Gera a semente do número aleatório

 Saída:
   seed: semente do número aleatório
```

### func \(\*ContainerBuilder\) [gitMakePublicSshKey](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcGitMakePublicSshKey.go#L26>)

```go
func (e *ContainerBuilder) gitMakePublicSshKey() (publicKeys *ssh.PublicKeys, err error)
```

gitMakePublicSshKey

English:

Mount the ssl certificate for the git clone function

```
Output:
  publicKeys: Ponteiro de objeto compatível com o objeto ssh.PublicKeys
  err: standard error object
```

Português:

Monta o certificado ssl para a função de git clone

```
Saída:
```

```
publicKeys: Ponteiro de objeto compatível com o objeto ssh.PublicKeys
err: objeto de erro padrão
```

### func \(\*ContainerBuilder\) [imageExpirationTimeIsValid](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcImageExpirationTimeIsValid.go#L20>)

```go
func (e *ContainerBuilder) imageExpirationTimeIsValid() (valid bool)
```

imageExpirationTimeIsValid

English:

Detects if the image is within the expiration date\.

```
Output:
  valid: true, if the image is within the expiry date.
```

Português:

Detecta se a imagem está dentro do prazo de validade\.

```
Saída:
  valid: true, se a imagem está dentro do prazo de validade.
```

### func \(\*ContainerBuilder\) [incIpV4Address](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcIncIpV4Address.go#L44>)

```go
func (e *ContainerBuilder) incIpV4Address(ip string, inc int64) (next string, err error)
```

incIpV4Address

English:

Receives an IP address in the form of a string and increments it\.

```
Input:
  ip:  only the ip address. e.g.: 10.0.0.1
  inc: number of increments

Output:
  next: the next ip address. e.g.: 10.0.0.2
  err: standard error object
```

Note:

```
* This function does not take into account the network configuration, use it with care!
```

Português:

Recebe um endereço IP na forma de string e incrementa o mesmo\.

```
Entrada:
  ip:  apenas o endereço ip. ex.: 10.0.0.1
  inc: quantidade de incrementos

Saída:
  next: o próximo endereço ip. ex.: 10.0.0.2
  err: objeto de erro padrão
```

Nota:

```
Esta função não considera a configuração da rede, use com cuidado!
```

### func \(\*ContainerBuilder\) [logsCleaner](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcLogsCleaner.go#L28>)

```go
func (e *ContainerBuilder) logsCleaner(logs []byte) (logsLine [][]byte)
```

logsCleaner

English:

```
Clear blank lines of the container's standard output

Input:
  logs: container's standard output

Output:
  logsLine: List of lines of the container's standard output
```

Português:

```
Limpa as linhas em branco da saída padrão do container

 Entrada:
   logs: saída padrão do container

 Saída:
   logsLine: Lista de linhas da saída padrão do container
```

### func \(\*ContainerBuilder\) [logsSearchAndReplaceIntoText](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcLogsSearchAndReplaceIntoText.go#L13>)

```go
func (e *ContainerBuilder) logsSearchAndReplaceIntoText(logs *[]byte, lineList [][]byte, configuration []LogFilter) (line []byte, found bool)
```

### func \(\*ContainerBuilder\) [managerChaos](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcManagerChaos.go#L15>)

```go
func (e *ContainerBuilder) managerChaos()
```

managerChaos

English: manages the log and state of the container

Português: gerencia o log e o estado do container

### func \(\*ContainerBuilder\) [selectBetweenMaxAndMin](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcSelectBetweenMaxAndMin.go#L5>)

```go
func (e *ContainerBuilder) selectBetweenMaxAndMin(max, min time.Duration) (selected time.Duration)
```

### func \(\*ContainerBuilder\) [stopMonitorAfterStopped](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcStopMonitorAfterStopped.go#L8>)

```go
func (e *ContainerBuilder) stopMonitorAfterStopped() (err error)
```

### func \(ContainerBuilder\) [traceCodeLine](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTraceCodeLine.go#L5>)

```go
func (e ContainerBuilder) traceCodeLine() (file string, line int)
```

### func \(\*ContainerBuilder\) [verifyImageName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcVerifyImageName.go#L14>)

```go
func (e *ContainerBuilder) verifyImageName() (err error)
```

verifyImageName

English: check if the image name has the version tag

Português: verifica se o nome da imagem tem a tag de versão

### func \(\*ContainerBuilder\) [verifyStatusError](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcVerifyStatusError.go#L8>)

```go
func (e *ContainerBuilder) verifyStatusError(inspect ContainerInspect) (hasError bool)
```

### func \(\*ContainerBuilder\) [writeAggregatePreCPUTimeTheContainerWasThrottled](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteAggregatePreCPUTimeTheContainerWasThrottled.go#L11>)

```go
func (e *ContainerBuilder) writeAggregatePreCPUTimeTheContainerWasThrottled(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeAggregateTimeTheContainerWasThrottledForInNanoseconds](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteAggregateTimeTheContainerWasThrottledForInNanoseconds.go#L11>)

```go
func (e *ContainerBuilder) writeAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoMergedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoMergedRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoQueuedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoQueuedRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoServiceBytesRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoServiceBytesRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoServiceTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoServiceTimeRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoServicedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoServicedRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoTimeRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioIoWaitTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioIoWaitTimeRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeBlkioSectorsRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteBlkioSectorsRecursive.go#L11>)

```go
func (e *ContainerBuilder) writeBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteCommittedBytes.go#L11>)

```go
func (e *ContainerBuilder) writeCommittedBytes(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstAggregatePreCPUTimeTheContainerWasThrottled](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstAggregatePreCPUTimeTheContainerWasThrottled.go#L9>)

```go
func (e *ContainerBuilder) writeConstAggregatePreCPUTimeTheContainerWasThrottled(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstAggregateTimeTheContainerWasThrottledForInNanoseconds](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstAggregateTimeTheContainerWasThrottledForInNanoseconds.go#L9>)

```go
func (e *ContainerBuilder) writeConstAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoMergedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoMergedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoQueuedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoQueuedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoServiceBytesRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoServiceBytesRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoServiceTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoServiceTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoServicedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoServicedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioIoWaitTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioIoWaitTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstBlkioSectorsRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstBlkioSectorsRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeConstBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstCommittedBytes.go#L9>)

```go
func (e *ContainerBuilder) writeConstCommittedBytes(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstCurrentNumberOfOidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstCurrentNumberOfOidsInTheCGroup.go#L9>)

```go
func (e *ContainerBuilder) writeConstCurrentNumberOfOidsInTheCGroup(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstCurrentResCounterUsageForMemory](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstCurrentResCounterUsageForMemory.go#L9>)

```go
func (e *ContainerBuilder) writeConstCurrentResCounterUsageForMemory(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstFilterIntoLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstFilterIntoLog.go#L10>)

```go
func (e *ContainerBuilder) writeConstFilterIntoLog(file *os.File, filter []LogFilter) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstLimitOnTheNumberOfPidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstLimitOnTheNumberOfPidsInTheCGroup.go#L9>)

```go
func (e *ContainerBuilder) writeConstLimitOnTheNumberOfPidsInTheCGroup(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstMaximumUsageEverRecorded](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstMaximumUsageEverRecorded.go#L9>)

```go
func (e *ContainerBuilder) writeConstMaximumUsageEverRecorded(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstMemoryLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstMemoryLimit.go#L9>)

```go
func (e *ContainerBuilder) writeConstMemoryLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit.go#L9>)

```go
func (e *ContainerBuilder) writeConstNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit.go#L9>)

```go
func (e *ContainerBuilder) writeConstNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstNumberOfPeriodsWithPreCPUThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstNumberOfPeriodsWithPreCPUThrottlingActive.go#L9>)

```go
func (e *ContainerBuilder) writeConstNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstNumberOfPeriodsWithThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstNumberOfPeriodsWithThrottlingActive.go#L9>)

```go
func (e *ContainerBuilder) writeConstNumberOfPeriodsWithThrottlingActive(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstNumberOfTimesMemoryUsageHitsLimits](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstNumberOfTimesMemoryUsageHitsLimits.go#L9>)

```go
func (e *ContainerBuilder) writeConstNumberOfTimesMemoryUsageHitsLimits(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstOnlineCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstOnlineCPUs.go#L9>)

```go
func (e *ContainerBuilder) writeConstOnlineCPUs(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstOnlinePreCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstOnlinePreCPUs.go#L9>)

```go
func (e *ContainerBuilder) writeConstOnlinePreCPUs(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstPeakCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstPeakCommittedBytes.go#L9>)

```go
func (e *ContainerBuilder) writeConstPeakCommittedBytes(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstPreCPUSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstPreCPUSystemUsage.go#L9>)

```go
func (e *ContainerBuilder) writeConstPreCPUSystemUsage(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstPrivateWorkingSet](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstPrivateWorkingSet.go#L9>)

```go
func (e *ContainerBuilder) writeConstPrivateWorkingSet(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstReadingTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstReadingTime.go#L9>)

```go
func (e *ContainerBuilder) writeConstReadingTime(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstSystemUsage.go#L9>)

```go
func (e *ContainerBuilder) writeConstSystemUsage(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTimeSpentByPreCPUTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTimeSpentByPreCPUTasksOfTheCGroupInKernelMode.go#L9>)

```go
func (e *ContainerBuilder) writeConstTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTimeSpentByPreCPUTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTimeSpentByPreCPUTasksOfTheCGroupInUserMode.go#L9>)

```go
func (e *ContainerBuilder) writeConstTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTimeSpentByTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTimeSpentByTasksOfTheCGroupInKernelMode.go#L9>)

```go
func (e *ContainerBuilder) writeConstTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTimeSpentByTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTimeSpentByTasksOfTheCGroupInUserMode.go#L9>)

```go
func (e *ContainerBuilder) writeConstTimeSpentByTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTotalCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTotalCPUTimeConsumed.go#L9>)

```go
func (e *ContainerBuilder) writeConstTotalCPUTimeConsumed(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTotalCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTotalCPUTimeConsumedPerCore.go#L9>)

```go
func (e *ContainerBuilder) writeConstTotalCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTotalPreCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTotalPreCPUTimeConsumed.go#L9>)

```go
func (e *ContainerBuilder) writeConstTotalPreCPUTimeConsumed(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeConstTotalPreCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteConstTotalPreCPUTimeConsumedPerCore.go#L9>)

```go
func (e *ContainerBuilder) writeConstTotalPreCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeContainerConstToFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteContainerConstToFile.go#L10>)

```go
func (e *ContainerBuilder) writeContainerConstToFile(file *os.File, stats *types.Stats) (err error)
```

### func \(\*ContainerBuilder\) [writeContainerLabelToFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteContainerLabelToFile.go#L10>)

```go
func (e *ContainerBuilder) writeContainerLabelToFile(file *os.File, stats *types.Stats) (err error)
```

### func \(\*ContainerBuilder\) [writeContainerLogToFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteContainerLogToFile.go#L14>)

```go
func (e *ContainerBuilder) writeContainerLogToFile(path string, lineList [][]byte) (err error)
```

writeContainerLogToFile

Português: Escreve um arquivo csv com dados capturados da saída padrão do container e dados estatísticos do container

### func \(\*ContainerBuilder\) [writeContainerStatsToFile](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteContainerStatsToFile.go#L10>)

```go
func (e *ContainerBuilder) writeContainerStatsToFile(file *os.File, stats *types.Stats, lineList *[][]byte) (err error)
```

### func \(\*ContainerBuilder\) [writeCurrentNumberOfOidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteCurrentNumberOfOidsInTheCGroup.go#L11>)

```go
func (e *ContainerBuilder) writeCurrentNumberOfOidsInTheCGroup(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeCurrentResCounterUsageForMemory](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteCurrentResCounterUsageForMemory.go#L11>)

```go
func (e *ContainerBuilder) writeCurrentResCounterUsageForMemory(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeFilterIntoLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteFilterIntoLog.go#L11>)

```go
func (e *ContainerBuilder) writeFilterIntoLog(file *os.File, filter []LogFilter, lineList *[][]byte) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelAggregatePreCPUTimeTheContainerWasThrottled](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelAggregatePreCPUTimeTheContainerWasThrottled.go#L9>)

```go
func (e *ContainerBuilder) writeLabelAggregatePreCPUTimeTheContainerWasThrottled(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelAggregateTimeTheContainerWasThrottledForInNanoseconds](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelAggregateTimeTheContainerWasThrottledForInNanoseconds.go#L9>)

```go
func (e *ContainerBuilder) writeLabelAggregateTimeTheContainerWasThrottledForInNanoseconds(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoMergedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoMergedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoMergedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoQueuedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoQueuedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoQueuedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoServiceBytesRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoServiceBytesRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoServiceBytesRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoServiceTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoServiceTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoServiceTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoServicedRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoServicedRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoServicedRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioIoWaitTimeRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioIoWaitTimeRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioIoWaitTimeRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelBlkioSectorsRecursive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelBlkioSectorsRecursive.go#L10>)

```go
func (e *ContainerBuilder) writeLabelBlkioSectorsRecursive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelCommittedBytes.go#L9>)

```go
func (e *ContainerBuilder) writeLabelCommittedBytes(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelCurrentNumberOfOidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelCurrentNumberOfOidsInTheCGroup.go#L9>)

```go
func (e *ContainerBuilder) writeLabelCurrentNumberOfOidsInTheCGroup(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelCurrentResCounterUsageForMemory](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelCurrentResCounterUsageForMemory.go#L9>)

```go
func (e *ContainerBuilder) writeLabelCurrentResCounterUsageForMemory(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelFilterIntoLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelFilterIntoLog.go#L10>)

```go
func (e *ContainerBuilder) writeLabelFilterIntoLog(file *os.File, filter []LogFilter) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelLimitOnTheNumberOfPidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelLimitOnTheNumberOfPidsInTheCGroup.go#L9>)

```go
func (e *ContainerBuilder) writeLabelLimitOnTheNumberOfPidsInTheCGroup(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelMaximumUsageEverRecorded](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelMaximumUsageEverRecorded.go#L9>)

```go
func (e *ContainerBuilder) writeLabelMaximumUsageEverRecorded(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelMemoryLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelMemoryLimit.go#L9>)

```go
func (e *ContainerBuilder) writeLabelMemoryLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit.go#L9>)

```go
func (e *ContainerBuilder) writeLabelNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit.go#L9>)

```go
func (e *ContainerBuilder) writeLabelNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelNumberOfPeriodsWithPreCPUThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelNumberOfPeriodsWithPreCPUThrottlingActive.go#L9>)

```go
func (e *ContainerBuilder) writeLabelNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelNumberOfPeriodsWithThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelNumberOfPeriodsWithThrottlingActive.go#L9>)

```go
func (e *ContainerBuilder) writeLabelNumberOfPeriodsWithThrottlingActive(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelNumberOfTimesMemoryUsageHitsLimits](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelNumberOfTimesMemoryUsageHitsLimits.go#L9>)

```go
func (e *ContainerBuilder) writeLabelNumberOfTimesMemoryUsageHitsLimits(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelOnlineCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelOnlineCPUs.go#L9>)

```go
func (e *ContainerBuilder) writeLabelOnlineCPUs(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelOnlinePreCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelOnlinePreCPUs.go#L9>)

```go
func (e *ContainerBuilder) writeLabelOnlinePreCPUs(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelPeakCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelPeakCommittedBytes.go#L9>)

```go
func (e *ContainerBuilder) writeLabelPeakCommittedBytes(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelPreCPUSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelPreCPUSystemUsage.go#L9>)

```go
func (e *ContainerBuilder) writeLabelPreCPUSystemUsage(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelPrivateWorkingSet](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelPrivateWorkingSet.go#L9>)

```go
func (e *ContainerBuilder) writeLabelPrivateWorkingSet(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelReadingTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelReadingTime.go#L9>)

```go
func (e *ContainerBuilder) writeLabelReadingTime(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelSystemUsage.go#L9>)

```go
func (e *ContainerBuilder) writeLabelSystemUsage(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTimeSpentByPreCPUTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTimeSpentByPreCPUTasksOfTheCGroupInKernelMode.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTimeSpentByPreCPUTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTimeSpentByPreCPUTasksOfTheCGroupInUserMode.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTimeSpentByTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTimeSpentByTasksOfTheCGroupInKernelMode.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTimeSpentByTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTimeSpentByTasksOfTheCGroupInUserMode.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTimeSpentByTasksOfTheCGroupInUserMode(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTotalCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTotalCPUTimeConsumed.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTotalCPUTimeConsumed(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTotalCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTotalCPUTimeConsumedPerCore.go#L10>)

```go
func (e *ContainerBuilder) writeLabelTotalCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTotalPreCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTotalPreCPUTimeConsumed.go#L9>)

```go
func (e *ContainerBuilder) writeLabelTotalPreCPUTimeConsumed(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLabelTotalPreCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLabelTotalPreCPUTimeConsumedPerCore.go#L10>)

```go
func (e *ContainerBuilder) writeLabelTotalPreCPUTimeConsumedPerCore(file *os.File) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeLimitOnTheNumberOfPidsInTheCGroup](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteLimitOnTheNumberOfPidsInTheCGroup.go#L11>)

```go
func (e *ContainerBuilder) writeLimitOnTheNumberOfPidsInTheCGroup(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeMaximumUsageEverRecorded](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteMaximumUsageEverRecorded.go#L11>)

```go
func (e *ContainerBuilder) writeMaximumUsageEverRecorded(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeMemoryLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteMemoryLimit.go#L11>)

```go
func (e *ContainerBuilder) writeMemoryLimit(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit.go#L11>)

```go
func (e *ContainerBuilder) writeNumberOfPeriodsWhenTheContainerHitsItsThrottlingLimit(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit.go#L11>)

```go
func (e *ContainerBuilder) writeNumberOfPeriodsWhenTheContainerPreCPUHitsItsThrottlingLimit(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeNumberOfPeriodsWithPreCPUThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteNumberOfPeriodsWithPreCPUThrottlingActive.go#L11>)

```go
func (e *ContainerBuilder) writeNumberOfPeriodsWithPreCPUThrottlingActive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeNumberOfPeriodsWithThrottlingActive](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteNumberOfPeriodsWithThrottlingActive.go#L11>)

```go
func (e *ContainerBuilder) writeNumberOfPeriodsWithThrottlingActive(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeNumberOfTimesMemoryUsageHitsLimits](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteNumberOfTimesMemoryUsageHitsLimits.go#L11>)

```go
func (e *ContainerBuilder) writeNumberOfTimesMemoryUsageHitsLimits(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeOnlineCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteOnlineCPUs.go#L11>)

```go
func (e *ContainerBuilder) writeOnlineCPUs(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeOnlinePreCPUs](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteOnlinePreCPUs.go#L11>)

```go
func (e *ContainerBuilder) writeOnlinePreCPUs(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writePeakCommittedBytes](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWritePeakCommittedBytes.go#L11>)

```go
func (e *ContainerBuilder) writePeakCommittedBytes(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writePreCPUSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWritePreCPUSystemUsage.go#L11>)

```go
func (e *ContainerBuilder) writePreCPUSystemUsage(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writePrivateWorkingSet](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWritePrivateWorkingSet.go#L11>)

```go
func (e *ContainerBuilder) writePrivateWorkingSet(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeReadingTime](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteReadingTime.go#L10>)

```go
func (e *ContainerBuilder) writeReadingTime(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeSystemUsage](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteSystemUsage.go#L11>)

```go
func (e *ContainerBuilder) writeSystemUsage(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTimeSpentByPreCPUTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTimeSpentByPreCPUTasksOfTheCGroupInKernelMode.go#L11>)

```go
func (e *ContainerBuilder) writeTimeSpentByPreCPUTasksOfTheCGroupInKernelMode(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTimeSpentByPreCPUTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTimeSpentByPreCPUTasksOfTheCGroupInUserMode.go#L11>)

```go
func (e *ContainerBuilder) writeTimeSpentByPreCPUTasksOfTheCGroupInUserMode(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTimeSpentByTasksOfTheCGroupInKernelMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTimeSpentByTasksOfTheCGroupInKernelMode.go#L11>)

```go
func (e *ContainerBuilder) writeTimeSpentByTasksOfTheCGroupInKernelMode(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTimeSpentByTasksOfTheCGroupInUserMode](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTimeSpentByTasksOfTheCGroupInUserMode.go#L11>)

```go
func (e *ContainerBuilder) writeTimeSpentByTasksOfTheCGroupInUserMode(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTotalCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTotalCPUTimeConsumed.go#L11>)

```go
func (e *ContainerBuilder) writeTotalCPUTimeConsumed(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTotalCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTotalCPUTimeConsumedPerCore.go#L11>)

```go
func (e *ContainerBuilder) writeTotalCPUTimeConsumedPerCore(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTotalPreCPUTimeConsumed](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTotalPreCPUTimeConsumed.go#L11>)

```go
func (e *ContainerBuilder) writeTotalPreCPUTimeConsumed(file *os.File, stats *types.Stats) (tab bool, err error)
```

### func \(\*ContainerBuilder\) [writeTotalPreCPUTimeConsumedPerCore](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcWriteTotalPreCPUTimeConsumedPerCore.go#L11>)

```go
func (e *ContainerBuilder) writeTotalPreCPUTimeConsumedPerCore(file *os.File, stats *types.Stats) (tab bool, err error)
```

## type [DockerfileAuto](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeDockerfileAuto.go#L211-L214>)

### DockerfileAuto

English: Interface from automatic Dockerfile generator\.

```
Note: To be able to access private repositories from inside the container, build the image in two or more
steps and in the first step, copy the id_rsa and known_hosts files to the /root/.ssh folder and the .gitconfig
file to the /root folder.

One way to do this automatically is to use the Dockerfile example below, where the arguments SSH_ID_RSA_FILE
contains the file ~/.ssh/id_rsa, KNOWN_HOSTS_FILE contains the file ~/.ssh/known_hosts and GITCONFIG_FILE
contains the file ~/.gitconfig.

If the ~/.ssh/id_rsa key is password protected, use the SetGitSshPassword() function to set the password.

If you want to copy the files into the image automatically, use SetPrivateRepositoryAutoConfig() and the
function will copy the files ~/.ssh/id_rsa, ~/.ssh/known_hosts and ~/.gitconfig to the viable arguments
located above.

If you want to define the files manually, use SetGitConfigFile(), SetSshKnownHostsFile() and SetSshIdRsaFile()
to define the files manually.

The Dockerfile below can be used as a base

  # (en) first stage of the process
  # (pt) primeira etapa do processo
  FROM golang:1.16-alpine as builder

  # (en) enable the argument variables
  # (pt) habilita as variáveis de argumento
  ARG SSH_ID_RSA_FILE
  ARG KNOWN_HOSTS_FILE
  ARG GITCONFIG_FILE
  ARG GIT_PRIVATE_REPO

  # (en) creates the .ssh directory within the root directory
  # (pt) cria o diretório .ssh dentro do diretório root
  RUN mkdir -p /root/.ssh/ && \
      # (en) creates the id_esa file inside the .ssh directory
      # (pt) cria o arquivo id_esa dentro do diretório .ssh
      echo "$SSH_ID_RSA_FILE" > /root/.ssh/id_rsa && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.ssh/ && \
      # (en) creates the known_hosts file inside the .ssh directory
      # (pt) cria o arquivo known_hosts dentro do diretório .ssh
      echo "$KNOWN_HOSTS_FILE" > /root/.ssh/known_hosts && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.ssh/known_hosts && \
      # (en) creates the .gitconfig file at the root of the root directory
      # (pt) cria o arquivo .gitconfig na raiz do diretório /root
      echo "$GITCONFIG_FILE" > /root/.gitconfig && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.gitconfig && \
      # (en) prepares the OS for installation
      # (pt) prepara o OS para instalação
      apk update && \
      # (en) install git and openssh
      # (pt) instala o git e o opnssh
      apk add --no-cache build-base git openssh && \
      # (en) clear the cache
      # (pt) limpa a cache
      rm -rf /var/cache/apk/*

  # (en) creates the /app directory, where your code will be installed
  # (pt) cria o diretório /app, onde seu código vai ser instalado
  WORKDIR /app
  # (en) copy your project into the /app folder
  # (pt) copia seu projeto para dentro da pasta /app
  COPY . .
  # (en) enables the golang compiler to run on an extremely simple OS, scratch
  # (pt) habilita o compilador do golang para rodar em um OS extremamente simples, o scratch
  ARG CGO_ENABLED=0
  # (en) adjust git to work with shh
  # (pt) ajusta o git para funcionar com shh
  RUN git config --global url.ssh://git@github.com/.insteadOf https://github.com/
  # (en) defines the path of the private repository
  # (pt) define o caminho do repositório privado
  RUN echo "go env -w GOPRIVATE=$GIT_PRIVATE_REPO"
  # (en) install the dependencies in the go.mod file
  # (pt) instala as dependências no arquivo go.mod
  RUN go mod tidy
  # (en) compiles the main.go file
  # (pt) compila o arquivo main.go
  RUN go build -ldflags="-w -s" -o /app/main /app/main.go
  # (en) creates a new scratch-based image
  # (pt) cria uma nova imagem baseada no scratch
  # (en) scratch is an extremely simple OS capable of generating very small images
  # (pt) o scratch é um OS extremamente simples capaz de gerar imagens muito reduzidas
  # (en) discarding the previous image erases git access credentials for your security and reduces the size of the
  #      image to save server space
  # (pt) descartar a imagem anterior apaga as credenciais de acesso ao git para a sua segurança e reduz o tamanho
  #      da imagem para poupar espaço no servidor
  FROM scratch
  # (en) copy your project to the new image
  # (pt) copia o seu projeto para a nova imagem
  COPY --from=builder /app/main .
  # (en) execute your project
  # (pt) executa o seu projeto
  CMD ["/main"]
```

Português: Interface do gerador de dockerfile automático\.

```
Nota: Para conseguir acessar repositórios privados de dentro do container, construa a imagem em duas ou mais
etapas e na primeira etapa, copie os arquivos id_rsa e known_hosts para a pasta /root/.ssh e o arquivo
.gitconfig para a pasta /root/.

Uma maneira de fazer isto de forma automática é usar o exemplo de Dockerfile abaixo, onde os argumentos
SSH_ID_RSA_FILE contém o arquivo ~/.ssh/id_rsa, KNOWN_HOSTS_FILE contém o arquivo ~/.ssh/known_hosts e
GITCONFIG_FILE contém o arquivo ~/.gitconfig.

Caso a chave ~/.ssh/id_rsa seja protegida com senha, use a função SetGitSshPassword() para definir a senha da
mesma.

Caso você queira copiar os arquivos para dentro da imagem de forma automática, use
SetPrivateRepositoryAutoConfig() e a função copiará os arquivos ~/.ssh/id_rsa, ~/.ssh/known_hosts e
~/.gitconfig para as viáveis de argumentos sitada anteriormente.

Caso queira definir os arquivos de forma manual, use SetGitConfigFile(), SetSshKnownHostsFile() e
SetSshIdRsaFile() para definir os arquivos de forma manual.

O arquivo Dockerfile abaixo pode ser usado como base

  # (en) first stage of the process
  # (pt) primeira etapa do processo
  FROM golang:1.16-alpine as builder

  # (en) enable the argument variables
  # (pt) habilita as variáveis de argumento
  ARG SSH_ID_RSA_FILE
  ARG KNOWN_HOSTS_FILE
  ARG GITCONFIG_FILE
  ARG GIT_PRIVATE_REPO

  # (en) creates the .ssh directory within the root directory
  # (pt) cria o diretório .ssh dentro do diretório root
  RUN mkdir -p /root/.ssh/ && \
      # (en) creates the id_esa file inside the .ssh directory
      # (pt) cria o arquivo id_esa dentro do diretório .ssh
      echo "$SSH_ID_RSA_FILE" > /root/.ssh/id_rsa && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.ssh/ && \
      # (en) creates the known_hosts file inside the .ssh directory
      # (pt) cria o arquivo known_hosts dentro do diretório .ssh
      echo "$KNOWN_HOSTS_FILE" > /root/.ssh/known_hosts && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.ssh/known_hosts && \
      # (en) creates the .gitconfig file at the root of the root directory
      # (pt) cria o arquivo .gitconfig na raiz do diretório /root
      echo "$GITCONFIG_FILE" > /root/.gitconfig && \
      # (en) adjust file access security
      # (pt) ajusta a segurança de acesso do arquivo
      chmod -R 600 /root/.gitconfig && \
      # (en) prepares the OS for installation
      # (pt) prepara o OS para instalação
      apk update && \
      # (en) install git and openssh
      # (pt) instala o git e o opnssh
      apk add --no-cache build-base git openssh && \
      # (en) clear the cache
      # (pt) limpa a cache
      rm -rf /var/cache/apk/*

  # (en) creates the /app directory, where your code will be installed
  # (pt) cria o diretório /app, onde seu código vai ser instalado
  WORKDIR /app
  # (en) copy your project into the /app folder
  # (pt) copia seu projeto para dentro da pasta /app
  COPY . .
  # (en) enables the golang compiler to run on an extremely simple OS, scratch
  # (pt) habilita o compilador do golang para rodar em um OS extremamente simples, o scratch
  ARG CGO_ENABLED=0
  # (en) adjust git to work with shh
  # (pt) ajusta o git para funcionar com shh
  RUN git config --global url.ssh://git@github.com/.insteadOf https://github.com/
  # (en) defines the path of the private repository
  # (pt) define o caminho do repositório privado
  RUN echo "go env -w GOPRIVATE=$GIT_PRIVATE_REPO"
  # (en) install the dependencies in the go.mod file
  # (pt) instala as dependências no arquivo go.mod
  RUN go mod tidy
  # (en) compiles the main.go file
  # (pt) compila o arquivo main.go
  RUN go build -ldflags="-w -s" -o /app/main /app/main.go
  # (en) creates a new scratch-based image
  # (pt) cria uma nova imagem baseada no scratch
  # (en) scratch is an extremely simple OS capable of generating very small images
  # (pt) o scratch é um OS extremamente simples capaz de gerar imagens muito reduzidas
  # (en) discarding the previous image erases git access credentials for your security and reduces the size of the
  #      image to save server space
  # (pt) descartar a imagem anterior apaga as credenciais de acesso ao git para a sua segurança e reduz o tamanho
  #      da imagem para poupar espaço no servidor
  FROM scratch
  # (en) copy your project to the new image
  # (pt) copia o seu projeto para a nova imagem
  COPY --from=builder /app/main .
  # (en) execute your project
  # (pt) executa o seu projeto
  CMD ["/main"]
```

```go
type DockerfileAuto interface {
    MountDefaultDockerfile(args map[string]*string, changePorts []dockerfileGolang.ChangePort, openPorts []string, exposePorts []string, volumes []mount.Mount, installExtraPackages bool, useCache bool, imageCacheName string) (dockerfile string, err error)
    Prayer()
}
```

## type [Event](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeEvent.go#L3-L10>)

```go
type Event struct {
    ContainerName string
    Message       string
    Error         bool
    Done          bool
    Fail          bool
    Metadata      map[string]interface{}
}
```

### func \(\*Event\) [clear](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeEvent.go#L12>)

```go
func (e *Event) clear()
```

## type [HealthConfig](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeHealthConfig.go#L12-L30>)

### HealthConfig

English: holds configuration settings for the HEALTHCHECK feature\.

Português: contém as configurações para o HEALTHCHECK

```go
type HealthConfig struct {
    // Test is the test to perform to check that the container is healthy.
    // An empty slice means to inherit the default.
    // The options are:
    // {} : inherit healthcheck
    // {"NONE"} : disable healthcheck
    // {"CMD", args...} : exec arguments directly
    // {"CMD-SHELL", command} : run command with system's default shell
    Test []string `json:",omitempty"`

    // Zero means to inherit. Durations are expressed as integer nanoseconds.
    Interval    time.Duration `json:",omitempty"` // Interval is the time to wait between checks.
    Timeout     time.Duration `json:",omitempty"` // Timeout is the time to wait before considering the check to have hung.
    StartPeriod time.Duration `json:",omitempty"` // The start period for the container to initialize before the retries starts to count down.

    // Retries is the number of consecutive failures needed to consider a container as unhealthy.
    // Zero means inherit.
    Retries int `json:",omitempty"`
}
```

## type [LogFilter](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeLogFilter.go#L3-L20>)

```go
type LogFilter struct {
    Label string

    // Texto contido na linha (tudo ou nada)
    Match string

    // expressão regular contendo o filtro para capturar o elemento
    // Ex.: ^(.*?)(?P<valueToGet>\\d+)(.*)
    Filter string

    // texto usado em replaceAll
    // Ex.: search: "." replace: "," para compatibilizar número com o excel
    Search  string
    Replace string

    // path to sabe container default output into file format
    LogPath string
}
```

## type [MemoryStats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeMemoryStats.go#L5-L27>)

MemoryStats aggregates all memory stats since container inception on Linux\. Windows returns stats for commit and private working set only\.

```go
type MemoryStats struct {

    // current res_counter usage for memory
    Usage uint64 `json:"usage,omitempty"`
    // maximum usage ever recorded.
    MaxUsage uint64 `json:"max_usage,omitempty"`
    // all the stats exported via memory.stat.
    Stats map[string]uint64 `json:"stats,omitempty"`
    // number of times memory usage hits limits.
    Failcnt uint64 `json:"failcnt,omitempty"`
    Limit   uint64 `json:"limit,omitempty"`

    // committed bytes
    Commit uint64 `json:"commitbytes,omitempty"`
    // peak committed bytes
    CommitPeak uint64 `json:"commitpeakbytes,omitempty"`
    // private working set
    PrivateWorkingSet uint64 `json:"privateworkingset,omitempty"`
}
```

## type [NameAndId](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNameAndId.go#L3-L6>)

```go
type NameAndId struct {
    ID   string
    Name string
}
```

## type [NetworkChaos](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L12-L21>)

```go
type NetworkChaos struct {
    imageName     string
    builder       *ContainerBuilder
    overload      *ContainerBuilder
    network       isolatedNetwork.ContainerBuilderNetworkInterface
    containerName string
    listenPort    int
    outputPort    int
    invert        bool
}
```

### func \(\*NetworkChaos\) [Init](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L49>)

```go
func (e *NetworkChaos) Init() (err error)
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"context"
	"fmt"
	dockerNetwork "github.com/helmutkemper/iotmaker.docker.builder.network"
	"github.com/helmutkemper/util"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"log"
	"time"
)

func main() {
	var err error

	SaGarbageCollector()

	var netDocker = &dockerNetwork.ContainerBuilderNetwork{}
	err = netDocker.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = netDocker.NetworkCreate("cache_delete_after_test", "10.0.0.0/16", "10.0.0.1")
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var mongoDocker = &ContainerBuilder{}
	mongoDocker.SetNetworkDocker(netDocker)
	mongoDocker.SetImageName("mongo:latest")
	mongoDocker.SetContainerName("container_delete_mongo_after_test")
	//mongoDocker.AddPortToChange("27017", "27016")
	//mongoDocker.AddPortToExpose("27017")
	mongoDocker.SetEnvironmentVar(
		[]string{
			"--bind_ip_all",
			"--host 0.0.0.0",
			"--bind 0.0.0.0",
		},
	)
	mongoDocker.SetWaitStringWithTimeout(`"msg":"Waiting for connections","attr":{"port":27017`, 20*time.Second)
	err = mongoDocker.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = mongoDocker.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var redis = ContainerBuilder{}
	redis.SetNetworkDocker(netDocker)
	redis.SetImageName("redis:latest")
	redis.SetContainerName("container_delete_redis_test")
	redis.AddPortToExpose("6379")
	redis.SetWaitStringWithTimeout("Ready to accept connections", 10*time.Second)

	err = redis.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = redis.ContainerBuildAndStartFromImage()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	var chaos = NetworkChaos{}
	chaos.SetNetworkDocker(netDocker)
	chaos.SetFatherContainer(mongoDocker)
	chaos.SetPorts(27017, 27016, false)
	err = chaos.Init()
	if err != nil {
		util.TraceToLog()
		panic(err)
	}

	err = testNetworkOverloaded(
		"mongodb://0.0.0.0:27016",
		2*time.Second,
	)

	if err != nil {
		util.TraceToLog()
		panic(err)
	}

}

// testNetworkOverloaded (English): Tests the new network port
// testNetworkOverloaded (Português): Testa a nova porta de rede
func testNetworkOverloaded(
	address string,
	timeout time.Duration,
) (
	err error,
) {

	// (English): Runtime measurement starts
	// (Português): Começa a medição do tempo de execução
	start := time.Now()

	var mongoClient *mongo.Client
	var cancel context.CancelFunc
	var ctx context.Context

	// (English): Prepare the MongoDB client
	// (Português): Prepara o cliente do MongoDB
	mongoClient, err = mongo.NewClient(options.Client().ApplyURI(address))
	if err != nil {
		return
	}

	// (English): Connects to MongoDB
	// (Português): Conecta ao MongoDB
	err = mongoClient.Connect(ctx)
	if err != nil {
		return
	}

	// (English): Prepares the timeout
	// (Português): Prepara o tempo limite
	ctx, cancel = context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// (English): Ping() to test the MongoDB connection
	// (Português): Faz um ping() para testar a conexão do MongoDB
	err = mongoClient.Ping(ctx, readpref.Primary())
	if err != nil {
		return
	}

	// (English): New collection format
	// (Português): Formato da nova coleção
	type Trainer struct {
		Name string
		Age  int
		City string
	}

	// (English): Creates the 'test' bank and the 'dinos' collection
	// (Português): Cria o banco 'test' e a coleção 'dinos'
	collection := mongoClient.Database("test").Collection("dinos")

	// (English): Prepares the data to be inserted
	// (Português): Prepara os dados a serem inseridos
	trainerData := Trainer{"T-Rex", 10, "Jurassic Town"}

	for i := 0; i != 100; i += 1 {
		// (English): Insert the data
		// (Português): Insere os dados
		_, err = collection.InsertOne(context.TODO(), trainerData)
		if err != nil {
			log.Printf("collection.InsertOne().error: %v", err)
			return
		}
	}

	// (English): Stop the operation time measurement
	// (Português): Para a medição de tempo da operação
	duration := time.Since(start)
	fmt.Printf("End!\n")
	fmt.Printf("Duration: %v\n\n", duration)

	return
}
```

#### Output

```

```

</p>
</details>

### func \(\*NetworkChaos\) [SetContainerName](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L39>)

```go
func (e *NetworkChaos) SetContainerName(value string)
```

### func \(\*NetworkChaos\) [SetFatherContainer](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L35>)

```go
func (e *NetworkChaos) SetFatherContainer(fatherContainer *ContainerBuilder)
```

### func \(\*NetworkChaos\) [SetNetworkDocker](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L31>)

```go
func (e *NetworkChaos) SetNetworkDocker(network isolatedNetwork.ContainerBuilderNetworkInterface)
```

SetNetworkDocker \(english\):

SetNetworkDocker \(português\): Define o ponteiro do gerenciador de rede docker Entrada: network: ponteiro para o objeto gerenciador de rede\.

```
Nota: - A entrada network deve ser compatível com a interface
        dockerBuilderNetwork.ContainerBuilderNetwork{}
```

### func \(\*NetworkChaos\) [SetPorts](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L43>)

```go
func (e *NetworkChaos) SetPorts(listenPort, outputPort int, invert bool)
```

### func \(\*NetworkChaos\) [imageExists](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeNetworkChaos.go#L165>)

```go
func (e *NetworkChaos) imageExists() (exists bool)
```

## type [PidsStats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typePidsStats.go#L4-L10>)

PidsStats contains the stats of a container's pids

```go
type PidsStats struct {
    // Current is the number of pids in the cgroup
    Current uint64 `json:"current,omitempty"`
    // Limit is the hard limit on the number of pids in the cgroup.
    // A "Limit" of 0 means that there is no limit.
    Limit uint64 `json:"limit,omitempty"`
}
```

## type [Restart](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeRestart.go#L5-L12>)

```go
type Restart struct {
    FilterToStart      []LogFilter
    TimeToStart        Timers
    RestartProbability float64
    RestartLimit       int

    minimumEventTime time.Time
}
```

## type [Stats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeStats.go#L8-L25>)

Stats is Ultimate struct aggregating all types of stats of one container

```go
type Stats struct {
    // Common stats
    Read    time.Time `json:"read"`
    PreRead time.Time `json:"preread"`

    // Linux specific stats, not populated on Windows.
    PidsStats  PidsStats  `json:"pids_stats,omitempty"`
    BlkioStats BlkioStats `json:"blkio_stats,omitempty"`

    // Windows specific stats, not populated on Linux.
    NumProcs     uint32       `json:"num_procs"`
    StorageStats StorageStats `json:"storage_stats,omitempty"`

    // Shared stats
    CPUStats    CPUStats    `json:"cpu_stats,omitempty"`
    PreCPUStats CPUStats    `json:"precpu_stats,omitempty"` // "Pre"="Previous"
    MemoryStats MemoryStats `json:"memory_stats,omitempty"`
}
```

## type [StorageStats](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeStorageStats.go#L4-L9>)

StorageStats is the disk I/O stats for read/write on Windows\.

```go
type StorageStats struct {
    ReadCountNormalized  uint64 `json:"read_count_normalized,omitempty"`
    ReadSizeBytes        uint64 `json:"read_size_bytes,omitempty"`
    WriteCountNormalized uint64 `json:"write_count_normalized,omitempty"`
    WriteSizeBytes       uint64 `json:"write_size_bytes,omitempty"`
}
```

## type [TestContainerLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L138-L140>)

```go
type TestContainerLog struct {
    data [][][]byte
}
```

### func \(\*TestContainerLog\) [fileToDataFormat](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L172>)

```go
func (e *TestContainerLog) fileToDataFormat(path string, t *testing.T) (problem pb.Problem)
```

### func \(TestContainerLog\) [findKeyIndex](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L226>)

```go
func (e TestContainerLog) findKeyIndex(key string, t *testing.T) (index int, problem pb.Problem)
```

### func \(\*TestContainerLog\) [makeTest](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L142>)

```go
func (e *TestContainerLog) makeTest(path string, listUnderTest *[]parserLog, t *testing.T) (problem pb.Problem)
```

### func \(TestContainerLog\) [proccessKeyList](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L247>)

```go
func (e TestContainerLog) proccessKeyList(listUnderTest *[]parserLog, t *testing.T) (problem pb.Problem)
```

## type [Theater](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L29-L32>)

### Theater

English: Theater is the collection of scene

Português: Teatro é a coleção de cenas

```go
type Theater struct {
    s   sync.Mutex
    m   map[string]scene
}
```

### func \(\*Theater\) [ConfigScene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L59>)

```go
func (e *Theater) ConfigScene(sceneName string, maxStopedContainers, maxPausedContainers, maxTotalPausedAndStoppedContainers int)
```

#### ConfigScene

English: Create and configure a new scene\. Input: sceneName: unique name of the scene maxStopedContainers: maximum number of stopped containers maxPausedContainers: maximum number of paused containers

Português: Cria e configura uma cena nova\. Entrada: sceneName: nome único da cena maxStopedContainers: quantidade máxima de containers parados maxPausedContainers: quantidade máxima de containers pausados

### func \(\*Theater\) [Init](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L39>)

```go
func (e *Theater) Init()
```

#### Init

English: Initialization must always be the first function called\.

Português: A inicialização sempre deve ser a primeira função chamada\.

### func \(\*Theater\) [SetContainerPaused](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L109>)

```go
func (e *Theater) SetContainerPaused(sceneName string) (doNotPauseContainer bool)
```

#### SetContainerPaused

English: Increments the paused containers counter Input: sceneName: unique name of the scene Output: doNotPauseContainer: the maximum number of containers has been reached

Português: Incrementa o contador de containers pausados Entrada: sceneName: nome único da cena Saída: doNotPauseContainer: a quantidade máxima de containers foi atingida

### func \(\*Theater\) [SetContainerStopped](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L143>)

```go
func (e *Theater) SetContainerStopped(sceneName string) (IsOnTheEdge bool)
```

#### SetContainerStopped

English: Increments the stopped containers counter Input: sceneName: unique name of the scene Output: IsOnTheEdge: the maximum number of containers has been reached

Português: Incrementa o contador de containers parados Entrada: sceneName: nome único da cena Saída: IsOnTheEdge: a quantidade máxima de containers foi atingida

### func \(\*Theater\) [SetContainerUnPaused](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L83>)

```go
func (e *Theater) SetContainerUnPaused(sceneName string)
```

#### SetContainerUnPaused

English: Decreases the paused containers counter

```
Input:
  sceneName: unique name of the scene
```

Português: Decrementa o contador de containers pausados

```
Entrada:
  sceneName: nome único da cena
```

### func \(\*Theater\) [SetContainerUnStopped](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L173>)

```go
func (e *Theater) SetContainerUnStopped(sceneName string)
```

#### SetContainerUnStopped

English: Decreases the stopped containers counter Input: sceneName: unique name of the scene

Português: Decrementa o contador de containers parados Entrada: sceneName: nome único da cena

## type [ThrottlingData](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeThrottlingData.go#L5-L12>)

ThrottlingData stores CPU throttling stats of one running container\. Not used on Windows\.

```go
type ThrottlingData struct {
    // Number of periods with throttling active
    Periods uint64 `json:"periods"`
    // Number of periods when the container hits its throttling limit.
    ThrottledPeriods uint64 `json:"throttled_periods"`
    // Aggregate time the container was throttled for in nanoseconds.
    ThrottledTime uint64 `json:"throttled_time"`
}
```

## type [Timers](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeTimers.go#L5-L8>)

```go
type Timers struct {
    Min time.Duration
    Max time.Duration
}
```

## type [chaos](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeChaos.go#L14-L53>)

chaos

English:

Object chaos manager

Português:

Objeto gerenciador de caos

```go
type chaos struct {
    foundSuccess               bool
    foundFail                  bool
    filterToStart              []LogFilter
    filterRestart              []LogFilter
    filterSuccess              []LogFilter
    filterFail                 []LogFilter
    filterLog                  []LogFilter
    sceneName                  string
    logPath                    string
    serviceStartedAt           time.Time
    minimumTimeBeforeRestart   time.Duration
    maximumTimeBeforeRestart   time.Duration
    minimumTimeToStartChaos    time.Duration
    maximumTimeToStartChaos    time.Duration
    minimumTimeToPause         time.Duration
    maximumTimeToPause         time.Duration
    minimumTimeToUnpause       time.Duration
    maximumTimeToUnpause       time.Duration
    minimumTimeToRestart       time.Duration
    maximumTimeToRestart       time.Duration
    restartProbability         float64
    restartChangeIpProbability float64
    restartLimit               int
    enableChaos                bool
    event                      chan Event
    monitorStop                chan struct{}
    monitorRunning             bool
    //containerStarted         bool
    containerPaused          bool
    containerStopped         bool
    linear                   bool
    chaosStarted             bool
    chaosCanRestartContainer bool
    //chaosCanRestartEnd       bool
    eventNext time.Time

    disableStopContainer  bool
    disablePauseContainer bool
}
```

## type [gitData](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeGitData.go#L8-L14>)

gitData

English: struct based on go\-git framework

Português: Estrutura de dados baseada no framework go\-git

```go
type gitData struct {
    url               string
    sshPrivateKeyPath string
    privateToke       string
    user              string
    password          string
}
```

## type [parserLog](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/funcTestLogFile.go#L132-L136>)

```go
type parserLog struct {
    Label string
    Key   string
    Rule  string
}
```

## type [scene](<https://github.com/helmutkemper/iotmaker.docker.builder/blob/main/typeScene.go#L16-L22>)

scene

English: Determines the maximum number of stopped and paused containers per scene\. The scene grants some control over the chaos in container testing\, preventing all containers in a scene from pausing or stopping at the same time\.

Português: Determina os números máximos de containers parados e pausados por cena\. A cena garante algum controle sobre o caos no teste dos container\, impedindo que todos os containers de uma cena sejam pausando ou parados ao mesmo tempo\.

```go
type scene struct {
    StopedContainers                   int
    PausedContainers                   int
    MaxStopedContainers                int
    MaxPausedContainers                int
    MaxTotalPausedAndStoppedContainers int
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
